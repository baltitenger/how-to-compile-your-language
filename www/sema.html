<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="chrome=1" />
        <title>How to Compile Your Language</title>
        <link rel="icon" href="./favicon.ico" />
        <link rel="stylesheet" href="stylesheets/styles.css" />
        <link rel="stylesheet" href="stylesheets/pygment_trac.css" />
        <meta name="viewport" content="width=device-width" />
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="wrapper">
            <header>
                <ul>
                    <li>
                        <a href="index.html">Intro </a>
                    </li>
                    <li><a href="lexing.html">Lexing</a></li>
                    <li><a href="parsing.html">Parsing</a></li>
                    <li>
                        <a href="extending-the-parser.html"
                            >Extending the Language</a
                        >
                    </li>
                    <li>
                        <a href="sema.html">Semantic Analysis</a>
                        <div id="toc"></div>
                    </li>
                    <li><a href="codegen.html">Generating LLVM IR</a></li>
                    <li><a href="driver.html">Driver</a></li>
                    <li>
                        <a href="operators.html">Operators</a>
                    </li>
                    <li>
                        <a href="constexpr.html">Constant Expression</a>
                    </li>
                    <li>
                        <a href="control-flow.html">Control Flow</a>
                    </li>
                    <li>
                        <a href="variables.html">Variables</a>
                    </li>
                </ul>
            </header>
            <section>
                <h1>Name Resolution</h1>
                <p>
                    The last step of the compilation pipeline on the frontend is
                    reasoning about the meaning the source code. It might happen
                    that a piece of code is accepted by the parser, but the
                    compiler still can't figure out what it means.
                </p>
                <pre><code>fn foo(x: number): void {
  println(y);
}</code></pre>
                <p>
                    The above snippet is correct according to the grammar,
                    however it's not known what <code>y</code> refers to. Is it
                    a parameter? Is it a function, which the developer forgot to
                    call? The semantic analyzer of a compiler is searching for
                    the answer to these questions.
                </p>
                <p>
                    The process of figuring out what a name in the source code
                    refers to is called name resolution.
                </p>
                <pre><code>fn foo(x: number): void {
       ^
       &boxur;&boxdl;
        &boxv;
  print(x); // 'x' refers to the parameter 'x'
}</code></pre>
                <p>
                    The general approach is to record every name introduced by a
                    declaration while traversing the AST into a so called symbol
                    table. When a reference to a symbol is encountered, it is
                    checked if the symbol has been recorded already or not. If
                    it's not found in the symbol table it's assumed the
                    developer forgot to introduce it and an error is reported.
                </p>
                <pre><code>int x;     // symbol table: [], insert 'x'
int y;     // symbol table: ['x'], insert 'y'
x + y + z; // symbol table: ['x', 'y'], error: 'z' not found

int foo(int);    // symbol table: ['x', 'y'], insert 'foo'
foo(0) + bar(0); // symbol table: ['x', 'y', 'foo'], error: 'bar' not found</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        The difficulty of this problem can vary based on how the
                        language is designed. C and C++ require every symbol to
                        be declared before it can be referenced, so in those
                        languages the source file can be traversed from top to
                        bottom and when a symbol is not found and error can be
                        safely reported.
                    </p>
                    <p>
                        Other languages such as Kotlin or JavaScript (and your
                        language) however allow the to use a symbol before it is
                        declared. The following snippets are valid Kotlin and
                        JavaScript codes.
                    </p>
                    <pre><code>fun main() {
    foo()
}

fun foo() {}</code></pre>
                    <pre><code>foo()

function foo() {}</code></pre>
                    <p>
                        JavaScript introduces a mechanism called hoisting, when
                        <code>function</code> and <code>var</code> declarations
                        are moved to the top of the source file before the
                        source file is executed.
                    </p>
                    <p>
                        Upon learning about hoisting, a naive approach might be
                        to reorder the functions during semantic analysis, but
                        if 2 different function call each other in a cycle,
                        there is no suitable order.
                    </p>
                    <pre><code>function foo() { bar() }
function bar() { foo() }</code></pre>
                    <p>
                        To properly tackle this problem in such languages name
                        resolution must be done in multiple passes.
                    </p>
                </blockquote>
                <h2>Scopes</h2>
                <p>
                    Languages also define scopes, which limit the visibility of
                    symbols. For example in C++ or Kotlin variables defined in
                    the body of a condition are not visible outside that body.
                </p>
                <pre><code>void foo() {
    if(true)
        int x = 0;
    x; // error: 'x' was not declared in this scope
}</code></pre>
                <p>
                    In Python however the variable is visible until the end of
                    the function.
                </p>
                <pre><code>def fun():
    if True:
        x = 1
    print(x) # 'x' is visible</code></pre>

                <p>
                    Scopes are usually modelled using symbol tables linked after
                    each other.
                </p>
                <pre><code>int x = 0; // symbol tables: [], insert 'x'

void foo() {
  int x = 1; // symbol tables: ['x'] -> [], insert 'x'
  int y = 2; // symbol tables: ['x'] -> ['x'], insert 'y'

  {
    int x = 2; // symbol tables: ['x'] -> ['x', 'y'] -> [], insert 'x'
    int z = 3; // symbol tables: ['x'] -> ['x', 'y'] -> ['x'], insert 'z'

    x; // symbol tables: ['x'] -> ['x', 'y'] -> ['x' <--, 'z'], lookup from the right
  }

  x; // symbol tables: ['x'] -> ['x' <--, 'y'], lookup from the right
}</code></pre>
                <h2>Resolved Tree</h2>
                <p>
                    After resolution the AST nodes should carry the semantic
                    information. For example a
                    <code>DeclRefExpr</code> should no longer store a
                    <code>std::string</code> that represents the identifier of
                    the declaration being referenced, but a pointer to the
                    corresponding <code>Decl</code> node itself.
                </p>
                <p>
                    One approach to achieve this is to add additional fields to
                    the current AST and fill those in during semantic analysis.
                    The drawback of this approach is that nodes can be left in
                    an invalid state by forgetting to set the correct
                    information. Also the AST becomes heavy with multiple
                    properties.
                </p>
                <p>
                    Another approach is to recreate the AST with nodes that only
                    contain the information needed after resolution. This is the
                    approach being preferred in this compiler. The only field
                    kept form the original AST nodes is the type.
                </p>
                <pre><code>struct ResolvedStmt : public Dumpable {
  SourceLocation location;

  ResolvedStmt(SourceLocation location) : location(location) {}

  virtual ~ResolvedStmt() = default;
};

struct ResolvedExpr : public ResolvedStmt {
  Type type;

  ResolvedExpr(SourceLocation location, Type type)
      : ResolvedStmt(location), type(type) {}

  virtual ~ResolvedExpr() = default;
};

struct ResolvedDecl : public Dumpable {
  SourceLocation location;
  std::string identifier;
  Type type;

  ResolvedDecl(SourceLocation location, std::string identifier, Type type)
      : location(location), identifier(std::move(identifier)), type(type) {}
  virtual ~ResolvedDecl() = default;
};</code></pre>
                <p>
                    Since numbers are all double precision floating point
                    numbers, <code>ResolvedNumberLiteral</code> contains a
                    <code>double</code> to store the actual value.
                </p>
                <pre><code>struct ResolvedNumberLiteral : public ResolvedExpr {
  double value;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>
                    <code>ResolvedDeclRefExpr</code> and
                    <code>ResolvedCallExpr</code> store a pointer to
                    <code>ResolvedDecl</code> and
                    <code>ResolvedFunctionDecl</code> respectively.
                </p>
                <pre><code>struct ResolvedDeclRefExpr : public ResolvedExpr {
  const ResolvedDecl *decl;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <pre><code>struct ResolvedCallExpr : public ResolvedExpr {
  const ResolvedFunctionDecl *callee;
  std::vector&lt;std::unique_ptr&lt;ResolvedExpr>> arguments;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>
                    The rest of the resolved nodes are identical to their
                    non-resolved counterparts except for storing pointers to
                    other resolved nodes.
                </p>
                <pre><code>struct ResolvedBlock : public Dumpable {
  SourceLocation location;
  std::vector&lt;std::unique_ptr&lt;ResolvedStmt>> statements;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <pre><code>struct ResolvedParamDecl : public ResolvedDecl {
  // the constructor and dump() are omitted
  ...
};</code></pre>
                <pre><code>struct ResolvedFunctionDecl : public ResolvedDecl {
  std::vector&lt;std::unique_ptr&lt;ResolvedParamDecl>> params;
  std::unique_ptr&lt;ResolvedBlock> body;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <pre><code>struct ResolvedReturnStmt : public ResolvedStmt {
  std::unique_ptr&lt;ResolvedExpr> expr;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <h2>Sema</h2>
                <p>
                    The semantic analysis logic is encapsulated by the
                    <code>Sema</code> class. It takes the AST returned by the
                    parser and attempts to resolve it.
                </p>
                <pre><code>class Sema {
  std::vector&lt;std::unique_ptr&lt;FunctionDecl>> ast;

public:
  explicit Sema(std::vector&lt;std::unique_ptr&lt;FunctionDecl>> ast)
      : ast(std::move(ast)) {}

  std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> resolveAST();
};</code></pre>
                <p>
                    A scope is represented by a vector of
                    <code>ResolvedDecl*</code>, while the chain of scopes is
                    represented by a vector of scopes.
                </p>
                <p>
                    To make working with scopes more convenient, a helper object
                    and two helper methods are introduced. The
                    <code>ScopeRAII</code> object makes the handling of scopes
                    natural by creating a new scope in it's constructor and
                    destroying it in it's destructor.
                </p>
                <pre><code>class Sema {
  ...
  std::vector&lt;std::vector&lt;ResolvedDecl *>> scopes;

  class ScopeRAII {
    Sema *sema;

  public:
    explicit ScopeRAII(Sema *sema) : sema(sema) { sema->Scopes.emplace_back(); }
    ~ScopeRAII() { sema->Scopes.pop_back(); }
  };
  ...
};</code></pre>
                <p>
                    The <code>lookupDecl()</code> method looks up a symbol based
                    on it's id and returns the <code>ResolvedDecl</code> and the
                    index of the scope the declaration was found in. The index
                    helps to determine whether an id collision is a
                    redeclaration or a shadowing. With a more complex type
                    systems, it's also necessary to use the type of the symbol
                    for the lookup, as a user defined type might have the same
                    name as a local variable.
                </p>
                <pre><code>std::pair&lt;ResolvedDecl *, int> Sema::lookupDecl(const std::string id) {
  int scopeIdx = 0;
  for (auto it = Scopes.rbegin(); it != Scopes.rend(); ++it) {
    for (auto &&decl : *it) {
      if (decl->identifier != id)
        continue;

      return {decl, scopeIdx};
    }

    ++scopeIdx;
  }

  return {nullptr, -1};
}</code></pre>
                <p>
                    The <code>insertDeclToCurrentScope()</code> method attempts
                    to insert the declaration into the current scope and error
                    out on a redeclaration, but not on shadowing.
                </p>
                <pre><code>bool Sema::insertDeclToCurrentScope(ResolvedDecl &decl) {
  const auto &[foundDecl, scopeIdx] = lookupDecl(decl.identifier);

  if (foundDecl && scopeIdx == 0) {
    report(decl.location, "redeclaration of '" + decl.identifier + '\'');
    return false;
  }

  scopes.back().emplace_back(&decl);
  return true;
}</code></pre>
                <p>
                    The source file is resolved in two passes. Because the order
                    of the function declarations doesn't matter, first the
                    functions and their parameters are resolved without their
                    bodies. This will insert all of the valid function symbols
                    into the global symbol table.
                </p>
                <p>
                    Before the function are resolved however, the builtin
                    <code>println</code> function is created and inserted into
                    the global scope. Creating this function first allows the
                    semantic analyzer to error out if the user redeclared
                    <code>println</code>.
                </p>
                <pre><code>std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveAST() {
  ScopeRAII globalScope{this};
  std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> resolvedTree;

  auto println = createBuiltinPrintln();
  insertDeclToCurrentScope(*resolvedTree.emplace_back(std::move(println)));
  ...
}</code></pre>
                <p>
                    The <code>println</code> function is created at the
                    <code>&lt;builtin>:0:0</code> location, with one parameter,
                    <code>n</code> of number type.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedFunctionDecl> Sema::createBuiltinPrintln() {
  SourceLocation loc = SourceLocation{"&lt;builtin>", 0, 0};

  auto param =
      std::make_unique&lt;ResolvedParamDecl>(loc, "n", Type::builtinNumber());

  std::vector&lt;std::unique_ptr&lt;ResolvedParamDecl>> params;
  params.emplace_back(std::move(param));

  ...
};</code></pre>
                <p>
                    The body of the function is empty, while it's return type is
                    <code>void</code>.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedFunctionDecl> Sema::createBuiltinPrintln() {
  ...

  auto block = std::make_unique&lt;ResolvedBlock>(
      loc, std::vector&lt;std::unique_ptr&lt;ResolvedStmt>>());

  return std::make_unique&lt;ResolvedFunctionDecl>(
      loc, "println", Type::builtinVoid(), std::move(params), std::move(block));
};</code></pre>
                <p>
                    If an error happens during the resolution of one of the
                    functions, or a function with the same name is declared
                    multiple times, an empty resolved tree is returned.
                </p>
                <pre><code>std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveAST() {
  ...

  bool error = false;
  for (auto &&fn : ast) {
    auto resolvedFunctionDecl = resolveFunctionDeclaration(*fn);

    if (!resolvedFunctionDecl ||
        !insertDeclToCurrentScope(*resolvedFunctionDecl)) {
      error = true;
      continue;
    }

    resolvedTree.emplace_back(std::move(resolvedFunctionDecl));
  }

  if (error)
    return {};

  ...
}</code></pre>
                <p>
                    In the second pass, a new scope is created for each function
                    and the parameters are inserted into that scope, so they are
                    visible to any <code>DeclRefExpr</code> that references
                    them. The current function is also stored inside
                    <code>Sema</code> because return statement analysis will
                    need it later.
                </p>
                <pre><code>class Sema {
  ...
  ResolvedFunctionDecl *currentFunction;
  ...
};

std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveSourceFile() {
  ...
  for (size_t i = 1; i < resolvedTree.size(); ++i) {
    ScopeRAII scope{this};
    currentFunction = resolvedTree[i].get();

    for (auto &&param : currentFunction->params)
      insertDeclToCurrentScope(*param);

    ...
  }

  ...
}
</code></pre>
                <p>
                    Then the body is resolved. This is the only place where a
                    resolved node is modified after it's creation, as it's body
                    has to be replaced with the resolved body. If any of the
                    bodies cannot be resolved, the error is stored and an empty
                    resolved tree is returned.
                </p>
                <pre><code>std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveSourceFile() {
  ...
  for (size_t i = 1; i < resolvedTree.size(); ++i) {
    ...

    auto resolvedBody = resolveBlock(*ast[i - 1]->body);
    if (!resolvedBody) {
      error = true;
      continue;
    }

    currentFunction->body = std::move(resolvedBody);
  }

  if (error)
    return {};

  return std::move(resolvedTree);
}
</code></pre>
                <p>
                    With a simple type system like this one, resolving the types
                    is straightforward. The type is only considered resolved if
                    it is <code>void</code> or <code>number</code>.
                </p>
                <pre><code>std::optional&lt;Type> Sema::resolveType(Type parsedType) {
  if (parsedType.kind == Type::Kind::Custom)
    return std::nullopt;

  return parsedType;
}</code></pre>
                <p>
                    In case of functions, the return type is resolved first. If
                    the resolution fails, an error is reported.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedFunctionDecl>
Sema::resolveFunctionDeclaration(const FunctionDecl &function) {
  std::optional&lt;Type> type = resolveType(function.type);

  if (!type)
    return report(function.location, "function '" + function.identifier +
                                         "' has invalid '" +
                                         function.type.name + "' type");

  ...
};</code></pre>
                <p>
                    If the current function is the <code>main</code> function it
                    is ensured that it is declared as <code>void</code> with no
                    parameters.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedFunctionDecl>
Sema::resolveFunctionDeclaration(const FunctionDecl &function) {
  ...

  if (function.identifier == "main") {
    if (type->kind != Type::Kind::Void)
      return report(function.location,
                    "'main' function is expected to have 'void' type");

    if (!function.params.empty())
      return report(function.location,
                    "'main' function is expected to take no arguments");
  }

  ...
};</code></pre>
                <p>
                    Next each of the parameters are resolved. A new scope is
                    created for the parameters so that their name collision can
                    be detected easily. If a parameter cannot be resolved, or is
                    the redeclaration of a previous parameter the resolution of
                    the function fails and a <code>nullptr</code> is reported.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedFunctionDecl>
Sema::resolveFunctionDeclaration(const FunctionDecl &function) {
  ...

  ScopeRAII paramScope{this};
  std::vector&lt;std::unique_ptr&lt;ResolvedParamDecl>> resolvedParams;

  for (auto &&param : function.params) {
    auto resolvedParam = resolveParamDecl(*param);

    if (!resolvedParam || !insertDeclToCurrentScope(*resolvedParam))
      return nullptr;

    resolvedParams.emplace_back(std::move(resolvedParam));
  }

  ...
};</code></pre>
                <p>
                    If everything was successful, a
                    <code>ResolvedFunctionDecl</code> is returned without a body
                    node, which is added later.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedFunctionDecl>
Sema::resolveFunctionDeclaration(const FunctionDecl &function) {
  ...

  return std::make_unique&lt;ResolvedFunctionDecl>(
      function.location, function.identifier, *type, std::move(resolvedParams),
      nullptr);
};</code></pre>
                <p>
                    For <code>ParamDecl</code> only it's type needs to be
                    resolved and checked if it's not <code>void</code> as such
                    parameters are not allowed.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedParamDecl>
Sema::resolveParamDecl(const ParamDecl &param) {
  std::optional&lt;Type> type = resolveType(param.type);

  if (!type || type->kind == Type::Kind::Void)
    return report(param.location, "parameter '" + param.identifier +
                                      "' has invalid '" + param.type.name +
                                      "' type");

  return std::make_unique&lt;ResolvedParamDecl>(param.location, param.identifier,
                                             *type);
}</code></pre>
                <p>
                    Resolving a block is equivalent to resolving all the
                    statements inside the block. For each block a new scope is
                    created and if an error happens during the resolution of one
                    statement, the semantic analyzes keeps resolving the
                    remaining statements. This allows the compile to report
                    multiple error messages together at the cost of some
                    introduced false positives.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedBlock> Sema::resolveBlock(const Block &block) {
  std::vector&lt;std::unique_ptr&lt;ResolvedStmt>> resolvedStatements;

  bool error = false;
  ...

  ScopeRAII blockScope{this};
  for (auto &&stmt : block.statements) {
    auto resolvedStmt = resolveStmt(*stmt);

    error |= !resolvedStatements.emplace_back(std::move(resolvedStmt));
    if (error)
      continue;

    ...
  }

  if (error)
    return nullptr;

  return std::make_unique&lt;ResolvedBlock>(block.location,
                                         std::move(resolvedStatements));
}</code></pre>
                <p>
                    This function is the place where unreachable statements can
                    be detected too. After the first return statement in a
                    block, every other statement is considered unreachable, but
                    a warning should only be reported for the first such
                    statement.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedBlock> Sema::resolveBlock(const Block &block) {
  ...
  int reportUnreachableCount = 0;

  ...
  for (auto &&stmt : block.statements) {
    ...

    if (reportUnreachableCount == 1) {
      report(stmt->location, "unreachable statement", true);
      ++reportUnreachableCount;
    }

    if (dynamic_cast&lt;ReturnStmt *>(stmt.get()))
      ++reportUnreachableCount;
  }

  ...
}</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        Some languages like C or C++ allow the declaration of
                        labels to which the program can jump. If a label appears
                        after a return statement, only the statements after the
                        return and before the label are unreachable.
                    </p>
                    <pre><code>void foo() {
    return;
    int unreachable;

label:
    int mightBeReachable;
}</code></pre>
                </blockquote>
                <h2>Resolving Statements</h2>
                <p>
                    The <code>resolveStmt()</code> method drives the resolution
                    of the various statements. It checks the what the current
                    <code>Stmt</code> is, and dispatches the corresponding
                    resolver method.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedStmt> Sema::resolveStmt(const Stmt &stmt) {
  if (auto *expr = dynamic_cast&lt;const Expr *>(&stmt))
    return resolveExpr(*expr);

  if (auto *returnStmt = dynamic_cast&lt;const ReturnStmt *>(&stmt));
    return resolveReturnStmt(*returnStmt);
  
  assert(false && "unknown statement");
  return nullptr;
}</code></pre>
                <p>
                    For a <code>ReturnStmt</code> it needs to be checked whether
                    it's in the correct form. Void functions are not allowed to
                    return values, while non-void functions are expected to
                    return a value of the return type. To be able to reason
                    about the return statement properly <code>Sema</code> tracks
                    the function that's being analyzed in the
                    <code>currentFunction</code> field, set previously in
                    <code>resolveAST()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedReturnStmt>
Sema::resolveReturnStmt(const ReturnStmt &returnStmt) {
  assert(currentFunction && "return stmt outside a function");

  if (currentFunction->type.kind == Type::Kind::Void && returnStmt.expr)
    return report(returnStmt.location,
                  "unexpected return value in void function");

  if (currentFunction->type.kind != Type::Kind::Void && !returnStmt.expr)
    return report(returnStmt.location, "expected a return value");

  ...
}</code></pre>
                <p>
                    If the return statement is in the correct form, the
                    expression, whose result is returned is resolved. If the
                    expression cannot be resolved, or the type of the expression
                    doesn't match the return type of the current function, an
                    error is reported.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedReturnStmt>
Sema::resolveReturnStmt(const ReturnStmt &returnStmt) {
  ...

  std::unique_ptr&lt;ResolvedExpr> resolvedExpr;
  if (returnStmt.expr) {
    resolvedExpr = resolveExpr(*returnStmt.expr);
    if (!resolvedExpr)
      return nullptr;

    if (currentFunction->type.kind != resolvedExpr->type.kind)
      return report(resolvedExpr->location, "unexpected return type");
  }

  return std::make_unique&lt;ResolvedReturnStmt>(returnStmt.location,
                                              std::move(resolvedExpr));
}</code></pre>
                <h2>Resolving Expressions</h2>
                <p>
                    As in case of <code>Stmt</code>, a function called
                    <code>resolveExpr()</code> is called to drive the
                    resolution.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedExpr> Sema::resolveExpr(const Expr &expr) {
  ...
  assert(false && "unexpected expression");
  return nullptr;
}</code></pre>
                <p>
                    A <code>NumberLiteral</code> is resolved by it's value being
                    converted into a <code>double</code>. The grammar ensures
                    that it's always in a valid form, so the conversion should
                    succeed.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedExpr> Sema::resolveExpr(const Expr &expr) {

  if (const auto *number = dynamic_cast&lt;const NumberLiteral *>(&expr))
    return std::make_unique&lt;ResolvedNumberLiteral>(number->location,
                                                   std::stod(number->value));

  ...
}</code></pre>
                <p>
                    In case of a <code>DeclRefExpr</code>, the semantic analyzer
                    looks up the <code>Decl</code> it refers to and stores the
                    pointer to it in the node. If the referenced
                    <code>Decl</code> is not found, an error is reported.
                </p>

                <pre><code>std::unique_ptr&lt;ResolvedExpr> Sema::resolveExpr(const Expr &expr) {
  ...

  if (const auto *declRefExpr = dynamic_cast&lt;const DeclRefExpr *>(&expr))
    return resolveDeclRefExpr(*declRefExpr);

  ...
}</code></pre>
                <p>
                    The <code>resolveDeclRefExpr()</code> function also takes a
                    flag, indicating if it's the LHS of a function call. If it
                    isn't and the looked up <code>Decl</code> is a function
                    declaration, an error is reported to the user about
                    forgetting to call the function.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedDeclRefExpr>
Sema::resolveDeclRefExpr(const DeclRefExpr &declRefExpr, bool inCall = false) {
  ResolvedDecl *decl = lookupDecl(declRefExpr.identifier).first;
  if (!decl)
    return report(declRefExpr.location,
                  "symbol '" + declRefExpr.identifier + "' not found");

  if (!inCall && dynamic_cast&lt;ResolvedFunctionDecl *>(decl))
    return report(declRefExpr.location,
                  "expected to call function '" + declRefExpr.identifier + "'");

  return std::make_unique&lt;ResolvedDeclRefExpr>(declRefExpr.location, *decl);
}</code></pre>
                <p>
                    For a <code>CallExpr</code>, first the callee is looked up
                    and checked if it's indeed a function.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedCallExpr> Sema::resolveCallExpr(const CallExpr &call) {
  varOrReturn(resolvedCallee, resolveDeclRefExpr(*call.identifier, true));

  const auto *resolvedFunctionDecl =
      dynamic_cast&lt;const ResolvedFunctionDecl *>(resolvedCallee->decl);

  if (!resolvedFunctionDecl)
    return report(call.location, "calling non-function symbol");

  ...
}</code></pre>
                <p>
                    Then it's checked if the number of arguments in the call is
                    equivalent to the number of parameters the called function
                    has. If the number of the arguments match, each argument is
                    resolved and it's checked if each has the correct type.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedCallExpr> Sema::resolveCallExpr(const CallExpr &call) {
  ...

  if (call.arguments.size() != resolvedFunctionDecl->params.size())
    return report(call.location, "argument count mismatch in function call");

  std::vector&lt;std::unique_ptr&lt;ResolvedExpr>> resolvedArguments;
  int idx = 0;
  for (auto &&arg : call.arguments) {
    varOrReturn(resolvedArg, resolveExpr(*arg));

    if (resolvedArg->type.kind != resolvedFunctionDecl->params[idx]->type.kind)
      return report(resolvedArg->location, "unexpected type of argument");

    ++idx;
    resolvedArguments.emplace_back(std::move(resolvedArg));
  }

  return std::make_unique&lt;ResolvedCallExpr>(
      call.location, *resolvedFunctionDecl, std::move(resolvedArguments));
}</code></pre>
            </section>
            <footer>
                <p>
                    <small
                        >Hosted on GitHub Pages &mdash; Theme by
                        <a href="https://github.com/orderedlist" target="_blank"
                            >orderedlist</a
                        ></small
                    >
                </p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
        <script src="javascripts/toc.js"></script>
    </body>
</html>
