<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="chrome=1" />
        <title>How to Compile Your Language</title>
        <link rel="icon" href="./favicon.ico" />
        <link rel="stylesheet" href="stylesheets/styles.css" />
        <link rel="stylesheet" href="stylesheets/pygment_trac.css" />
        <meta name="viewport" content="width=device-width" />
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="wrapper">
            <header>
                <ul>
                    <li>
                        <a href="index.html">Intro </a>
                    </li>
                    <li><a href="lexing.html">Lexing</a></li>
                    <li><a href="parsing.html">Parsing</a></li>
                    <li>
                        <a href="extending-the-parser.html"
                            >Extending the Language</a
                        >
                    </li>
                    <li>
                        <a href="sema.html">Semantic Analysis</a>
                        <div id="toc"></div>
                    </li>
                    <li><a href="codegen.html">Generating LLVM IR</a></li>
                    <li><a href="driver.html">Driver</a></li>
                    <li>
                        <a href="operators.html">Operators</a>
                    </li>
                    <li>
                        <a href="constexpr.html">Constant Expressions</a>
                    </li>
                    <li>
                        <a href="control-flow.html">Control Flow</a>
                    </li>
                    <li>
                        <a href="variables.html">Variables</a>
                    </li>
                </ul>
            </header>
            <section>
                <h1>Name Resolution</h1>
                <p>
                    The last step of the compilation pipeline on the frontend is
                    reasoning about the meaning of the source code. It might
                    happen that a snippet is accepted by the parser, but it
                    still has no meaning.
                </p>
                <pre><code>fn wrong(x: number): void {
  println(y);
}</code></pre>
                <p>
                    The above snippet is correct according to the grammar,
                    however it's not known what <code>y</code> refers to. Is it
                    a parameter? Is it a function, which the developer forgot to
                    call? The semantic analyzer of a compiler is searching for
                    the answer to these questions.
                </p>
                <p>
                    The process of figuring out what a name in the source code
                    refers to is called name resolution.
                </p>
                <pre><code>fn printX(x: number): void {
          ^
          │
  println(x); // 'x' refers to the parameter 'x'
}</code></pre>
                <p>
                    The idea is to traverse the AST and record every identifier
                    introduced by a declaration into a so called symbol table.
                    The identifiers can also be called symbols, hence the symbol
                    table name.
                </p>
                <p>
                    When a reference to a symbol is encountered, it is checked
                    whether it has already been recorded. If the symbol is not
                    found in the symbol table it's assumed the developer forgot
                    to declare it and the compiler reports an error.
                </p>
                <pre><code>fn function(  // symbols: ['function']
  x: number,  // symbols: ['function', 'x']
  y: number,  // symbols: ['function', 'x', 'y']
): void {
  x + z;
      ^ error: 'z' is not a known symbol
}</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        The difficulty of this problem can vary based on how the
                        language is designed. C and C++ require every symbol to
                        be declared before it can be referenced, so in those
                        languages the source file can be traversed from top to
                        bottom and when a symbol is not found and error can be
                        safely reported.
                    </p>
                    <p>
                        Other languages such as Kotlin or JavaScript (and your
                        language) however allow the use of a symbol before it is
                        declared. The following snippet for example is a valid
                        Kotlin code.
                    </p>
                    <pre><code>fun main() {
    foo()
}

fun foo() {}</code></pre>
                    <p>Similarly, this other snippet is valid in JavaScript.</p>
                    <pre><code>foo()

function foo() {}</code></pre>
                    <p>
                        JavaScript also introduces a mechanism called hoisting,
                        when
                        <code>function</code> and <code>var</code> declarations
                        are moved to the top of the source file before the
                        source file is executed.
                    </p>
                    <p>
                        Still even moving every declaration to the top of the
                        source file doesn't work in case of 2 functions are
                        referencing each other in their bodies.
                    </p>
                    <pre><code>function foo() { bar() }
function bar() { foo() }</code></pre>
                    <p>
                        C and C++ solves this problem with the use of forward
                        declarations, as in these languages a function can be
                        declared any number of times, but it is only allowed to
                        be defined exactly once.
                    </p>
                    <pre><code>void foo();
void bar() { foo(); }
void foo() { bar(); }</code></pre>
                    <p>
                        One drawback of forward declarations is that the
                        compiler has no way to figure out whether a function is
                        defined or not. Catching that error happens after
                        compilation in the linker.
                    </p>
                    <p>
                        In languages where forward declarations are not allowed
                        to properly tackle this problem name resolution must be
                        done in multiple passes.
                    </p>
                </blockquote>
                <h2>Scopes</h2>
                <p>
                    Languages also define scopes, which limit the visibility of
                    symbols. For example in C++ or Kotlin variables defined in
                    the body of a condition are not visible outside that body.
                </p>
                <pre><code>void foo() {
    if(true)
        int x = 0;
    x; // error: 'x' was not declared in this scope
}</code></pre>
                <p>
                    In Python however the variable is visible until the end of
                    the function.
                </p>
                <pre><code>def fun():
    if True:
        x = 1
    print(x) # 'x' is visible</code></pre>

                <p>
                    In <i>your language</i> function symbols declared on the top
                    level of the source file live inside the global scope, that
                    makes them visible to every part of the source file.
                </p>
                <pre><code>┌──────────────────────────┐
│ Global Scope: ['x', 'y'] │
├──────────────────────────┴────────────┐
│ fn x(n: number): void { println(n); } │
│                                       │
│ fn y(x: number): void { println(x); } │
└───────────────────────────────────────┘</code></pre>
                <p>
                    Parameters on the other hand are only visible inside the
                    parameter list they are declared in and the body of the
                    corresponding function. The parameter of a specific function
                    is not visible in any other functions.
                </p>
                <pre><code>┌──────────────────────────┐
│ Global Scope: ['x', 'y'] │
├──────────────────────────┴─────────────────┐
│      ┌────────────────────┐                │
│      │ Param Scope: ['n'] │                │
│      ├────────────────────┴──────────────┐ │
│ fn x │ (n: number): void { println(n); } │ │
│      └───────────────────────────────────┘ │
│                                            │
│      ┌────────────────────┐                │
│      │ Param Scope: ['x'] │                │
│      ├────────────────────┴──────────────┐ │
│ fn y │ (x: number): void { println(x); } │ │
│      └───────────────────────────────────┘ │
└────────────────────────────────────────────┘</code></pre>
                <p>
                    Blocks also get their own scope, so that everything that's
                    declared inside a block is not visible outside of it.
                </p>
                <pre><code>┌──────────────────────────┐
│ Global Scope: ['x', 'y'] │
├──────────────────────────┴─────────────────────┐
│      ┌────────────────────┐                    │
│      │ Param Scope: ['n'] │                    │
│      ├────────────────────┴──────────────────┐ │
│      │                   ┌─────────────────┐ │ │
│      │                   │ Block scope: [] │ │ │
│      │                   ├─────────────────┤ │ │
│ fn x │ (n: number): void │ { println(n); } │ │ │
│      │                   └─────────────────┘ │ │
│      └───────────────────────────────────────┘ │
│                                                │
│      ┌────────────────────┐                    │
│      │ Param Scope: ['x'] │                    │
│      ├────────────────────┴──────────────────┐ │
│      │                   ┌─────────────────┐ │ │
│      │                   │ Block Scope: [] │ │ │
│      │                   ├─────────────────┤ │ │
│ fn y │ (x: number): void │ { println(x); } │ │ │
│      │                   └─────────────────┘ │ │
│      └───────────────────────────────────────┘ │
└────────────────────────────────────────────────┘</code></pre>
                <p>
                    Because scopes are nested inside each other and each scope
                    needs to be aware of the declarations it contains, they are
                    usually modelled as symbol tables linked after each other.
                </p>
                <pre><code>['x', 'y'] &lt;- ['n'] &lt;- []
           ^ 
           └─ ['x'] &lt;- []</code></pre>
                <p>
                    During lookup the scopes are scanned from the inner-most one
                    to the outer-most one, so it's always the declaration in the
                    deepest scope found first.
                </p>
                <pre><code>Lookup 'x' in the body of 'fn x()':
['x', 'y'] &lt;- ['n'] &lt;- [] <-- lookup from right to left
  ^

Lookup 'x' in the body of 'fn y()':
['x', 'y'] &lt;- ['x'] &lt;- [] <-- lookup from right to left
                ^</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        The previously described scope is also called lexical
                        scope as the visibility of the variables depend on the
                        place where they are created in source code.
                    </p>
                    <p>
                        For this reason in case of functions, symbol tables can
                        be created and destroyed as the semantic analyzer
                        traverses them from top to bottom, however other
                        elements such as classes require their symbol tables to
                        be bound to the class itself. The reason for this is
                        inheritance.
                    </p>
                    <pre><code>struct Base {
  int x;
  void foo();
};

struct Derived : public Base {};</code></pre>
                    <p>
                        Because <code>Derived</code> inherits from
                        <code>Base</code>, it must have access to the symbols of
                        <code>Base</code>. If the symbol table of
                        <code>Base</code> is destroyed when the semantic
                        analyzer finishes processing the class, the information
                        is lost.
                    </p>
                </blockquote>
                <p>
                    If a symbol at the point of a declaration is already
                    inserted into the same scope, it's called a redeclaration.
                    Inside the compiler it is an error, as there is no way to
                    know which of the symbols a reference points to.
                </p>
                <pre><code>// symbol tables: ['function'] &lt;- ['x', 'x'] &lt;- []

fn function(x: number, x: number): void {
            ^          ^
          ┌─┴──────────┘ // which 'x' is being printed?
  println(x);
}</code></pre>
                <p>
                    When the same symbol is already found in a higher symbol
                    table it's called shadowing, as the deeper symbol is found
                    first by the compiler and it hides the higher symbol.
                </p>
                <pre><code>// symbol tables: ['x', 'y'] &lt;- ['x'] &lt;- []

fn x(): void {}
   ^
   └─┐ // the parameter shadows the function
fn y(x: number): void {
     ^
  ┌──┘ // the closest 'x' symbol is the parameter
  x;
}</code></pre>
                <h2>Resolved Tree</h2>
                <p>
                    After resolution the compiler should have an intermediate
                    representation that contains information about the meaning
                    of the source code. For example a
                    <code>DeclRefExpr</code> should no longer store a
                    <code>std::string</code> that represents the identifier of
                    the declaration being referenced, but a pointer to the
                    corresponding <code>Decl</code> node itself.
                </p>
                <p>
                    One approach to achieve this is to add additional fields to
                    the current AST and fill those in during semantic analysis.
                    The drawback is that nodes can be left in an invalid state
                    by forgetting to set the correct information. Also the AST
                    becomes too heavy with multiple properties that are no
                    longer needed after resolution.
                </p>
                <p>
                    Another approach is to build a dedicated representation that
                    only contains the information needed after resolution. This
                    is the approach being preferred in this compiler. The
                    representation created is also a tree structure similarly to
                    the AST, in fact it could also be called resolved AST or
                    simply resolved tree.
                </p>
                <p>
                    The <code>ResolvedStmt</code> node is identical to the AST
                    <code>Stmt</code> as it also acts as the base class for
                    every resolved statement and stores the location of the node
                    and a <code>dump()</code> method.
                </p>
                <pre><code>struct ResolvedStmt {
  SourceLocation location;

  ResolvedStmt(SourceLocation location)
      : location(location) {}

  virtual ~ResolvedStmt() = default;

  virtual void dump(size_t level = 0) const = 0;
};</code></pre>
                <p>
                    The <code>ResolvedExpr</code> node is different as every
                    resolved expression must also have it's type set.
                </p>
                <pre><code>struct ResolvedExpr : public ResolvedStmt {
  Type type;

  ResolvedExpr(SourceLocation location, Type type)
      : ResolvedStmt(location),
        type(type) {}
};</code></pre>
                <p>
                    Similarly to resolved expressions, resolved declarations
                    must also have their types set compared to their
                    non-resolved counterparts.
                </p>
                <pre><code>struct ResolvedDecl {
  SourceLocation location;
  std::string identifier;
  Type type;

  ResolvedDecl(SourceLocation location, std::string identifier, Type type)
      : location(location),
        identifier(std::move(identifier)),
        type(type) {}
  virtual ~ResolvedDecl() = default;

  virtual void dump(size_t level = 0) const = 0;
};</code></pre>
                <p>
                    Since numbers are all double precision floating point
                    numbers, <code>ResolvedNumberLiteral</code> stores a
                    <code>double</code> instead of the textual representation of
                    it's value.
                </p>
                <pre><code>struct ResolvedNumberLiteral : public ResolvedExpr {
  double value;

  ResolvedNumberLiteral(SourceLocation location, double value)
      : ResolvedExpr(location, Type::builtinNumber()),
        value(value) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>It's textual representation also prints this value.</p>
                <pre><code>void ResolvedNumberLiteral::dump(size_t level) const {
  std::cerr << indent(level) << "ResolvedNumberLiteral: '" << value << "'\n";
}</code></pre>
                <p>
                    <code>ResolvedDeclRefExpr</code> stores a pointer to the
                    referenced <code>ResolvedDecl</code> instead of it's
                    identifier.
                </p>
                <pre><code>struct ResolvedDeclRefExpr : public ResolvedExpr {
  const ResolvedDecl *decl;

  ResolvedDeclRefExpr(SourceLocation location, ResolvedDecl &decl)
      : ResolvedExpr(location, decl.type),
        decl(&decl) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    The textual representation of the node also contains the
                    address of the referenced declaration besides it's
                    identifier.
                </p>
                <pre><code>void ResolvedDeclRefExpr::dump(size_t level) const {
  std::cerr << indent(level) << "ResolvedDeclRefExpr: @(" << decl << ") "
            << decl->identifier << '\n';
}</code></pre>
                <p>
                    The callee of a <code>ResolvedCallExpr</code> is now a
                    pointer to a <code>ResolvedFunctionDecl</code> instead of an
                    arbitrary expression.
                </p>
                <pre><code>struct ResolvedCallExpr : public ResolvedExpr {
  const ResolvedFunctionDecl *callee;
  std::vector&lt;std::unique_ptr&lt;ResolvedExpr>> arguments;

  ResolvedCallExpr(SourceLocation location,
                   const ResolvedFunctionDecl &callee,
                   std::vector&lt;std::unique_ptr&lt;ResolvedExpr>> arguments)
      : ResolvedExpr(location, callee.type),
        callee(&callee),
        arguments(std::move(arguments)) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    In the textual representation of the node the address of the
                    function is printed too.
                </p>
                <pre><code>void ResolvedCallExpr::dump(size_t level) const {
  std::cerr << indent(level) << "ResolvedCallExpr: @(" << callee << ") "
            << callee->identifier << '\n';

  for (auto &amp;&amp;arg : arguments)
    arg->dump(level + 1);
}</code></pre>
                <p>
                    The <code>ResolvedBlock</code> node doesn't contain any
                    different information from it's non-resolved counterpart.
                </p>
                <pre><code>struct ResolvedBlock {
  SourceLocation location;
  std::vector&lt;std::unique_ptr&lt;ResolvedStmt>> statements;

  ResolvedBlock(SourceLocation location,
                std::vector&lt;std::unique_ptr&lt;ResolvedStmt>> statements)
      : location(location),
        statements(std::move(statements)) {}

  void dump(size_t level = 0) const;
};</code></pre>
                <p>
                    It's textual representation is also identical to the AST
                    <code>Block</code> node.
                </p>
                <pre><code>void ResolvedBlock::dump(size_t level) const {
  std::cerr << indent(level) << "ResolvedBlock\n";

  for (auto &amp;&amp;stmt : statements)
    stmt->dump(level + 1);
}</code></pre>
                <p>
                    With moving more information to it's base class,
                    <code>ResolvedParamDecl</code> no longer contains any unique
                    fields.
                </p>
                <pre><code>struct ResolvedParamDecl : public ResolvedDecl {
  ResolvedParamDecl(SourceLocation location, std::string identifier, Type type)
      : ResolvedDecl{location, std::move(identifier), type} {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    The textual representation of the node also contains it's
                    address.
                </p>
                <pre><code>void ResolvedParamDecl::dump(size_t level) const {
  std::cerr << indent(level) << "ResolvedParamDecl: @(" << this << ") "
            << identifier << ':' << '\n';
}</code></pre>
                <p>
                    <code>ResolvedFunctionDecl</code> only stores a parameter
                    list and the body of the function. The rest of the fields
                    are stored in the <code>ResolvedDecl</code> base class.
                </p>
                <pre><code>struct ResolvedFunctionDecl : public ResolvedDecl {
  std::vector&lt;std::unique_ptr&lt;ResolvedParamDecl>> params;
  std::unique_ptr&lt;ResolvedBlock> body;

  ResolvedFunctionDecl(SourceLocation location,
                       std::string identifier,
                       Type type,
                       std::vector&lt;std::unique_ptr&lt;ResolvedParamDecl>> params,
                       std::unique_ptr&lt;ResolvedBlock> body)
      : ResolvedDecl(location, std::move(identifier), type),
        params(std::move(params)),
        body(std::move(body)) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    The textual representation of the node contains it's name,
                    address, identifier, parameters and body.
                </p>
                <pre><code>void ResolvedFunctionDecl::dump(size_t level) const {
  std::cerr << indent(level) << "ResolvedFunctionDecl: @(" << this << ") "
            << identifier << ':' << '\n';

  for (auto &amp;&amp;param : params)
    param->dump(level + 1);

  body->dump(level + 1);
}</code></pre>
                <p>
                    Identical to it's non-resolved counterpart
                    <code>ResolvedReturnStmt</code> stores only the optional
                    expression whose value is returned.
                </p>
                <pre><code>struct ResolvedReturnStmt : public ResolvedStmt {
  std::unique_ptr&lt;ResolvedExpr> expr;

  ResolvedReturnStmt(SourceLocation location,
                     std::unique_ptr&lt;ResolvedExpr> expr = nullptr)
      : ResolvedStmt(location),
        expr(std::move(expr)) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    It's textual representation is also almost identical to it's
                    non-resolved counterpart.
                </p>
                <pre><code>void ResolvedReturnStmt::dump(size_t level) const {
  std::cerr << indent(level) << "ResolvedReturnStmt\n";

  if (expr)
    expr->dump(level + 1);
}</code></pre>
                <h2>Sema</h2>
                <p>
                    The semantic analysis logic is encapsulated by the
                    <code>Sema</code> class. It takes the AST returned by the
                    parser and attempts to resolve it.
                </p>
                <pre><code>class Sema {
  std::vector&lt;std::unique_ptr&lt;FunctionDecl>> ast;

public:
  explicit Sema(std::vector&lt;std::unique_ptr&lt;FunctionDecl>> ast)
      : ast(std::move(ast)) {}

  std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> resolveAST();
};</code></pre>
                <p>
                    A scope is represented by a vector of
                    <code>ResolvedDecl*</code>, while the chain of scopes is
                    represented by a vector of scopes.
                </p>
                <pre><code>class Sema {
  ...
  std::vector&lt;std::vector&lt;ResolvedDecl *>> scopes;
  ...
};</code></pre>
                <p>
                    To make working with scopes more convenient, a helper object
                    is introduced. The
                    <code>ScopeRAII</code> makes managing the scopes natural by
                    creating a new scope in it's constructor and destroying it
                    in it's destructor.
                </p>
                <pre><code>class Sema {
  ...
  class ScopeRAII {
    Sema *sema;

  public:
    explicit ScopeRAII(Sema *sema)
        : sema(sema) {
      sema->scopes.emplace_back();
    }
    ~ScopeRAII() { sema->scopes.pop_back(); }
  };
  ...
};</code></pre>
                <p>
                    The <code>lookupDecl()</code> method looks up a symbol based
                    on it's identifier and returns the
                    <code>ResolvedDecl</code> and the index of the scope the
                    declaration was found in. The index helps to determine
                    whether an identifier collision is a redeclaration or a
                    shadowing.
                </p>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        With a more complex type systems, it's also necessary to
                        use the type of the symbol as well during the lookup, as
                        a user defined type might have the same name as a local
                        variable.
                    </p>
                    <pre><code>class C {};
int C;</code></pre>
                </blockquote>
                <p>
                    To lookup a symbol, first the symbol tables are iterated in
                    a reverse order while keeping track of the scope index, so
                    the inner-most table is checked first.
                </p>
                <pre><code>std::pair&lt;ResolvedDecl *, int> Sema::lookupDecl(const std::string id) {
  int scopeIdx = 0;
  for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
    ...

    ++scopeIdx;
  }

  ...
}</code></pre>
                <p>
                    For every scope the declarations inside that scope are
                    iterated and if the identifier of any declaration matches
                    the searched identifier, the declaration and the index of
                    the scope is returned.
                </p>
                <pre><code>std::pair&lt;ResolvedDecl *, int> Sema::lookupDecl(const std::string id) {
  ...
  for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
    for (auto &amp;&amp;decl : *it) {
      if (decl->identifier != id)
        continue;

      return {decl, scopeIdx};
    }

    ...
  }

  ...
}</code></pre>
                <p>
                    If none of the scopes contain the declaration a
                    <code>nullptr</code> is returned along with
                    <code>-1</code> as the index of the containing scope.
                </p>
                <pre><code>std::pair&lt;ResolvedDecl *, int> Sema::lookupDecl(const std::string id) {
  ...

  return {nullptr, -1};
}</code></pre>
                <p>
                    The <code>insertDeclToCurrentScope()</code> method attempts
                    to insert the declaration into the inner most scope. To
                    handle redeclarations, it first checks if a declaration with
                    the same identifier is already inserted into the current
                    scope chain.
                </p>
                <pre><code>bool Sema::insertDeclToCurrentScope(ResolvedDecl &decl) {
  const auto &[foundDecl, scopeIdx] = lookupDecl(decl.identifier);

  ...
}</code></pre>
                <p>
                    If the declaration is found in the inner-most scope and
                    error is reported for redeclaring the same symbol. The
                    method also returns <code>false</code> in this case to
                    indicate the failure.
                </p>
                <pre><code>bool Sema::insertDeclToCurrentScope(ResolvedDecl &decl) {
  ...

  if (foundDecl && scopeIdx == 0) {
    report(decl.location, "redeclaration of '" + decl.identifier + '\'');
    return false;
  }

  ...
}</code></pre>
                <p>
                    If the declaration is not found or it shadows another
                    declaration in an outer scope, it is inserted into to the
                    inner-most one and <code>true</code> is returned to indicate
                    success.
                </p>
                <pre><code>bool Sema::insertDeclToCurrentScope(ResolvedDecl &decl) {
  ...

  scopes.back().emplace_back(&decl);
  return true;
}</code></pre>
                <p>
                    The source file is resolved in two passes. Because the order
                    of the function declarations doesn't matter, first they are
                    resolved without their bodies. This way all of the valid
                    function symbols are inserted into the global scope.
                </p>
                <p>
                    Before the functions are resolved however, the builtin
                    <code>println()</code> function needs to be created and
                    inserted into the global scope. Creating this function first
                    allows the semantic analyzer to easily report an error if
                    the <code>println()</code> is redeclared in the source code.
                </p>
                <p>
                    The <code>resolveAST()</code> method creates the global
                    scope, the root of the resolved tree and inserts
                    <code>println()</code>
                    into both of them.
                </p>
                <pre><code>std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveAST() {
  std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> resolvedTree;
  auto println = createBuiltinPrintln();
                  
  ScopeRAII globalScope(this);
  insertDeclToCurrentScope(*resolvedTree.emplace_back(std::move(println)));
  ...
}</code></pre>
                <p>
                    The <code>println()</code> function is created at the
                    <code>&lt;builtin>:0:0</code> location, with one parameter,
                    <code>n: number</code>.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedFunctionDecl> Sema::createBuiltinPrintln() {
  SourceLocation loc{"&lt;builtin>", 0, 0};

  auto param =
      std::make_unique&lt;ResolvedParamDecl>(loc, "n", Type::builtinNumber());

  std::vector&lt;std::unique_ptr&lt;ResolvedParamDecl>> params;
  params.emplace_back(std::move(param));

  ...
};</code></pre>
                <p>
                    The return type of the function is <code>void</code> and
                    it's body is empty. This function node in the resolved tree
                    only acts as a placeholder.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedFunctionDecl> Sema::createBuiltinPrintln() {
  ...

  auto block = std::make_unique&lt;ResolvedBlock>(
      loc, std::vector&lt;std::unique_ptr&lt;ResolvedStmt>>());

  return std::make_unique&lt;ResolvedFunctionDecl>(
      loc, "println", Type::builtinVoid(), std::move(params), std::move(block));
};</code></pre>
                <p>
                    After the builtin <code>println()</code> function is
                    inserted into the resolved tree, the functions in the AST
                    are resolved one by one.
                </p>
                <pre><code>std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveAST() {
  ...

  for (auto &amp;&amp;fn : ast) {
    auto resolvedFunctionDecl = resolveFunctionDeclaration(*fn);
    ...
  }

  ...
}</code></pre>
                <p>
                    If an error happens during the resolution of one of the
                    functions, or a function with the same name is declared
                    multiple times, the error is recorded but the semantic
                    analyzer keeps checking the other functions. This way
                    independent errors are stacked together.
                </p>
                <pre><code>std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveAST() {
  ...

  bool error = false;
  for (auto &amp;&amp;fn : ast) {
    ...

    if (!resolvedFunctionDecl ||
        !insertDeclToCurrentScope(*resolvedFunctionDecl)) {
      error = true;
      continue;
    }

    ...
  }

  ...
}</code></pre>
                <p>
                    If a function is successfully resolved, it is inserted into
                    the resolved tree.
                </p>
                <pre><code>std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveAST() {
  ...

  for (auto &amp;&amp;fn : ast) {
    ...

    resolvedTree.emplace_back(std::move(resolvedFunctionDecl));
  }

  ...
}</code></pre>
                <p>
                    If any error happened during this pass, an empty resolved
                    tree is returned.
                </p>
                <pre><code>std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveAST() {
  ...

  if (error)
    return {};

  ...
}</code></pre>
                <p>
                    In the second pass the body of every function in the
                    resolved tree is resolved. The first function in the tree is
                    the builtin
                    <code>println()</code>, which can be skipped.
                </p>
                <pre><code>std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveSourceFile() {
  ...
  for (size_t i = 1; i < resolvedTree.size(); ++i) {
    ...
  }

  ...
}</code></pre>
                <p>
                    The current function is also recorded inside the
                    <code>Sema</code> class because to reason about some
                    statements the analyzer needs to know which function the
                    particular statement is in.
                </p>
                <pre><code>class Sema {
  ...
  ResolvedFunctionDecl *currentFunction;
  ...
};</code></pre>
                <p>
                    Next the current function is set and a new scope is created
                    for it's parameters, so they are visible to any
                    <code>DeclRefExpr</code> that references them in the body.
                </p>
                <pre><code>std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveSourceFile() {
  ...
  for (size_t i = 1; i < resolvedTree.size(); ++i) {
    currentFunction = resolvedTree[i].get();
    
    ScopeRAII paramScope(this);
    for (auto &amp;&amp;param : currentFunction->params)
      insertDeclToCurrentScope(*param);

    ...
  }

  ...
}
</code></pre>
                <p>
                    Then the body is resolved. This is the only place where a
                    resolved node is modified after it's creation, as it's body
                    has to be replaced with the resolved body. If any of the
                    bodies cannot be resolved, the error is recorded.
                </p>
                <pre><code>std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveSourceFile() {
  ...
  for (size_t i = 1; i < resolvedTree.size(); ++i) {
    ...

    auto resolvedBody = resolveBlock(*ast[i - 1]->body);
    if (!resolvedBody) {
      error = true;
      continue;
    }

    currentFunction->body = std::move(resolvedBody);
  }

  ...
}
</code></pre>
                <p>
                    If an error happened during the resolution of any of the
                    blocks an empty resolved tree is returned, otherwise the
                    valid resolved tree is returned.
                </p>
                <pre><code>std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveSourceFile() {
  ...

  if (error)
    return {};

  return resolvedTree;
}
</code></pre>
                <p>
                    With a simple type system like this one, a type is
                    automatically considered resolved if it is
                    <code>void</code> or <code>number</code>.
                </p>
                <pre><code>std::optional&lt;Type> Sema::resolveType(Type parsedType) {
  if (parsedType.kind == Type::Kind::Custom)
    return std::nullopt;

  return parsedType;
}</code></pre>
                <p>
                    In case of functions, the return type is resolved first. If
                    the resolution fails, an error is reported.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedFunctionDecl>
Sema::resolveFunctionDeclaration(const FunctionDecl &function) {
  std::optional&lt;Type> type = resolveType(function.type);

  if (!type)
    return report(function.location, "function '" + function.identifier +
                                         "' has invalid '" +
                                         function.type.name + "' type");

  ...
};</code></pre>
                <p>
                    If the current function is the <code>main()</code> function
                    it is ensured that it is declared as <code>void</code> with
                    no parameters.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedFunctionDecl>
Sema::resolveFunctionDeclaration(const FunctionDecl &function) {
  ...

  if (function.identifier == "main") {
    if (type->kind != Type::Kind::Void)
      return report(function.location,
                    "'main' function is expected to have 'void' type");

    if (!function.params.empty())
      return report(function.location,
                    "'main' function is expected to take no arguments");
  }

  ...
};</code></pre>
                <p>
                    Next each of the parameters are resolved. A new scope is
                    created for the parameters so that their redeclarations can
                    be detected easily. If a parameter cannot be resolved, or is
                    the redeclaration of a previous parameter the resolution of
                    the function fails and a <code>nullptr</code> is returned.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedFunctionDecl>
Sema::resolveFunctionDeclaration(const FunctionDecl &function) {
  ...

  std::vector&lt;std::unique_ptr&lt;ResolvedParamDecl>> resolvedParams;
  
  ScopeRAII paramScope(this);
  for (auto &amp;&amp;param : function.params) {
    auto resolvedParam = resolveParamDecl(*param);

    if (!resolvedParam || !insertDeclToCurrentScope(*resolvedParam))
      return nullptr;

    resolvedParams.emplace_back(std::move(resolvedParam));
  }

  ...
};</code></pre>
                <p>
                    If everything was successful, a
                    <code>ResolvedFunctionDecl</code> is returned without a body
                    node, which is added later.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedFunctionDecl>
Sema::resolveFunctionDeclaration(const FunctionDecl &function) {
  ...

  return std::make_unique&lt;ResolvedFunctionDecl>(
      function.location, function.identifier, *type, std::move(resolvedParams),
      nullptr);
};</code></pre>
                <p>
                    For a <code>ParamDecl</code> only it's type needs to be
                    resolved. If the resolution fails or the type is
                    <code>void</code> an error is reported.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedParamDecl>
Sema::resolveParamDecl(const ParamDecl &amp;param) {
  std::optional&lt;Type> type = resolveType(param.type);

  if (!type || type->kind == Type::Kind::Void)
    return report(param.location, "parameter '" + param.identifier +
                                      "' has invalid '" + param.type.name +
                                      "' type");

  return std::make_unique&lt;ResolvedParamDecl>(param.location, param.identifier,
                                             *type);
}</code></pre>
                <p>
                    Resolving a block is equivalent to resolving all the
                    statements inside that block. For each block a new scope is
                    created and if an error happens during the resolution of one
                    statement, the semantic analyzes keeps resolving the
                    remaining statements. This allows the compiler to report
                    multiple error messages together at the cost of some
                    introduced false positives.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedBlock> Sema::resolveBlock(const Block &block) {
  std::vector&lt;std::unique_ptr&lt;ResolvedStmt>> resolvedStatements;

  bool error = false;
  ...

  ScopeRAII blockScope(this);
  for (auto &amp;&amp;stmt : block.statements) {
    auto resolvedStmt = resolveStmt(*stmt);

    error |= !resolvedStatements.emplace_back(std::move(resolvedStmt));
    if (error)
      continue;

    ...
  }

  if (error)
    return nullptr;

  return std::make_unique&lt;ResolvedBlock>(block.location,
                                         std::move(resolvedStatements));
}</code></pre>
                <p>
                    This function is the place where unreachable statements can
                    be detected too. After the first return statement in a
                    block, every other statement is considered unreachable, but
                    a warning should only be reported for the first such
                    statement.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedBlock> Sema::resolveBlock(const Block &block) {
  ...
  int reportUnreachableCount = 0;

  ...
  for (auto &amp;&amp;stmt : block.statements) {
    ...

    if (reportUnreachableCount == 1) {
      report(stmt->location, "unreachable statement", true);
      ++reportUnreachableCount;
    }

    if (dynamic_cast&lt;ReturnStmt *>(stmt.get()))
      ++reportUnreachableCount;
  }

  ...
}</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        Some languages like C or C++ allow the declaration of
                        labels to which the program can jump. If a label appears
                        after a return statement, only the statements after the
                        return and before the label are unreachable.
                    </p>
                    <pre><code>void foo() {
    return;
    int unreachable;

label:
    int mightBeReachable;
}</code></pre>
                </blockquote>
                <h2>Resolving Statements</h2>
                <p>
                    The <code>resolveStmt()</code> method drives the resolution
                    of the various statements. It checks what the current
                    <code>Stmt</code> is, and dispatches the corresponding
                    resolver method. Because this method is responsible for
                    handling every statement, it's end should be unreachable,
                    which is marked with the
                    <code>llvm_unreachable()</code> utility.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedStmt> Sema::resolveStmt(const Stmt &stmt) {
  if (auto *expr = dynamic_cast&lt;const Expr *>(&stmt))
    return resolveExpr(*expr);

  if (auto *returnStmt = dynamic_cast&lt;const ReturnStmt *>(&stmt));
    return resolveReturnStmt(*returnStmt);
  
  llvm_unreachable("unexpected statement");
}</code></pre>
                <p>
                    For a <code>ReturnStmt</code> it needs to be checked whether
                    it's in the correct form. Void functions are not allowed to
                    return values, while non-void functions are expected to
                    return a value of the return type of the function.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedReturnStmt>
Sema::resolveReturnStmt(const ReturnStmt &returnStmt) {
  if (currentFunction->type.kind == Type::Kind::Void && returnStmt.expr)
    return report(returnStmt.location,
                  "unexpected return value in void function");

  if (currentFunction->type.kind != Type::Kind::Void && !returnStmt.expr)
    return report(returnStmt.location, "expected a return value");

  ...
}</code></pre>
                <p>
                    If the return statement is in the correct form, the
                    expression, whose result is returned is resolved. If the
                    expression cannot be resolved, or the type of the expression
                    doesn't match the return type of the current function, an
                    error is reported.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedReturnStmt>
Sema::resolveReturnStmt(const ReturnStmt &returnStmt) {
  ...

  std::unique_ptr&lt;ResolvedExpr> resolvedExpr;
  if (returnStmt.expr) {
    resolvedExpr = resolveExpr(*returnStmt.expr);
    if (!resolvedExpr)
      return nullptr;

    if (currentFunction->type.kind != resolvedExpr->type.kind)
      return report(resolvedExpr->location, "unexpected return type");
  }

  return std::make_unique&lt;ResolvedReturnStmt>(returnStmt.location,
                                              std::move(resolvedExpr));
}</code></pre>
                <h2>Resolving Expressions</h2>
                <p>
                    For expression resolution <code>resolveExpr()</code> acts as
                    the driver. It checks what the current expression is and
                    decides how the semantic analyzer should proceed. As it is
                    responsible for handling every expression, the end of the
                    function is unreachable similarly to
                    <code>resolveStmt()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedExpr> Sema::resolveExpr(const Expr &expr) {
  ...

  llvm_unreachable("unexpected expression");
}</code></pre>
                <p>
                    A <code>NumberLiteral</code> is resolved by it's value being
                    converted into a <code>double</code>. The grammar ensures
                    that it's value is always a correct double literal, so the
                    conversion always succeeds.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedExpr> Sema::resolveExpr(const Expr &expr) {
  if (const auto *number = dynamic_cast&lt;const NumberLiteral *>(&expr))
    return std::make_unique&lt;ResolvedNumberLiteral>(number->location,
                                                   std::stod(number->value));

  ...
}</code></pre>
                <p>
                    Resolving a <code>DeclRefExpr</code> is a more complex
                    process, so it gets a dedicated method that handles it.
                </p>

                <pre><code>std::unique_ptr&lt;ResolvedExpr> Sema::resolveExpr(const Expr &expr) {
  ...

  if (const auto *declRefExpr = dynamic_cast&lt;const DeclRefExpr *>(&expr))
    return resolveDeclRefExpr(*declRefExpr);

  ...
}</code></pre>
                <p>
                    First <code>resolveDeclRefExpr()</code> looks up the
                    referenced symbol. If the symbol is not found, it wasn't
                    declared in the source code, so an error is reported.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedDeclRefExpr>
Sema::resolveDeclRefExpr(const DeclRefExpr &declRefExpr, ...) {
  ResolvedDecl *decl = lookupDecl(declRefExpr.identifier).first;
  if (!decl)
    return report(declRefExpr.location,
                  "symbol '" + declRefExpr.identifier + "' not found");

  ...
}</code></pre>
                <p>
                    The method also takes a flag with a default value set to
                    <code>false</code> indicating if it's the callee of a
                    function call.
                </p>
                <pre><code>class Sema {
  ...
  std::unique_ptr&lt;ResolvedDeclRefExpr>
  resolveDeclRefExpr(const DeclRefExpr &declRefExpr, bool isCallee = false);
  ...
};</code></pre>
                <p>
                    This flag allows the semantic analyzer to catch the case
                    when a function declaration is referenced outside a call
                    expression. In that case the programmer must have forgotten
                    to call it and this error can be reported.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedDeclRefExpr>
Sema::resolveDeclRefExpr(const DeclRefExpr &declRefExpr, bool isCallee) {
  ...

  if (!isCallee && dynamic_cast&lt;ResolvedFunctionDecl *>(decl))
    return report(declRefExpr.location,
                  "expected to call function '" + declRefExpr.identifier + "'");

  ...
}</code></pre>
                <p>
                    If no problem is found, the
                    <code>ResolvedDeclRefExpr</code> is returned storing a
                    pointer to the resolved declaration.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedDeclRefExpr>
Sema::resolveDeclRefExpr(const DeclRefExpr &declRefExpr, bool isCallee) {
  ...

  return std::make_unique&lt;ResolvedDeclRefExpr>(declRefExpr.location, *decl);
}</code></pre>
                <p>
                    For a <code>CallExpr</code> first it is checked that the
                    callee is indeed a reference to a declaration and it's not
                    an arbitrary expression being called.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedCallExpr> Sema::resolveCallExpr(const CallExpr &call) {
  const auto *dre = dynamic_cast&lt;const DeclRefExpr *>(call.callee.get());
  if (!dre)
    return report(call.location, "expression cannot be called as a function");

  ...
}</code></pre>
                <p>
                    If the callee is a reference to a declaration, it is
                    resolved first, so that a possible calling of an unknown
                    symbol is caught and then it is checked if this resolved
                    reference is for a function declaration.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedCallExpr> Sema::resolveCallExpr(const CallExpr &call) {
  ...

  varOrReturn(resolvedCallee, resolveDeclRefExpr(*call.identifier, true));

  const auto *resolvedFunctionDecl =
      dynamic_cast&lt;const ResolvedFunctionDecl *>(resolvedCallee->decl);

  if (!resolvedFunctionDecl)
    return report(call.location, "calling non-function symbol");

  ...
}</code></pre>
                <p>
                    Then it's checked if the number of arguments in the call is
                    equivalent to the number of parameters the called function
                    has. If the argument count doesn't match, the semantic
                    analyzer errors out.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedCallExpr> Sema::resolveCallExpr(const CallExpr &call) {
  ...

  if (call.arguments.size() != resolvedFunctionDecl->params.size())
    return report(call.location, "argument count mismatch in function call");

  ...
}</code></pre>
                <p>
                    When the argument count matches, each of the arguments is
                    resolved and it's type is compared against the type of the
                    corresponding parameter in the called function. If one of
                    the arguments has a mismatching type, an error is reported.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedCallExpr> Sema::resolveCallExpr(const CallExpr &call) {
  ...

  std::vector&lt;std::unique_ptr&lt;ResolvedExpr>> resolvedArguments;
  int idx = 0;
  for (auto &amp;&amp;arg : call.arguments) {
    varOrReturn(resolvedArg, resolveExpr(*arg));

    if (resolvedArg->type.kind != resolvedFunctionDecl->params[idx]->type.kind)
      return report(resolvedArg->location, "unexpected type of argument");

    ++idx;
    resolvedArguments.emplace_back(std::move(resolvedArg));
  }

  ...
}</code></pre>
                <p>
                    If both the callee and the arguments are resolved
                    successfully, a <code>ResolvedCallExpr</code> is returned.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedCallExpr> Sema::resolveCallExpr(const CallExpr &call) {
  ...

  return std::make_unique&lt;ResolvedCallExpr>(
      call.location, *resolvedFunctionDecl, std::move(resolvedArguments));
}</code></pre>
            </section>
            <footer>
                <p>
                    <small
                        >Hosted on GitHub Pages &mdash; Theme by
                        <a href="https://github.com/orderedlist" target="_blank"
                            >orderedlist</a
                        ></small
                    >
                </p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
        <script src="javascripts/toc.js"></script>
    </body>
</html>
