<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="chrome=1" />
        <title>How to Compile Your Language</title>
        <link rel="icon" href="./favicon.ico" />
        <link rel="stylesheet" href="stylesheets/styles.css" />
        <link rel="stylesheet" href="stylesheets/pygment_trac.css" />
        <meta name="viewport" content="width=device-width" />
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="wrapper">
            <header>
                <ul>
                    <li>
                        <a href="index.html">Intro </a>
                    </li>
                    <li><a href="lexing.html">Lexing</a></li>
                    <li><a href="parsing.html">Parsing</a></li>
                    <li>
                        <a href="extending-the-parser.html"
                            >Extending the Language</a
                        >
                    </li>
                    <li><a href="sema.html">Semantic Analysis</a></li>
                    <li><a href="codegen.html">Generating LLVM IR</a></li>
                    <li><a href="driver.html">Driver</a></li>
                    <li>
                        <a href="operators.html">Operators</a>
                    </li>
                    <li>
                        <a href="constexpr.html">Constant Expression</a>
                    </li>
                    <li>
                        <a href="control-flow.html">Control Flow</a>
                    </li>
                    <li>
                        <a href="variables.html">Variables</a>
                        <div id="toc"></div>
                    </li>
                </ul>
            </header>
            <section>
                <h1>Variables</h1>
                <p>
                    User defined variables allow the programmer to store and
                    manipulate values in memory. They are also essential for
                    some other constructs to work properly. Right now the
                    language doesn't have any way to modify a value, so for
                    example loops can only be infinitely running.
                </p>
                <h2>Immutability</h2>
                <p>
                    The language will support two kinds of variables, mutable
                    and immutable. Immutable variables cannot be changed over
                    time, once they are assigned a value, the value remains the
                    same for the entire lifetime of the variable. This can allow
                    the compiler to do further optimization and reason about
                    values better.
                </p>
                <pre><code>fn main(): void {
    let x = 3;
    
    // 'x' is immutable, the condition is always true
    if x < 4 {
        ....
    }
}</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        Reasoning about immutable values is only possible if
                        there really is no way to mutate them. For example in
                        C++ it is possible to have <code>const</code> variables,
                        which means that the value of the variable cannot be
                        changed, but the language also provides
                        <code>const_cast<>()</code>, which allows the mutation
                        of such values.
                    </p>
                    <pre><code>const int x = 3;

const int *ptr = &amp;x;
*const_cast&lt;int*>(ptr) = 2;

assert(ptr == &x && *ptr == 2);</code></pre>
                    <p>
                        Even though the result of the above snippet is undefined
                        behavior, the compiler still cannot assume that the
                        value never changes, as it's simply not true.
                    </p>
                </blockquote>
                <h2>Variables</h2>
                <p>
                    Immutable variables can be defined with the
                    <code>let</code> keyword, while mutable variables are
                    defined with the <code>var</code> keyword.
                </p>
                <pre><code>let immutable ...;
var mutable ...;</code></pre>
                <p>
                    The statement seen above is called a declaration statement,
                    as it's a statement that declares a variable.
                </p>
                <pre><code>&lt;declStmt>
  ::= ('let' | 'var') &lt;varDecl></code></pre>
                <p>
                    In a variable declaration the identifier is followed by a
                    type annotation and an optional initializer. If an
                    initializer is given however, the type annotation is not
                    necessary, because the compiler can figure out the type from
                    the initializer.
                </p>
                <pre><code>let x: number; // type annotation necessary
var y = 1;     // type inferred from the initializer</code></pre>
                <p>In the grammar this is described by the following rule.</p>
                <pre><code>&lt;varDecl>
  ::= &lt;identifier> (':' &lt;type>)? ('=' &lt;expr>)?</code></pre>
                <p>
                    The previously seen grammar rules introduce the
                    <code>let</code> and <code>var</code> keywords and the
                    <code>=</code> token, which need to be added to the lexer.
                </p>
                <pre><code>enum class TokenKind : char {
  ...
  Equal,
  KwLet,
  KwVar,
  ...
};

const std::unordered_map&lt;std::string_view, TokenKind> keywords = {
    ...,    
    {"let", TokenKind::KwLet}, {"var", TokenKind::KwVar}};
</code></pre>
                <p>
                    The <code>=</code> token changes the logic of
                    <code>getNextToken()</code> too, because so far it can only
                    lex <code>==</code>. It is modified such that if the current
                    character is <code>'='</code>, it peeks the next one and if
                    that is not an <code>'='</code> the lexer returns the
                    <code>=</code> token, otherwise it returns <code>==</code>.
                </p>
                <pre><code>Token Lexer::getNextToken() {
  ...

  if (currentChar == '=') {
    if (peekNextChar() != '=')
      return Token{tokenStartLocation, TokenKind::Equal};

    eatNextChar();
    return Token{tokenStartLocation, TokenKind::EqualEqual};
  }

  ...
}</code></pre>
                <p>
                    The AST of a variable declaration encapsulates it's
                    identifier, the optional type annotation and initializer and
                    whether the variable is mutable or not.
                </p>
                <pre><code>struct VarDecl : public Decl {
  std::optional&lt;Type> type;
  std::unique_ptr&lt;Expr> initializer;
  bool isMutable;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>
                    The AST of the declaration statement is just a wrapper
                    around a <code>VarDecl</code>.
                </p>
                <pre><code>struct DeclStmt : public Stmt {
  std::unique_ptr&lt;VarDecl> varDecl;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>
                    The parsing of the <code>DeclStmt</code> is driven by the
                    <code>parseStmt()</code> method. Since this statement is
                    also followed by a <code>;</code>, it is first parsed into a
                    temporary variable so that the parser can check the
                    <code>;</code> at the end.
                </p>
                <pre><code>std::unique_ptr&lt;Stmt> Parser::parseStmt() {
  ...

  std::unique_ptr&lt;Stmt> expr = nullptr;
  if (nextToken.kind == TokenKind::KwLet || nextToken.kind == TokenKind::KwVar)
    expr = parseDeclStmt();
  else {
    expr = parseExpr();
  }

  if (!expr)
    return nullptr;

  if (nextToken.kind != TokenKind::Semi)
  ...
}</code></pre>
                <p>
                    Parsing the <code>DeclStmt</code> is an easy process. First
                    the leading <code>let</code> or <code>var</code> is eaten,
                    then the identifier which is followed by the parsing of a
                    <code>VarDecl</code>. The parser of the
                    <code>VarDecl</code> needs to be provided with the
                    information whether the declaration statement starts with a
                    <code>let</code>.
                </p>
                <pre><code>std::unique_ptr&lt;DeclStmt> Parser::parseDeclStmt() {
  Token tok = nextToken;
  eatNextToken(); // eat 'let' | 'var'

  if (nextToken.kind != TokenKind::Identifier)
    return report(nextToken.location, "expected identifier");

  varOrReturn(varDecl, parseVarDecl(tok.kind == TokenKind::KwLet));

  return std::make_unique&lt;DeclStmt>(tok.location, std::move(varDecl));
}</code></pre>
                <p>
                    Parsing the variable declaration is a bit more complex since
                    both the type annotation and the initializer can be
                    optional. It is known however that the first token is an
                    identifier.
                </p>
                <pre><code>std::unique_ptr&lt;VarDecl> Parser::parseVarDecl(bool isLet) {
  SourceLocation location = nextToken.location;

  assert(nextToken.value && "identifier token without value");

  std::string identifier = *nextToken.value;
  eatNextToken(); // eat identifier

  ...
}</code></pre>
                <p>
                    Then the parser checks if the identifier is followed by a
                    <code>:</code>, which indicates a type annotation. If this
                    is the case, the type annotation is parsed.
                </p>
                <pre><code>std::unique_ptr&lt;VarDecl> Parser::parseVarDecl(bool isLet) {
  ...

  std::optional&lt;Type> type;
  if (nextToken.kind == TokenKind::Colon) {
    eatNextToken(); // eat ':'

    type = parseType();
    if (!type)
      return nullptr;
  }

  ...
}</code></pre>
                <p>
                    Once the type is handled, the parser checks if there is an
                    <code>=</code> token, which indicates an initializer. If it
                    doesn't find such token, it returns the AST node, otherwise
                    it parses the initializer and only then returns the node.
                </p>
                <pre><code>std::unique_ptr&lt;VarDecl> Parser::parseVarDecl(bool isLet) {
  ...

  if (nextToken.kind != TokenKind::Equal)
    return std::make_unique&lt;VarDecl>(location, identifier, type, !isLet);
  eatNextToken(); // eat '='

  varOrReturn(initializer, parseExpr());

  return std::make_unique&lt;VarDecl>(location, identifier, type, !isLet,
                                   std::move(initializer));
}</code></pre>
                <p>
                    The resolved nodes are identical to their non-resolved
                    counterparts, except for containing other resolved nodes.
                </p>
                <pre><code>struct ResolvedVarDecl : public ResolvedDecl {
  std::unique_ptr&lt;ResolvedExpr> initializer;
  bool isMutable;

  ...
};</code></pre>
                <pre><code>struct ResolvedDeclStmt : public ResolvedStmt {
  std::unique_ptr&lt;ResolvedVarDecl> varDecl;

  ...
};</code></pre>
                <p>
                    The resolution of the <code>DeclStmt</code> is driven by
                    <code>resolveStmt()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedStmt> Sema::resolveStmt(const Stmt &stmt) {
  ...

  if (auto *declStmt = dynamic_cast&lt;const DeclStmt *>(&stmt))
    return resolveDeclStmt(*declStmt);

  ...
}</code></pre>
                <p>
                    First the <code>VarDecl</code> is resolved, and if the
                    resolution is successful, the variable is inserted into the
                    current scope.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedDeclStmt>
Sema::resolveDeclStmt(const DeclStmt &declStmt) {
  varOrReturn(resolvedVarDecl, resolveVarDecl(*declStmt.varDecl));

  if (!insertDeclToCurrentScope(*resolvedVarDecl))
    return nullptr;

  return std::make_unique&lt;ResolvedDeclStmt>(declStmt.location,
                                            std::move(resolvedVarDecl));
}</code></pre>
                <p>
                    A <code>VarDecl</code> must either have a type annotation or
                    an initializer. If both of them are missing, an error is
                    reported.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedVarDecl> Sema::resolveVarDecl(const VarDecl &varDecl) {
  if (!varDecl.type && !varDecl.initializer)
    return report(
        varDecl.location,
        "an uninitialized variable is expected to have a type specifier");

  ...
}</code></pre>
                <p>
                    To be able to infer the type, if there is an initializer it
                    has to be resolved first.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedVarDecl> Sema::resolveVarDecl(const VarDecl &varDecl) {
  ...

  std::unique_ptr&lt;ResolvedExpr> resolvedInitializer = nullptr;
  if (varDecl.initializer) {
    resolvedInitializer = resolveExpr(*varDecl.initializer);
    if (!resolvedInitializer)
      return nullptr;
  }

  ...
}</code></pre>
                <p>
                    The type that needs to be resolved is either the type of the
                    variable, or if it's not specified, the type of the
                    initializer.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedVarDecl> Sema::resolveVarDecl(const VarDecl &varDecl) {
  ...

  Type resolvableType = varDecl.type.value_or(resolvedInitializer->type);
  std::optional&lt;Type> type = resolveType(resolvableType);

  ...
}</code></pre>
                <p>
                    If the type cannot be resolved, or it is
                    <code>void</code> an error is reported to the user.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedVarDecl> Sema::resolveVarDecl(const VarDecl &varDecl) {
  ...

  if (!type || type->kind == Type::Kind::Void)
    return report(varDecl.location, "variable '" + varDecl.identifier +
                                        "' has invalid '" +
                                        resolvableType.name + "' type");

  ...
}</code></pre>
                <p>
                    Finally, the case is handled when there is both an
                    initializer and a type specifier, but they are of different
                    types. The initializer is also evaluated by the constant
                    expression evaluator. If everything was successful, the
                    resolved node is returned.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedVarDecl> Sema::resolveVarDecl(const VarDecl &varDecl) {
  ...

  if (resolvedInitializer) {
    if (resolvedInitializer->type.kind != type->kind)
      return report(resolvedInitializer->location, "initializer type mismatch");

    resolvedInitializer->setConstantValue(cee.evaluate(*resolvedInitializer, false));
  }

  return std::make_unique&lt;ResolvedVarDecl>(varDecl.location, varDecl.identifier,
                                           *type, varDecl.isMutable,
                                           std::move(resolvedInitializer));
}</code></pre>
                <p>
                    With the introduction of variables, the components
                    responsible for code analysis can also be extended. In the
                    tree walk interpreter it now makes sense to handle
                    <code>DeclRefExpr</code> too. Prior to the introduction of
                    variables, this expression could only point to parameters
                    and functions, but none of them could be evaluated in
                    compile time.
                </p>
                <pre><code>std::optional&lt;double>
ConstantExpressionEvaluator::evaluate(const ResolvedExpr &expr,
                                      bool allowSideEffects) {
  ...

  if (const auto *declRefExpr =
          dynamic_cast&lt;const ResolvedDeclRefExpr *>(&expr))
    return evaluateDeclRefExpr(*declRefExpr, allowSideEffects);

  ...
}</code></pre>
                <p>
                    If a variable is immutable and initialized upon declaration,
                    it's value is set by the initializer and doesn't change over
                    time. Because of this, the value of the variable is known in
                    compile time.
                </p>
                <pre><code>std::optional&lt;double> 
ConstantExpressionEvaluator::evaluateDeclRefExpr(const ResolvedDeclRefExpr &dre,
                                                 bool allowSideEffects) {
  const auto *rvd = dynamic_cast&lt;const ResolvedVarDecl *>(dre.decl);
  if (!rvd || rvd->isMutable || !rvd->initializer)
    return std::nullopt;

  return evaluate(*rvd->initializer, allowSideEffects);
}</code></pre>
                <p>
                    The control flow graph can also be extended by the new
                    variable declarations, which extension becomes necessary
                    soon.
                </p>
                <pre><code>int CFGBuilder::insertStmt(const ResolvedStmt &stmt, int block) {
  ...

  if (auto *declStmt = dynamic_cast&lt;const ResolvedDeclStmt *>(&stmt))
    return insertDeclStmt(*declStmt, block);

  ...
}</code></pre>
                <p>
                    Because the CFG is constructed in a reverse order, from
                    bottom to top, first the <code>DeclStmt</code> is inserted,
                    then the initializer if there's one.
                </p>
                <pre><code>int CFGBuilder::insertDeclStmt(const ResolvedDeclStmt &stmt, int block) {
  cfg.insertStmt(&stmt, block);

  if (const auto &init = stmt.varDecl->initializer)
    return insertExpr(*init, block);

  return block;
}</code></pre>
                <p>
                    The LLVM IR generation is driven by
                    <code>generateStmt()</code>.
                </p>
                <pre><code>llvm::Value *Codegen::generateStmt(const ResolvedStmt &stmt) {
  ...

  if (auto *declStmt = dynamic_cast&lt;const ResolvedDeclStmt *>(&stmt))
    return generateDeclStmt(*declStmt);

  ...
}</code></pre>
                <p>
                    When a variable is declared, first some space on the stack
                    has to be allocated for it. If it's initialized, the value
                    of the initializer is stored in this space. Finally the
                    variable is added to the declarations map.
                </p>
                <pre><code>llvm::Value *Codegen::generateDeclStmt(const ResolvedDeclStmt &stmt) {
  llvm::Function *function = getCurrentFunction();
  const auto *decl = stmt.varDecl.get();

  llvm::AllocaInst *var = allocateStackVariable(function, decl->identifier);

  if (const auto &init = decl->initializer)
    builder.CreateStore(generateExpr(*init), var);

  declarations[decl] = var;
  return nullptr;
}</code></pre>
                <h2>Assignment</h2>
                <p>
                    Now variables can be created an initialized, but their
                    values cannot be changed even if they are mutable. To
                    address this issue, the language must support assignments
                    too.
                </p>
                <pre><code>&lt;assignment>
  ::= &lt;declRefExpr> '=' &lt;expr></code></pre>
                <p>
                    The grammar is constructed such that assignments are easy to
                    parse and analyze later. Since only declared values can be
                    assigned, the LHS is a <code>DeclRefExpr</code>.
                </p>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        In more complex languages the LHS of an assignment can
                        be an arbitrary expression as even
                        <code>a.b().c.d = 1;</code> can mean a valid assignment.
                        In this case it's the responsibility of the semantic
                        analyzer to ensure, the LHS is indeed a variable that
                        can be assigned a new value.
                    </p>
                </blockquote>
                <p>
                    The rule doesn't introduce any new tokens, so the lexer
                    doesn't need to be modified before the assignment can be
                    parsed.
                </p>
                <p>
                    The <code>Assignment</code> node encapsulated the
                    <code>DeclRefExpr</code> on the left hand side and the
                    arbitrary expression on the right hand side.
                </p>
                <pre><code>struct Assignment : public Stmt {
  std::unique_ptr&lt;DeclRefExpr> variable;
  std::unique_ptr&lt;Expr> expr;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>
                    Since both an expression and an assignment can start with a
                    <code>DeclRefExpr</code> on the LHS,
                    <code>parseStmt()</code> is modified such that it parses a
                    prefix expression first and if it's a
                    <code>DeclRefExpr</code> and the next token is
                    <code>=</code> it proceeds with parsing the assignment,
                    otherwise it proceeds with parsing a regular expression.
                </p>
                <pre><code>std::unique_ptr&lt;Stmt> Parser::parseStmt() {
  ...

  else {
    varOrReturn(lhs, parsePrefixExpr());

    if (nextToken.kind != TokenKind::Equal)
      expr = parseExprRHS(std::move(lhs), 0);
    else if (auto *dre = dynamic_cast&lt;DeclRefExpr *>(lhs.get())) {
      std::ignore = lhs.release();
      expr = parseAssignmentRHS(std::unique_ptr&lt;DeclRefExpr>(dre));
    } else
      return report(nextToken.location,
                    "expected variable on the LHS of an assignment");
  }

  ...
}</code></pre>
                <p>
                    The <code>parseAssignmentRHS()</code> method is similar to
                    <code>parseExpressionRHS()</code> in that it also takes the
                    LHS as a parameter. It then proceeds by parsing the
                    arbitrary expression on the RHS and returns the assignment
                    node.
                </p>
                <pre><code>std::unique_ptrstd::unique_ptr&lt;Assignment>
Parser::parseAssignmentRHS(std::unique_ptr&lt;DeclRefExpr> lhs) {
  eatNextToken(); // eat '='

  varOrReturn(rhs, parseExpr());

  return std::make_unique&lt;Assignment>(lhs->location, std::move(lhs),
                                      std::move(rhs));
}</code></pre>
                <p>
                    The resolved assignment node captures the resolved LHS and
                    resolved RHS.
                </p>
                <pre><code>struct ResolvedAssignment : public ResolvedStmt {
  std::unique_ptr&lt;ResolvedDeclRefExpr> variable;
  std::unique_ptr&lt;ResolvedExpr> expr;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>
                    The resolution is driven by the
                    <code>resolveStmt()</code> method.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedStmt> Sema::resolveStmt(const Stmt &stmt) {
  ...

  if (auto *assignment = dynamic_cast&lt;const Assignment *>(&stmt))
    return resolveAssignment(*assignment);

  ...
}</code></pre>
                <p>
                    The resolution of the <code>Assignment</code> starts with
                    the resolution of the LHS and the RHS.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedAssignment>
Sema::resolveAssignment(const Assignment &assignment) {
  varOrReturn(resolvedLHS, resolveDeclRefExpr(*assignment.variable));
  varOrReturn(resolvedRHS, resolveExpr(*assignment.expr));

  ...
}</code></pre>
                <p>
                    It's known that the referenced declaration on the LHS cannot
                    be <code>void</code>, as only function declarations can be
                    <code>void</code>, however if the LHS is a reference to a
                    function declaration, it couldn't have been resolved.
                    Function parameters are immutable, so assigning a value to
                    any of them is an error.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedAssignment>
Sema::resolveAssignment(const Assignment &assignment) {
  ...

  assert(resolvedLHS->type.kind != Type::Kind::Void &&
         "reference to void declaration in assignment LHS");

  if (dynamic_cast&lt;const ResolvedParamDecl *>(resolvedLHS->decl))
    return report(resolvedLHS->location,
                  "parameters are immutable and cannot be assigned");

  ...
}</code></pre>
                <p>
                    If the LHS is not a parameter, it must be a variable. If the
                    type of the variable doesn't match the type of the assigned
                    value, an error is reported. Otherwise the RHS is tried to
                    be evaluated as a constant expression and the resolved node
                    is returned.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedAssignment>
  Sema::resolveAssignment(const Assignment &assignment) {
    ...
  
    auto *var = dynamic_cast&lt;const ResolvedVarDecl *>(resolvedLHS->decl);
    assert(var && "assignment LHS is not a variable");
  
    if (resolvedRHS->type.kind != resolvedLHS->type.kind)
      return report(resolvedRHS->location,
                    "assigned value type doesn't match variable type");
  
    resolvedRHS->setConstantValue(cee.evaluate(*resolvedRHS, false));
  
    return std::make_unique&lt;ResolvedAssignment>(
        assignment.location, std::move(resolvedLHS), std::move(resolvedRHS));
  }</code></pre>
                <p>
                    Assignments need to be introduced to the CFG builder for
                    flow-sensitive analysis to work properly.
                </p>
                <pre><code>int CFGBuilder::insertStmt(const ResolvedStmt &stmt, int block) {
  ...

  if (auto *assignment = dynamic_cast&lt;const ResolvedAssignment *>(&stmt))
    return insertAssignment(*assignment, block);

  ...
}</code></pre>
                <p>
                    Only the <code>Assignment</code> itself and the assigned
                    expression is inserted into the CFG to avoid ambiguities.
                </p>
                <pre><code>int CFGBuilder::insertAssignment(const ResolvedAssignment &stmt, int block) {
  cfg.insertStmt(&stmt, block);
  return insertExpr(*stmt.expr, block);
}</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        Consider the CFG of <code>x = x;</code> if the
                        <code>DeclRefExpr</code> on the LHS is also inserted.
                    </p>
                    <pre><code>ResolvedDeclRefExpr: x
ResolvedDeclRefExpr: x
ResolvedAssignment: ...</code></pre>
                    <p>
                        By traversing the CFG both the LHS and the RHS looks the
                        same. This means that in an arbitrary situation there is
                        no way to know whether a
                        <code>ResolvedDeclRefExpr</code> is reading the value or
                        writing it without checking the next statement. This is
                        also a problem in the Clang CFG, where both sided of an
                        assignment are inserted like this.
                    </p>
                </blockquote>
                <p>
                    As the IR generation of every other statement, the
                    generation of the assignment is also driven by
                    <code>generateStmt()</code>.
                </p>
                <pre><code>llvm::Value *Codegen::generateStmt(const ResolvedStmt &stmt) {
  ...

  if (auto *assignment = dynamic_cast&lt;const ResolvedAssignment *>(&stmt))
    return generateAssignment(*assignment);

  ...
}</code></pre>
                <p>
                    An assignment is simply a store instruction to the
                    referenced variable.
                </p>
                <pre><code>llvm::Value *Codegen::generateAssignment(const ResolvedAssignment &stmt) {
  return builder.CreateStore(generateExpr(*stmt.expr),
                             declarations[stmt.variable->decl]);
}</code></pre>
                <h2>Lazy Initialization</h2>
                <p>
                    Lazy initialization allows the programmer to declare a
                    variable and initialize it later. This can come in handy if
                    the value of an immutable variable depends on some other
                    variable.
                </p>
                <pre><code>fn calculateAddress(base: number, offset: number, useLegacyMode: number): number {
    let pointerSize: number;

    if useLegacyMode {
        pointerSize = 4;
    } else {
        pointerSize = 8;
    }

    ...
}</code></pre>
                <p>
                    This feature can however quickly lead to error prone code if
                    the compiler doesn't perform proper analysis to prevent it.
                    For example the value might not be initialized before it is
                    used.
                </p>
                <pre><code>fn calculateAddress(base: number, offset: number, useLegacyMode: number): number {
    let pointerSize: number;

    if useLegacyMode {
        pointerSize = 4;
    }

    // uninitialized if 'useLegacyMode' is false
    println(pointerSize); 

    ...
}</code></pre>
                <p>
                    Another problem that can happen is the mutation of an
                    immutable variable in a loop.
                </p>
                <pre><code>fn mutateImmutable(): void {
    let lazy: number;
    
    var i = 2;
    while i > 0 {
        // the first iteration initializes,
        // the second mutates the value
        lazy = i;

        i = i - 1;
    }
}</code></pre>
                <p>
                    Intuitively if a variable is not initialized, the first time
                    it appears on the left side of an assignment, it gets
                    initialized, the second time it gets mutated. Detecting the
                    first and second assignment however is not a trivial task as
                    every path of execution needs to be considered.
                </p>
                <pre><code>fn noMutation(): void {
    let lazy: number;
    
    // seemingly infinite loop
    while 1 {
        lazy = 1;

        // exits after the first iteration, no mutation
        return;
    }
}</code></pre>
                <pre><code>fn mutation(condition: number): void {
    let lazy: number;
    
    if condition {
        lazy = 1;
    }
    
    // initialization if the condition is false
    // mutation otherwise
    lazy = 2;
}</code></pre>
                <p>
                    Performing the analysis with regular AST traversal would
                    prove to be difficult, as there are a lot of variables to
                    keep in mind like if the loop iterates more than once, or
                    branches of nested conditions. There is however a technique
                    called data flow analysis, which can easily reason about
                    this problem.
                </p>
                <h2>Data Flow Analysis</h2>
                <p>
                    Data flow analysis is a technique that collects information
                    about how certain values can change over the execution of
                    the program without actually executing it
                </p>
                <p>
                    The core of the technique is the traversal of the control
                    flow graph of a function until the result of the analysis
                    changes. In a more formal way, data flow analysis is a
                    fixpoint iteration over the CFG.
                </p>
                <p>
                    The most important data structure in data flow analysis is
                    the <code>Lattice</code>. A lattice is an ordered data
                    structure, that stores the information about the program in
                    each basic block. In case of lazy initialization it is
                    modelled as a mapping of a declaration to it's assignment
                    state.
                </p>
                <p>
                    At a certain point of the program a variable is either
                    <code>Assigned</code>, <code>Unassigned</code>, both of
                    them, or neither of them. A variable can be both assigned
                    and unassigned after an if statement, where only the true
                    branch assigns a value to it. This state is called
                    <code>Top</code> in the mapping. The neither case happens
                    when a variable is not declared or not found in the lattice,
                    so the analyzer has no information about it. This state is
                    called <code>Bottom</code>.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  enum class State { Bottom, Unassigned, Assigned, Top };

  ...
}</code></pre>
                <p>
                    Notice how the first value in <code>State</code> is
                    <code>Bottom</code>. If a state is not found in the map, one
                    will automatically be default constructed. The default
                    constructor of an enum yields it's first value, so
                    <code>Bottom</code> is returned.
                </p>
                <p>
                    At a certain point during the analysis multiple lattices
                    need to be combined (joined) with each other. In such cases
                    each of the states are combined the following way.
                </p>
                <ul>
                    <li>
                        If both <code>State</code> has the same value, their
                        joined value is the same too. E.g.:
                        <code>join(Assigned, Assigned) -> Assigned</code>
                    </li>
                    <li>
                        If either <code>State</code> is <code>Bottom</code>, the
                        result is the other state. E.g.:
                        <code>join(Bottom, Unassigned) -> Unassigned</code>
                    </li>
                    <li>
                        If one case is <code>Assigned</code> and the other is
                        <code>Unassigned</code>, the result is <code>Top</code>.
                        E.g.: <code>joint(Assigned, Unassigned) -> Top</code>
                    </li>
                    <li>
                        If either of the states is <code>Top</code>, the result
                        is <code>Top</code> too. E.g.:
                        <code>join(Unassigned, Top) -> Top</code>
                    </li>
                </ul>
                <p>
                    As a result, after performing multiple joins over time, the
                    result either stays the same, or reaches the
                    <code>Top</code> state and then keeps staying the same.
                    Formally the result reaches a fixpoint over time.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...

  auto joinStates = [](State s1, State s2) {
    if (s1 == s2)
      return s1;

    if (s1 == State::Bottom)
      return s2;

    if (s2 == State::Bottom)
      return s1;

    return State::Top;
  };

  using Lattice = std::map&lt;const ResolvedVarDecl *, State>;

  ...
}</code></pre>
                <p>
                    Initially every CFG block is assigned an empty lattice,
                    which will be filled in during the traversal.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...
  std::vector&lt;Lattice> curLattices(cfg.basicBlocks.size());
  
  ...
}</code></pre>
                <p>
                    Because the analysis iterates over the CFG multiple times,
                    any reported error can appear more than once. To tackle this
                    problem, instead of directly reporting an error, it is first
                    put into a container and processed once the analysis
                    finishes.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...
  std::vector&lt;std::pair&lt;SourceLocation, std::string>> pendingErrors;

  ...
}</code></pre>
                <p>
                    As mentioned before the core of the analysis is a fixpoint
                    iteration over the CFG. At the start of each iteration the
                    <code>changed</code> flag is set to false and the pending
                    errors are cleared.
                </p>
                <p>
                    Then each basic block is visited starting with the entry
                    block. For each block a new temporary lattice is created.
                    After the statements of the block have been processed, it's
                    checked if the temporary block is different from the
                    previously known block, stored in
                    <code>curLattices</code>.
                </p>
                <p>
                    If the block changed, the <code>changed</code> flag is set
                    to true, so that one more iteration is performed and the
                    temporary block becomes the new known block.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...

  bool changed = true;
  while (changed) {
    changed = false;
    pendingErrors.clear();

    for (int bb = cfg.entry; bb != cfg.exit; --bb) {
      Lattice tmp;
      
      ...

      if (curLattices[bb] != tmp) {
        curLattices[bb] = tmp;
        changed = true;
      }
    }
  }

  ...
}</code></pre>
                <p>
                    After the creation of the temporary lattice, the lattices of
                    the predecessor blocks are joined together in the current
                    one. This way the information at the end of each predecessor
                    block is transferred into the current one.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...

    for (int bb = cfg.entry; bb != cfg.exit; --bb) {
      ...
      
      const auto &[preds, succs, stmts] = cfg.basicBlocks[bb];
      for (auto &&pred : preds)
        for (auto &&[decl, state] : curLattices[pred.first])
          tmp[decl] = joinStates(tmp[decl], state);

      ...
    }
    ...
}</code></pre>
                <p>
                    Once the temporary lattice is prepared, the processing of
                    statements in the current block can begin. Since the CFG was
                    built from bottom to top, the statements need to be visited
                    in a reverse order.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...

    for (int bb = cfg.entry; bb != cfg.exit; --bb) {
      ...

      for (auto it = stmts.rbegin(); it != stmts.rend(); ++it) {
        const ResolvedStmt *stmt = *it;

        ...
      }

      ...
    }
  ...
}</code></pre>
                <p>
                    Upon seeing a <code>DeclStmt</code>, the variable is added
                    to the lattice and the state is set to
                    <code>Assigned</code> or <code>Unassigned</code> depending
                    on whether the variable was initialized or not.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...
      for (auto it = stmts.rbegin(); it != stmts.rend(); ++it) {
        ...

        if (const auto *declStmt =
                dynamic_cast&lt;const ResolvedDeclStmt *>(stmt)) {
          tmp[declStmt->varDecl.get()] = declStmt->varDecl->initializer
                                             ? State::Assigned
                                             : State::Unassigned;
        } 
        
        ...
      }
  ...
}</code></pre>
                <p>
                    In case of an assignment if the LHS is an immutable variable
                    and the current state is not <code>Unassigned</code>, a
                    pending error is created, as this is the mutation of an
                    immutable value. In every other case the state of the LHS is
                    set to <code>Assigned</code>.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...
      for (auto it = stmts.rbegin(); it != stmts.rend(); ++it) {
        ...

        } else if (const auto *assignment =
                       dynamic_cast&lt;const ResolvedAssignment *>(stmt)) {
          const auto *varDecl =
              dynamic_cast&lt;const ResolvedVarDecl *>(assignment->variable->decl);

          assert(varDecl &&
                 "assignment to non-variables should have been caught by sema");

          if (!varDecl->isMutable && tmp[varDecl] != State::Unassigned)
            pendingErrors.emplace_back(assignment->location,
                                       '\'' + varDecl->identifier +
                                           "' cannot be mutated");

          tmp[varDecl] = State::Assigned;
        }

        ...
      }
  ...
}</code></pre>
                <p>
                    The third and the last statement the analyzer cares about is
                    the <code>DeclRefExpr</code>. This statement reads the value
                    of the variable, so if the referenced variable is not in the
                    <code>Assigned</code> state, a pending error is created.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...
      for (auto it = stmts.rbegin(); it != stmts.rend(); ++it) {
        ...
        
        } else if (const auto *declRefExpr =
                       dynamic_cast&lt;const ResolvedDeclRefExpr *>(stmt)) {
          const auto *varDecl =
              dynamic_cast&lt;const ResolvedVarDecl *>(declRefExpr->decl);

          if (varDecl && tmp[varDecl] != State::Assigned)
            pendingErrors.emplace_back(declRefExpr->location,
                                       '\'' + varDecl->identifier +
                                           "' is not initialized");
        }
      }
  ...
}</code></pre>
                <p>
                    Finally after the lattices reached a fixpoint, the pending
                    errors are reported and the function returns if it found any
                    errors.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...

  for (auto &&[loc, msg] : pendingErrors)
    report(loc, msg);

  return !pendingErrors.empty();
}</code></pre>
                <p>
                    Along with the other flow-sensitive check, this analysis is
                    also invoked in <code>runFlowSensitiveChecks()</code>.
                </p>
                <pre><code>bool Sema::runFlowSensitiveChecks(const ResolvedFunctionDecl &fn) {
  ...
  error |= checkVariableInitialization(fn, cfg);

  ...
};</code></pre>
            </section>
            <footer>
                <p>
                    <small
                        >Hosted on GitHub Pages &mdash; Theme by
                        <a href="https://github.com/orderedlist" target="_blank"
                            >orderedlist</a
                        ></small
                    >
                </p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
        <script src="javascripts/toc.js"></script>
    </body>
</html>
