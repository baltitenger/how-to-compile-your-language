<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="chrome=1" />
        <title>How to Compile Your Language</title>
        <link rel="icon" href="./favicon.ico" />
        <link rel="stylesheet" href="stylesheets/styles.css" />
        <link rel="stylesheet" href="stylesheets/pygment_trac.css" />
        <meta name="viewport" content="width=device-width" />
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="wrapper">
            <header>
                <ul>
                    <li>
                        <a href="index.html">Prologue </a>
                    </li>
                    <li><a href="lexing.html">Lexing</a></li>
                    <li><a href="parsing.html">Parsing</a></li>
                    <li>
                        <a href="extending-the-parser.html"
                            >Extending the Language</a
                        >
                    </li>
                    <li><a href="sema.html">Semantic Analysis</a></li>
                    <li><a href="codegen.html">Generating LLVM IR</a></li>
                    <li><a href="driver.html">Driver</a></li>
                    <li>
                        <a href="operators.html">Operators</a>
                    </li>
                    <li>
                        <a href="constexpr.html">Constant Expressions</a>
                    </li>
                    <li>
                        <a href="control-flow.html">Control Flow</a>
                    </li>
                    <li>
                        <a href="variables.html">Variables</a>
                        <div id="toc"></div>
                    </li>
                    <br />
                    <li>
                        <a href="structs.html">Exercise: Structs</a>
                    </li>
                </ul>
            </header>
            <section>
                <h1>Variables</h1>
                <p>
                    User-defined variables allow the programmer to store and
                    manipulate values in memory. They are also essential for
                    some other constructs to work properly. Right now the
                    language doesn't have any way to modify a value, so for
                    example loops can only be infinitely running or not running
                    at all.
                </p>
                <h2>Immutability</h2>
                <p>
                    The language supports two kinds of variables, mutable and
                    immutable. Immutable variables cannot be changed over time,
                    once they are assigned a value, the value remains the same
                    for the entire lifetime of the variable. This allows the
                    compiler to do further optimization and reason about values
                    better.
                </p>
                <pre><code>fn main(): void {
    let x = 3;
    
    ...

    // 'x' is immutable, the condition is always true
    if x < 4 {
        ....
    }
}</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        Reasoning about immutable values is only possible if
                        there really is no way to mutate them. For example, in
                        C++ it is possible to have <code>const</code> variables,
                        which means that the value of the variable cannot be
                        changed, but the language also provides
                        <code>const_cast<>()</code>, which allows the mutation
                        of such values.
                    </p>
                    <pre><code>const int x = 3;

const int *ptr = &amp;x;
*const_cast&lt;int*>(ptr) = 2;

assert(ptr == &x &amp;&amp; *ptr == 2);</code></pre>
                    <p>
                        Even though the result of the above snippet is undefined
                        behaviour, the compiler cannot assume that the value
                        never changes, as it's simply not true.
                    </p>
                </blockquote>
                <h2>Variables</h2>
                <p>
                    Immutable variables can be defined with the
                    <code>let</code> keyword, while mutable variables are
                    defined with the <code>var</code> keyword.
                </p>
                <pre><code>let immutable ...;
var mutable ...;</code></pre>
                <p>
                    The statement above is called a declaration statement, as
                    it's a statement that declares a variable.
                </p>
                <pre><code>&lt;declStmt>
  ::= ('let' | 'var') &lt;varDecl> ';'</code></pre>
                <p>
                    In a variable declaration, the identifier is followed by a
                    type annotation and an optional initializer. If an
                    initializer is given, however, the type annotation is not
                    necessary, because the compiler can figure out the type from
                    the initializer.
                </p>
                <pre><code>let x: number; // type annotation necessary
var y = 1;     // type inferred from the initializer</code></pre>
                <p>In the grammar, this is described by the following rule.</p>
                <pre><code>&lt;varDecl>
  ::= &lt;identifier> (':' &lt;type>)? ('=' &lt;expr>)?</code></pre>
                <p>
                    The previously seen grammar rules introduce the
                    <code>let</code> and <code>var</code> keywords and the
                    <code>=</code> token, which need to be added to the lexer.
                </p>
                <pre><code>enum class TokenKind : char {
  ...
  Equal,
  KwLet,
  KwVar,
  ...
};

const std::unordered_map&lt;std::string_view, TokenKind> keywords = {
    ...,    
    {"let", TokenKind::KwLet}, {"var", TokenKind::KwVar}};
</code></pre>
                <p>
                    The <code>=</code> token changes the logic of
                    <code>getNextToken()</code> too because so far it can only
                    lex <code>==</code>. It is modified such that if the current
                    character is <code>'='</code>, it peeks the next one and if
                    that is not an <code>'='</code> the lexer returns the
                    <code>=</code> token, otherwise, it returns <code>==</code>.
                </p>
                <pre><code>Token Lexer::getNextToken() {
  ...

  if (currentChar == '=') {
    if (peekNextChar() != '=')
      return Token{tokenStartLocation, TokenKind::Equal};

    eatNextChar();
    return Token{tokenStartLocation, TokenKind::EqualEqual};
  }

  ...
}</code></pre>
                <p>
                    The AST of a variable declaration encapsulates its
                    identifier, the optional type annotation and initializer and
                    whether the variable is mutable or not.
                </p>
                <pre><code>struct VarDecl : public Decl {
  std::optional&lt;Type> type;
  std::unique_ptr&lt;Expr> initializer;
  bool isMutable;

  VarDecl(SourceLocation location,
          std::string identifier,
          std::optional&lt;Type> type,
          bool isMutable,
          std::unique_ptr&lt;Expr> initializer = nullptr)
      : Decl(location, std::move(identifier)),
        type(std::move(type)),
        initializer(std::move(initializer)),
        isMutable(isMutable) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    The textual representation of the node contains its
                    identifier and the type annotation along with the
                    initializer if any of them are present.
                </p>
                <pre><code>void VarDecl::dump(size_t level) const {
  std::cerr << indent(level) << "VarDecl: " << identifier;
  if (type)
    std::cerr << ':' << type->name;
  std::cerr << '\n';

  if (initializer)
    initializer->dump(level + 1);
}</code></pre>
                <p>
                    The AST of the declaration statement is just a wrapper
                    around a <code>VarDecl</code>.
                </p>
                <pre><code>struct DeclStmt : public Stmt {
  std::unique_ptr&lt;VarDecl> varDecl;

  DeclStmt(SourceLocation location, std::unique_ptr&lt;VarDecl> varDecl)
      : Stmt(location),
        varDecl(std::move(varDecl)) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    Its textual representation also contains the wrapped
                    <code>VarDecl</code> only.
                </p>
                <pre><code>void DeclStmt::dump(size_t level) const {
  std::cerr << indent(level) << "DeclStmt:\n";
  varDecl->dump(level + 1);
}</code></pre>
                <p>
                    The parsing of the <code>DeclStmt</code> is driven by the
                    <code>parseStmt()</code> method.
                </p>
                <pre><code>std::unique_ptr&lt;Stmt> Parser::parseStmt() {
  ...

  if (nextToken.kind == TokenKind::KwLet || nextToken.kind == TokenKind::KwVar)
    return parseDeclStmt();

  ...
}</code></pre>
                <p>
                    First, the current token is stored, because it is needed to
                    figure out if the declared variable is mutable or not.
                </p>
                <pre><code>std::unique_ptr&lt;DeclStmt> Parser::parseDeclStmt() {
  Token tok = nextToken;
  ...
}</code></pre>
                <p>
                    The leading <code>let</code> or <code>var</code> keyword is
                    eaten and it's checked if the upcoming token is an
                    identifier before the <code>VarDecl</code> is parsed. The
                    <code>parseVarDecl()</code> method needs to be provided with
                    the information if it's inside a <code>let</code> statement.
                </p>
                <pre><code>std::unique_ptr&lt;DeclStmt> Parser::parseDeclStmt() {
  ...
  eatNextToken(); // eat 'let' | 'var'

  matchOrReturn(TokenKind::Identifier, "expected identifier");
  varOrReturn(varDecl, parseVarDecl(tok.kind == TokenKind::KwLet));

  ...
}</code></pre>
                <p>
                    After parsing the variable declaration, the trailing
                    <code>;</code> is matched and if everything is successful, a
                    <code>DeclStmt</code> node is returned.
                </p>
                <pre><code>std::unique_ptr&lt;DeclStmt> Parser::parseDeclStmt() {
  ...

  matchOrReturn(TokenKind::Semi, "expected ';' after declaration");
  eatNextToken(); // eat ';'

  return std::make_unique&lt;DeclStmt>(tok.location, std::move(varDecl));
}</code></pre>
                <p>
                    The <code>parseVarDecl()</code> method takes a flag as a
                    parameter that shows if the variable is inside a
                    <code>let</code> statement. Parsing the variable declaration
                    is a bit more complex since both the type annotation and the
                    initializer are optional. It is known however that the first
                    token is an identifier.
                </p>
                <pre><code>std::unique_ptr&lt;VarDecl> Parser::parseVarDecl(bool isLet) {
  SourceLocation location = nextToken.location;

  std::string identifier = *nextToken.value;
  eatNextToken(); // eat identifier

  ...
}</code></pre>
                <p>
                    Then the parser checks if the identifier is followed by a
                    <code>:</code>, which indicates a type annotation. If this
                    is the case, the type annotation is parsed.
                </p>
                <pre><code>std::unique_ptr&lt;VarDecl> Parser::parseVarDecl(bool isLet) {
  ...

  std::optional&lt;Type> type;
  if (nextToken.kind == TokenKind::Colon) {
    eatNextToken(); // eat ':'

    type = parseType();
    if (!type)
      return nullptr;
  }

  ...
}</code></pre>
                <p>
                    Once the type is handled, the parser checks if there is an
                    <code>=</code> token, which indicates an initializer. If it
                    doesn't find such a token, it returns the AST node,
                    otherwise, it parses the initializer and returns a node
                    including that too.
                </p>
                <pre><code>std::unique_ptr&lt;VarDecl> Parser::parseVarDecl(bool isLet) {
  ...

  if (nextToken.kind != TokenKind::Equal)
    return std::make_unique&lt;VarDecl>(location, identifier, type, !isLet);
  eatNextToken(); // eat '='

  varOrReturn(initializer, parseExpr());

  return std::make_unique&lt;VarDecl>(location, identifier, type, !isLet,
                                   std::move(initializer));
}</code></pre>
                <p>
                    The resolved nodes are identical to their non-resolved
                    counterparts, except for containing other resolved nodes.
                </p>
                <p>
                    The <code>ResolvedVarDecl</code> node no longer stores an
                    optional type, as it must have its type set by the semantic
                    analyzer.
                </p>
                <pre><code>struct ResolvedVarDecl : public ResolvedDecl {
  std::unique_ptr&lt;ResolvedExpr> initializer;
  bool isMutable;

  ResolvedVarDecl(SourceLocation location,
                  std::string identifier,
                  Type type,
                  bool isMutable,
                  std::unique_ptr&lt;ResolvedExpr> initializer = nullptr)
      : ResolvedDecl(location, std::move(identifier), type),
        initializer(std::move(initializer)),
        isMutable(isMutable) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    Since it's a declaration, its textual representation
                    contains its address as well as its identifier and optional
                    initializer.
                </p>
                <pre><code>void ResolvedVarDecl::dump(size_t level) const {
  std::cerr << indent(level) << "ResolvedVarDecl: @(" << this << ") "
            << identifier << ':' << '\n';
  if (initializer)
    initializer->dump(level + 1);
}</code></pre>
                <p>
                    The resolved node of a <code>DeclStmt</code> is also just a
                    wrapper around a <code>VarDecl</code> as its AST node.
                </p>
                <pre><code>struct ResolvedDeclStmt : public ResolvedStmt {
  std::unique_ptr&lt;ResolvedVarDecl> varDecl;

  ResolvedDeclStmt(SourceLocation location,
                   std::unique_ptr&lt;ResolvedVarDecl> varDecl)
      : ResolvedStmt(location),
        varDecl(std::move(varDecl)) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>Their textual representations are also identical.</p>
                <pre><code>void ResolvedDeclStmt::dump(size_t level) const {
  std::cerr << indent(level) << "ResolvedDeclStmt:\n";
  varDecl->dump(level + 1);
}</code></pre>
                <p>
                    The resolution of the <code>DeclStmt</code> is driven by
                    <code>resolveStmt()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedStmt> Sema::resolveStmt(const Stmt &stmt) {
  ...

  if (auto *declStmt = dynamic_cast&lt;const DeclStmt *>(&stmt))
    return resolveDeclStmt(*declStmt);

  ...
}</code></pre>
                <p>
                    First, the <code>VarDecl</code> is resolved, and if the
                    resolution is successful, the variable is inserted into the
                    current scope.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedDeclStmt>
Sema::resolveDeclStmt(const DeclStmt &declStmt) {
  varOrReturn(resolvedVarDecl, resolveVarDecl(*declStmt.varDecl));

  if (!insertDeclToCurrentScope(*resolvedVarDecl))
    return nullptr;

  return std::make_unique&lt;ResolvedDeclStmt>(declStmt.location,
                                            std::move(resolvedVarDecl));
}</code></pre>
                <p>
                    A <code>VarDecl</code> must either have a type annotation or
                    an initializer. If both of them are missing, an error is
                    reported.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedVarDecl> Sema::resolveVarDecl(const VarDecl &varDecl) {
  if (!varDecl.type &amp;&amp; !varDecl.initializer)
    return report(
        varDecl.location,
        "an uninitialized variable is expected to have a type specifier");

  ...
}</code></pre>
                <p>
                    To be able to infer the type, if there is an initializer it
                    has to be resolved first.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedVarDecl> Sema::resolveVarDecl(const VarDecl &varDecl) {
  ...

  std::unique_ptr&lt;ResolvedExpr> resolvedInitializer = nullptr;
  if (varDecl.initializer) {
    resolvedInitializer = resolveExpr(*varDecl.initializer);
    if (!resolvedInitializer)
      return nullptr;
  }

  ...
}</code></pre>
                <p>
                    The type that needs to be resolved is either the type of the
                    variable or if it's not specified, the type of the
                    initializer.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedVarDecl> Sema::resolveVarDecl(const VarDecl &varDecl) {
  ...

  Type resolvableType = varDecl.type.value_or(resolvedInitializer->type);
  std::optional&lt;Type> type = resolveType(resolvableType);

  ...
}</code></pre>
                <p>
                    If the type cannot be resolved, or it is
                    <code>void</code> an error is reported to the user.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedVarDecl> Sema::resolveVarDecl(const VarDecl &varDecl) {
  ...

  if (!type || type->kind == Type::Kind::Void)
    return report(varDecl.location, "variable '" + varDecl.identifier +
                                        "' has invalid '" +
                                        resolvableType.name + "' type");

  ...
}</code></pre>
                <p>
                    Finally, the case is handled when there is both an
                    initializer and a type specifier, but they are of different
                    types. The initializer is also evaluated by the constant
                    expression evaluator.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedVarDecl> Sema::resolveVarDecl(const VarDecl &varDecl) {
  ...

  if (resolvedInitializer) {
    if (resolvedInitializer->type.kind != type->kind)
      return report(resolvedInitializer->location, "initializer type mismatch");

    resolvedInitializer->setConstantValue(cee.evaluate(*resolvedInitializer, false));
  }

  ...
}</code></pre>
                <p>
                    If everything is successful, the resolved node is returned.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedVarDecl> Sema::resolveVarDecl(const VarDecl &varDecl) {
  ...

  return std::make_unique&lt;ResolvedVarDecl>(varDecl.location, varDecl.identifier,
                                           *type, varDecl.isMutable,
                                           std::move(resolvedInitializer));
}</code></pre>
                <p>
                    With the introduction of variables, the components
                    responsible for code analysis can also be extended. In the
                    tree walk interpreter, it now makes sense to handle
                    <code>DeclRefExpr</code> too. Before the introduction of
                    variables, this expression could only point to parameters
                    and functions, but none of those can be evaluated in compile
                    time.
                </p>
                <pre><code>std::optional&lt;double>
ConstantExpressionEvaluator::evaluate(const ResolvedExpr &expr,
                                      bool allowSideEffects) {
  ...

  if (const auto *declRefExpr =
          dynamic_cast&lt;const ResolvedDeclRefExpr *>(&expr))
    return evaluateDeclRefExpr(*declRefExpr, allowSideEffects);

  ...
}</code></pre>
                <p>
                    If a variable is immutable and initialized upon declaration,
                    its value is set by the initializer and doesn't change over
                    time. Because of this, the value of the variable is known in
                    compile time.
                </p>
                <pre><code>std::optional&lt;double> 
ConstantExpressionEvaluator::evaluateDeclRefExpr(const ResolvedDeclRefExpr &dre,
                                                 bool allowSideEffects) {
  const auto *rvd = dynamic_cast&lt;const ResolvedVarDecl *>(dre.decl);
  if (!rvd || rvd->isMutable || !rvd->initializer)
    return std::nullopt;

  return evaluate(*rvd->initializer, allowSideEffects);
}</code></pre>
                <p>
                    The control flow graph can also be extended with the new
                    variable declarations, which extension becomes necessary
                    soon.
                </p>
                <pre><code>int CFGBuilder::insertStmt(const ResolvedStmt &stmt, int block) {
  ...

  if (auto *declStmt = dynamic_cast&lt;const ResolvedDeclStmt *>(&stmt))
    return insertDeclStmt(*declStmt, block);

  ...
}</code></pre>
                <p>
                    Because the CFG is constructed in reverse order, from bottom
                    to top, first the <code>DeclStmt</code> is inserted, then
                    the initializer if there's one.
                </p>
                <pre><code>int CFGBuilder::insertDeclStmt(const ResolvedDeclStmt &stmt, int block) {
  cfg.insertStmt(&stmt, block);

  if (const auto &init = stmt.varDecl->initializer)
    return insertExpr(*init, block);

  return block;
}</code></pre>
                <p>
                    The LLVM IR generation is driven by
                    <code>generateStmt()</code>.
                </p>
                <pre><code>llvm::Value *Codegen::generateStmt(const ResolvedStmt &stmt) {
  ...

  if (auto *declStmt = dynamic_cast&lt;const ResolvedDeclStmt *>(&stmt))
    return generateDeclStmt(*declStmt);

  ...
}</code></pre>
                <p>
                    When a variable is declared, first some space on the stack
                    has to be allocated for it. If it's initialized, the value
                    of the initializer is stored in the variable's stack space.
                    Finally, the stack space of the variable is mapped to its
                    declaration.
                </p>
                <pre><code>llvm::Value *Codegen::generateDeclStmt(const ResolvedDeclStmt &stmt) {
  llvm::Function *function = getCurrentFunction();
  const auto *decl = stmt.varDecl.get();

  llvm::AllocaInst *var = allocateStackVariable(function, decl->identifier);

  if (const auto &init = decl->initializer)
    builder.CreateStore(generateExpr(*init), var);

  declarations[decl] = var;
  return nullptr;
}</code></pre>
                <h2>Assignment</h2>
                <p>
                    Now variables can be created and initialized, but their
                    values cannot be changed even if they are mutable. To
                    address this issue, the language must support assignments
                    too.
                </p>
                <pre><code>&lt;assignment>
  ::= &lt;declRefExpr> '=' &lt;expr></code></pre>
                <p>
                    The grammar is constructed such that assignments are easy to
                    parse and analyze later. Since only declared values can be
                    assigned, the LHS is a <code>DeclRefExpr</code>.
                </p>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        In more complex languages the LHS of an assignment can
                        be an arbitrary expression as even
                        <code>a.b().c.d = 1;</code> can mean a valid assignment.
                        In this case, it's the responsibility of the semantic
                        analyzer to ensure that the LHS is indeed a variable
                        that can be assigned a new value.
                    </p>
                </blockquote>
                <p>
                    This grammar rule doesn't introduce any new tokens, so the
                    lexer doesn't need to be modified before the assignment can
                    be parsed.
                </p>
                <p>
                    The <code>Assignment</code> node encapsulated the
                    <code>DeclRefExpr</code> on the left-hand side and the
                    arbitrary expression on the right-hand side.
                </p>
                <pre><code>struct Assignment : public Stmt {
  std::unique_ptr&lt;DeclRefExpr> variable;
  std::unique_ptr&lt;Expr> expr;

  Assignment(SourceLocation location,
             std::unique_ptr&lt;DeclRefExpr> variable,
             std::unique_ptr&lt;Expr> expr)
      : Stmt(location),
        variable(std::move(variable)),
        expr(std::move(expr)) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    The textual representation of the
                    <code>Assignment</code> includes the assigned variable and
                    the expression whose result is being assigned.
                </p>
                <pre><code>void Assignment::dump(size_t level) const {
  std::cerr << indent(level) << "Assignment:\n";
  variable->dump(level + 1);
  expr->dump(level + 1);
}</code></pre>
                <p>
                    Since both an expression and an assignment can start with a
                    <code>DeclRefExpr</code> on the LHS, a dedicated
                    <code>parseAssignmentOrExpr()</code> method is introduced
                    that helps the parser determine which of the two statements
                    to parse. It is called in <code>parseStmt()</code> when the
                    next token doesn't match any of the conditions.
                </p>
                <pre><code>std::unique_ptr&lt;Stmt> Parser::parseStmt() {
  ...

  return parseAssignmentOrExpr();
}</code></pre>
                <p>
                    This method first parses a prefix expression and if it's not
                    followed by an <code>=</code> token, it treats this prefix
                    expression as the LHS of a more complex expression and
                    proceeds accordingly. When the complex expression is parsed,
                    the <code>;</code> at the end is matched and the AST node is
                    returned.
                </p>
                <pre><code>std::unique_ptr&lt;Stmt> Parser::parseAssignmentOrExpr() {
  varOrReturn(lhs, parsePrefixExpr());

  if (nextToken.kind != TokenKind::Equal) {
    varOrReturn(expr, parseExprRHS(std::move(lhs), 0));

    matchOrReturn(TokenKind::Semi, "expected ';' at the end of expression");
    eatNextToken(); // eat ';'

    return expr;
  }

  ...
}</code></pre>
                <p>
                    If the next token is <code>=</code>, the parsed expression
                    must be the LHS of an assignment, so it is checked to be a
                    <code>DeclRefExpr</code>.
                </p>
                <pre><code>std::unique_ptr&lt;Stmt> Parser::parseAssignmentOrExpr() {
  ...

  auto *dre = dynamic_cast&lt;DeclRefExpr *>(lhs.get());
  if (!dre)
    return report(lhs->location,
                  "expected variable on the LHS of an assignment");

  ...
}</code></pre>
                <p>
                    If the expression is successfully cast to a
                    <code>DeclRefExpr</code>, it's treated as the LHS of an
                    assignment and handed over to
                    <code>parseAssignmentRHS()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;Stmt> Parser::parseAssignmentOrExpr() {
  ...
  std::ignore = lhs.release();

  varOrReturn(assignment,
              parseAssignmentRHS(std::unique_ptr&lt;DeclRefExpr>(dre)));

  ...
}</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        The general pattern to <code>dynamic_cast<></code> a
                        <code>std::unique_ptr</code> without causing a memory
                        leak is to first cast the raw pointer of the managed
                        object, and then transfer the ownership to a new
                        <code>std::unique_ptr</code> of the target type.
                    </p>
                    <p>
                        The initial casting of the raw pointer ensures that the
                        pointed object is of the correct type. If the cast
                        fails, the <code>std::unique_ptr</code> still keeps its
                        ownership over the pointed object.
                    </p>
                    <pre><code>auto *dre = dynamic_cast&lt;DeclRefExpr *>(lhs.get());</code></pre>
                    <p>
                        If the cast succeeds, the ownership of the object must
                        be transferred to a new <code>std::unique_ptr</code> of
                        the target type, which is done by first releasing the
                        object from the old pointer and passing it to the new
                        one.
                    </p>
                    <pre><code>if (dre) {
  lhs.release();
  std::unique_ptr&lt;DeclRefExpr> ptr(dre);
}</code></pre>
                    <p>
                        This way the object is always managed by a
                        <code>std::unique_ptr</code> and is not going to cause a
                        memory leak.
                    </p>
                    <p>
                        The common mistake is to release the ownership of the
                        object before casting.
                    </p>
                    <pre><code>auto *dre = dynamic_cast&lt;DeclRefExpr *>(lhs.release());
std::unique_ptr&lt;DeclRefExpr> ptr(dre);</code></pre>
                    <p>
                        This way the object is released from
                        <code>lhs</code> before the cast is performed and if the
                        cast fails, there is no way to get back the pointer to
                        the object, so the object is lost in memory.
                    </p>
                </blockquote>
                <p>
                    After the parsing of the assignment is successful, the
                    trailing <code>;</code> is matched and the node is returned.
                </p>
                <pre><code>std::unique_ptr&lt;Stmt> Parser::parseAssignmentOrExpr() {
  ...

  matchOrReturn(TokenKind::Semi, "expected ';' at the end of assignment");
  eatNextToken(); // eat ';'

  return assignment;
}</code></pre>
                <p>
                    The <code>parseAssignmentRHS()</code> method is similar to
                    <code>parseExpressionRHS()</code> in that it also takes the
                    LHS as a parameter. It then proceeds by eating the
                    <code>=</code> token, parsing the arbitrary expression on
                    the RHS and returning the assignment node.
                </p>
                <pre><code>std::unique_ptr&lt;Assignment>
Parser::parseAssignmentRHS(std::unique_ptr&lt;DeclRefExpr> lhs) {
  SourceLocation location = nextToken.location;
  eatNextToken(); // eat '='

  varOrReturn(rhs, parseExpr());

  return std::make_unique&lt;Assignment>(location, std::move(lhs), std::move(rhs));
}</code></pre>
                <p>
                    The resolved assignment node captures the resolved LHS and
                    resolved RHS.
                </p>
                <pre><code>struct ResolvedAssignment : public ResolvedStmt {
  std::unique_ptr&lt;ResolvedDeclRefExpr> variable;
  std::unique_ptr&lt;ResolvedExpr> expr;

  ResolvedAssignment(SourceLocation location,
                     std::unique_ptr&lt;ResolvedDeclRefExpr> variable,
                     std::unique_ptr&lt;ResolvedExpr> expr)
      : ResolvedStmt(location),
        variable(std::move(variable)),
        expr(std::move(expr)) {}

  void dump(size_t level = 0) const override;
};</code></pre>
                <p>
                    Its textual representation is identical to its non-resolved
                    counterpart.
                </p>
                <pre><code>void ResolvedAssignment::dump(size_t level) const {
  std::cerr << indent(level) << "ResolvedAssignment:\n";
  variable->dump(level + 1);
  expr->dump(level + 1);
}</code></pre>
                <p>
                    The resolution of the statement is driven by the
                    <code>resolveStmt()</code> method.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedStmt> Sema::resolveStmt(const Stmt &stmt) {
  ...

  if (auto *assignment = dynamic_cast&lt;const Assignment *>(&stmt))
    return resolveAssignment(*assignment);

  ...
}</code></pre>
                <p>First, the LHS and the RHS of the node is resolved.</p>
                <pre><code>std::unique_ptr&lt;ResolvedAssignment>
Sema::resolveAssignment(const Assignment &assignment) {
  varOrReturn(resolvedLHS, resolveDeclRefExpr(*assignment.variable));
  varOrReturn(resolvedRHS, resolveExpr(*assignment.expr));

  ...
}</code></pre>
                <p>
                    It's known that the referenced declaration on the LHS cannot
                    be <code>void</code>, as only function declarations are
                    allowed to have a <code>void</code> type, however, if the
                    LHS is a reference to a function declaration, it couldn't
                    have been resolved. Also, function parameters are immutable,
                    so assigning a value to any of them is an error.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedAssignment>
Sema::resolveAssignment(const Assignment &assignment) {
  ...

  if (dynamic_cast&lt;const ResolvedParamDecl *>(resolvedLHS->decl))
    return report(resolvedLHS->location,
                  "parameters are immutable and cannot be assigned");

  ...
}</code></pre>
                <p>
                    If the LHS is not a parameter, it must be a variable. If the
                    type of the variable doesn't match the type of the assigned
                    value, an error is reported. Otherwise, the RHS is tried to
                    be evaluated as a constant expression and the resolved node
                    is returned.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedAssignment>
  Sema::resolveAssignment(const Assignment &assignment) {
    ...
  
    auto *var = dynamic_cast&lt;const ResolvedVarDecl *>(resolvedLHS->decl);
  
    if (resolvedRHS->type.kind != resolvedLHS->type.kind)
      return report(resolvedRHS->location,
                    "assigned value type doesn't match variable type");
  
    resolvedRHS->setConstantValue(cee.evaluate(*resolvedRHS, false));
  
    return std::make_unique&lt;ResolvedAssignment>(
        assignment.location, std::move(resolvedLHS), std::move(resolvedRHS));
  }</code></pre>
                <p>
                    Assignments need to be introduced to the CFG builder for
                    flow-sensitive analysis to work properly.
                </p>
                <pre><code>int CFGBuilder::insertStmt(const ResolvedStmt &stmt, int block) {
  ...

  if (auto *assignment = dynamic_cast&lt;const ResolvedAssignment *>(&stmt))
    return insertAssignment(*assignment, block);

  ...
}</code></pre>
                <p>
                    Only the <code>Assignment</code> itself and the assigned
                    expression are inserted into the CFG to avoid ambiguities.
                </p>
                <pre><code>int CFGBuilder::insertAssignment(const ResolvedAssignment &stmt, int block) {
  cfg.insertStmt(&stmt, block);
  return insertExpr(*stmt.expr, block);
}</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        Consider the CFG of <code>x = x;</code> if the
                        <code>DeclRefExpr</code> on the LHS is also inserted.
                    </p>
                    <pre><code>ResolvedDeclRefExpr: x
ResolvedDeclRefExpr: x
ResolvedAssignment: ...</code></pre>
                    <p>
                        By traversing the CFG both the LHS and the RHS look the
                        same. This means that in an arbitrary situation, there
                        is no way to know whether a
                        <code>ResolvedDeclRefExpr</code> is reading the value or
                        writing it without checking the next statement. This is
                        also an issue in the Clang CFG, where both sides of an
                        assignment are inserted like this.
                    </p>
                </blockquote>
                <p>
                    As the IR generation of every other statement, the
                    generation of the assignment is also driven by
                    <code>generateStmt()</code>.
                </p>
                <pre><code>llvm::Value *Codegen::generateStmt(const ResolvedStmt &stmt) {
  ...

  if (auto *assignment = dynamic_cast&lt;const ResolvedAssignment *>(&stmt))
    return generateAssignment(*assignment);

  ...
}</code></pre>
                <p>
                    An assignment is simply a store instruction that places the
                    value of the RHS expression into the stack space of the
                    referenced variable.
                </p>
                <pre><code>llvm::Value *Codegen::generateAssignment(const ResolvedAssignment &stmt) {
  return builder.CreateStore(generateExpr(*stmt.expr),
                             declarations[stmt.variable->decl]);
}</code></pre>
                <h2>Lazy Initialization</h2>
                <p>
                    Lazy initialization allows the programmer to declare a
                    variable and initialize it later. This can come in handy if
                    the value of an immutable variable depends on some other
                    variable.
                </p>
                <pre><code>fn calculateAddress(base: number, offset: number, useLegacyMode: number): number {
    let pointerSize: number;

    if useLegacyMode {
        pointerSize = 4;
    } else {
        pointerSize = 8;
    }

    ...
}</code></pre>
                <p>
                    This feature can however quickly lead to error-prone code if
                    the compiler doesn't perform proper analysis to prevent it.
                    For example, the value might not be initialized before it is
                    used.
                </p>
                <pre><code>fn calculateAddress(base: number, offset: number, useLegacyMode: number): number {
    let pointerSize: number;

    if useLegacyMode {
        pointerSize = 4;
    }

    // uninitialized if 'useLegacyMode' is false
    println(pointerSize); 

    ...
}</code></pre>
                <p>
                    Another problem that can happen is the mutation of an
                    immutable variable in a loop.
                </p>
                <pre><code>fn mutateImmutable(): void {
    let lazy: number;
    
    var i = 2;
    while i > 0 {
        // the first iteration initializes,
        // the second mutates the value
        lazy = i;

        i = i - 1;
    }
}</code></pre>
                <p>
                    Intuitively if a variable is not initialized, the first time
                    it appears on the left side of an assignment, it gets
                    initialized, and the second time it gets mutated. Detecting
                    the first and second assignments, however, is not a trivial
                    task as every path of execution needs to be considered.
                </p>
                <pre><code>fn noMutation(): void {
    let lazy: number;
    
    // seemingly infinite loop
    while 1 {
        lazy = 1;

        // exits after the first iteration, no mutation
        return;
    }
}</code></pre>
                <pre><code>fn mutation(condition: number): void {
    let lazy: number;
    
    if condition {
        lazy = 1;
    }
    
    // initialization if the condition is false
    // mutation otherwise
    lazy = 2;
}</code></pre>
                <p>
                    Performing the analysis with regular AST traversal would
                    prove to be difficult, as there are a lot of variables to
                    keep in mind, like if the loop iterates more than once or
                    branches of nested conditions. There is however a technique
                    called data flow analysis, which can easily reason about
                    this problem.
                </p>
                <h2>Data Flow Analysis</h2>
                <p>
                    Data flow analysis is a technique that collects information
                    about how certain values change over the execution of the
                    program without actually executing it.
                </p>
                <p>
                    Its core is the traversal of the control flow graph of a
                    function until the result of the analysis changes. More
                    formally, data flow analysis is a fixpoint iteration over
                    the CFG of a function.
                </p>
                <p>
                    The most important data structure in data flow analysis is
                    the <code>Lattice</code>. A lattice is an ordered data
                    structure, that stores the information about the program in
                    each basic block. In the case of lazy initialization, it is
                    modelled as a mapping of a declaration to its assignment
                    state.
                </p>
                <p>
                    At a certain point in the program, a variable is either
                    <code>Assigned</code>, <code>Unassigned</code>, both of
                    them, or neither of them. A variable can be both assigned
                    and unassigned after an if statement, where only the true
                    branch assigns a value to it. This state is called
                    <code>Top</code> in the mapping. The neither case happens
                    when a variable is not declared or not found in the lattice,
                    so the analyzer has no information about it. This state is
                    called <code>Bottom</code>.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  enum class State { Bottom, Unassigned, Assigned, Top };

  using Lattice = std::map&lt;const ResolvedVarDecl *, State>;
  ...
}</code></pre>
                <p>
                    Notice how the first value in <code>State</code> is
                    <code>Bottom</code>. If a state is not found in the map, one
                    will automatically be default constructed. The default
                    constructor of an enum yields its first value, so
                    <code>Bottom</code> is returned.
                </p>
                <p>
                    At a certain point during the analysis, multiple lattices
                    need to be combined (joined) with each other. In such cases,
                    the states are combined in the following way.
                </p>
                <ul>
                    <li>
                        If both <code>State</code> has the same value, their
                        joined value is the same too. E.g.:
                        <code>join(Assigned, Assigned) -> Assigned</code>
                    </li>
                    <li>
                        If either <code>State</code> is <code>Bottom</code>, the
                        result is the other state. E.g.:
                        <code>join(Bottom, Unassigned) -> Unassigned</code>
                    </li>
                    <li>
                        If one case is <code>Assigned</code> and the other is
                        <code>Unassigned</code>, the result is <code>Top</code>.
                        E.g.: <code>joint(Assigned, Unassigned) -> Top</code>
                    </li>
                    <li>
                        If either of the states is <code>Top</code>, the result
                        is <code>Top</code> too. E.g.:
                        <code>join(Unassigned, Top) -> Top</code>
                    </li>
                </ul>
                <p>
                    As a result, after performing multiple joins over time, the
                    result either stays the same or reaches the
                    <code>Top</code> state and then keeps staying
                    <code>Top</code>. Formally the result reaches a fixpoint
                    over time.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...

  auto joinStates = [](State s1, State s2) {
    if (s1 == s2)
      return s1;

    if (s1 == State::Bottom)
      return s2;

    if (s2 == State::Bottom)
      return s1;

    return State::Top;
  };

  ...
}</code></pre>
                <p>
                    Initially, every CFG block is assigned an empty lattice,
                    which is filled in during the traversal.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...
  std::vector&lt;Lattice> curLattices(cfg.basicBlocks.size());
  ...
}</code></pre>
                <p>
                    Because the analysis iterates over the CFG multiple times,
                    any reported error can appear more than once. To tackle this
                    problem, instead of directly reporting an error, it is first
                    put into a container and gets processed only after the
                    analysis finishes.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...
  std::vector&lt;std::pair&lt;SourceLocation, std::string>> pendingErrors;
  ...
}</code></pre>
                <p>
                    As mentioned before the core of the analysis is a fixpoint
                    iteration over the CFG. At the start of each iteration, the
                    <code>changed</code> flag is set to false and the pending
                    errors are cleared.
                </p>
                <p>
                    Then each basic block is visited starting with the entry
                    block and a new temporary lattice is created for the current
                    block. After the statements of the block have been
                    processed, it's checked if the temporary block is different
                    from the previously known block, stored in
                    <code>curLattices</code>.
                </p>
                <p>
                    If the block changed, the <code>changed</code> flag is set
                    to true, so that one more iteration is performed and the
                    temporary block becomes the new known block.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...

  bool changed = true;
  while (changed) {
    changed = false;
    pendingErrors.clear();

    for (int bb = cfg.entry; bb != cfg.exit; --bb) {
      Lattice tmp;
      
      ...

      if (curLattices[bb] != tmp) {
        curLattices[bb] = tmp;
        changed = true;
      }
    }
  }

  ...
}</code></pre>
                <p>
                    After the creation of the temporary lattice, the lattices of
                    the predecessor blocks are joined together in it. This way
                    the information at the end of each predecessor block is
                    transferred into the temporary lattice.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...
    for (int bb = cfg.entry; bb != cfg.exit; --bb) {
      ...
      
      const auto &[preds, succs, stmts] = cfg.basicBlocks[bb];

      for (auto &amp;&amp;pred : preds)
        for (auto &amp;&amp;[decl, state] : curLattices[pred.first])
          tmp[decl] = joinStates(tmp[decl], state);

      ...
    }
    ...
}</code></pre>
                <p>
                    Once the temporary lattice is prepared, the processing of
                    statements in the current block can begin. Since the CFG was
                    built from bottom to top, the statements need to be visited
                    in reverse order.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...
    for (int bb = cfg.entry; bb != cfg.exit; --bb) {
      ...

      for (auto it = stmts.rbegin(); it != stmts.rend(); ++it) {
        const ResolvedStmt *stmt = *it;

        ...
      }

      ...
    }
  ...
}</code></pre>
                <p>
                    Upon seeing a <code>DeclStmt</code>, the variable is added
                    to the lattice and the state is set to
                    <code>Assigned</code> or <code>Unassigned</code> depending
                    on whether the variable is initialized or not.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...
    for (auto it = stmts.rbegin(); it != stmts.rend(); ++it) {
      ...

      if (const auto *decl = dynamic_cast&lt;const ResolvedDeclStmt *>(stmt)) {
        tmp[decl->varDecl.get()] =
            decl->varDecl->initializer ? State::Assigned : State::Unassigned;
        continue;
      }

      ...
    }
  ...
}</code></pre>
                <p>
                    In the case of an <code>Assignment</code> if the LHS is an
                    immutable variable and the current state is not
                    <code>Unassigned</code>, a pending error is created, as this
                    is the mutation of an immutable value. In every other case,
                    the state of the LHS is set to <code>Assigned</code>.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...
    for (auto it = stmts.rbegin(); it != stmts.rend(); ++it) {
      ...

      if (auto *assignment = dynamic_cast&lt;const ResolvedAssignment *>(stmt)) {
        const auto *var =
            dynamic_cast&lt;const ResolvedVarDecl *>(assignment->variable->decl);

        if (!var->isMutable && tmp[var] != State::Unassigned) {
          std::string msg = '\'' + var->identifier + "' cannot be mutated";
          pendingErrors.emplace_back(assignment->location, std::move(msg));
        }

        tmp[var] = State::Assigned;
        continue;
      }

      ...
    }
  ...
}</code></pre>
                <p>
                    The third and last statement the analyzer cares about is the
                    <code>DeclRefExpr</code>. This statement reads the value of
                    the variable, so if the referenced variable is not in the
                    <code>Assigned</code> state, a pending error is created.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...
      for (auto it = stmts.rbegin(); it != stmts.rend(); ++it) {
        ...
        
        if (const auto *dre = dynamic_cast&lt;const ResolvedDeclRefExpr *>(stmt)) {
          const auto *var = dynamic_cast&lt;const ResolvedVarDecl *>(dre->decl);

          if (var && tmp[var] != State::Assigned) {
            std::string msg = '\'' + var->identifier + "' is not initialized";
            pendingErrors.emplace_back(dre->location, std::move(msg));
          }

          continue;
        }
      }
  ...
}</code></pre>
                <p>
                    Finally when the lattices no longer change, the pending
                    errors are reported and the function returns if it found any
                    errors.
                </p>
                <pre><code>bool Sema::checkVariableInitialization(const ResolvedFunctionDecl &fn,
                                       const CFG &cfg) {
  ...

  for (auto &amp;&amp;[loc, msg] : pendingErrors)
    report(loc, msg);

  return !pendingErrors.empty();
}</code></pre>
                <p>
                    Along with the other flow-sensitive check, this analysis is
                    also invoked in <code>runFlowSensitiveChecks()</code>.
                </p>
                <pre><code>bool Sema::runFlowSensitiveChecks(const ResolvedFunctionDecl &fn) {
  ...
  error |= checkVariableInitialization(fn, cfg);

  ...
};</code></pre>
            </section>
            <footer>
                <p>
                    <small
                        >Hosted on GitHub Pages &mdash; Theme by
                        <a href="https://github.com/orderedlist" target="_blank"
                            >orderedlist</a
                        ></small
                    >
                </p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
        <script src="javascripts/toc.js"></script>
    </body>
</html>
