<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="chrome=1" />
        <title>How to Compile Your Language</title>
        <link rel="icon" href="./favicon.ico" />
        <link rel="stylesheet" href="stylesheets/styles.css" />
        <link rel="stylesheet" href="stylesheets/pygment_trac.css" />
        <meta name="viewport" content="width=device-width" />
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="wrapper">
            <header>
                <ul>
                    <li>
                        <a href="index.html">Prologue </a>
                    </li>
                    <li><a href="lexing.html">Lexing</a></li>
                    <li><a href="parsing.html">Parsing</a></li>
                    <li>
                        <a href="extending-the-parser.html"
                            >Extending the Language</a
                        >
                    </li>
                    <li><a href="sema.html">Semantic Analysis</a></li>
                    <li><a href="codegen.html">Generating LLVM IR</a></li>
                    <li><a href="driver.html">Driver</a></li>
                    <li>
                        <a href="operators.html">Operators</a>
                    </li>
                    <li>
                        <a href="constexpr.html">Constant Expressions</a>
                    </li>
                    <li>
                        <a href="control-flow.html">Control Flow</a>
                    </li>
                    <li>
                        <a href="variables.html">Variables</a>
                    </li>
                    <br />
                    <li>
                        <a href="structs.html">Exercise: Structs</a>
                        <div id="toc"></div>
                    </li>
                </ul>
            </header>
            <section>
                <h1>Extending the Language With Structs</h1>
                <p>
                    This section introduces a self-paced excercise to extend the
                    language with structs. The subsections only describe the
                    requirements and the theoretical background of every step.
                    Figuring out the implementation details of the new features
                    is part of the exercise. Imagine that this is a real world
                    situation of working as a compiler engineer and getting a
                    task to extend the language based on certain criteria.
                </p>
                <!-- FIXME add the link to the GH repo here -->
                <h2>Motivation</h2>
                <p>
                    The motivation behind structs is to pack values together and
                    make it more convenient to simultaneously pass them around,
                    as well as to make the source code more expressive.
                </p>
                <pre><code>fn rgbToGray(r: number, g: number, b: number): number {
  return (r + g + b) / 3;
}</code></pre>
                <p>
                    Maintaining 3 different variables to store each individual
                    color channel value can become overwhelming quickly and also
                    affects readability and maintanability. Expressing the same
                    logic with structs makes it more readable and maintainable.
                </p>
                <pre><code>struct RGBColor {
  r: number,
  g: number,
  b: number,
}

fn rgbToGray(c: RGBColor): number {
  return (c.r + c.g + c.b) / 3;
}</code></pre>
                <h2>Warm-up</h2>
                <p>
                    Whether extending the compiler from the lexer to code
                    generation seems overwhelming at first, or it looks like a
                    walk in the park, doing some small task to get used to
                    working on a codebase is always a good idea.
                </p>
                <p>
                    In the current version the language parameters are passed by
                    value, can only be of
                    <code>number</code> type and are always immutable. With
                    <code>struct</code> parameters however, there can be use
                    cases when only one or two fields of the struct needs to be
                    changed within the function body. With immutable parameters,
                    the only way to achieve this is to duplicate the
                    <code>struct</code> into a local variable and then change
                    the field value of this variable.
                </p>
                <pre><code>fn removeGreenChannel(c: RGBColor): RGBColor {
  var greenRemoved = c;
  greenRemoved.g = 0;

  return greenRemoved;
}</code></pre>
                <!-- FIXME design note about why the struct is passeb by value -->
                <p>
                    Because the <code>struct</code> is passed by value, no
                    modification to it would be visible in the caller anyway, so
                    creating a copy of it doesn't make sense. To resolve this
                    inconvenience, it's time to introduce support for mutable
                    parameters, which are marked with the
                    <code>var</code> keyword, similarly to how it used to be in
                    Swift. Declaring a parameter with the
                    <code>var</code> keyword keeps the language consistent with
                    local variable declarations where <code>var</code> also
                    expresses that mutations to the value are intended.
                </p>
                <!-- FIXME: add a design note on why Swift removed var parameters and why it is not an issue in this language -->
                <pre><code>fn removeGreenChannel(var c: RGBColor): RGBColor {
  c.g = 0;
  return c;
}</code></pre>
                <p>
                    To implement this simple, but useful change proceed with the
                    following few steps.
                </p>
                <ol>
                    <li>
                        <p>
                            Update the parser so that it accepts this
                            <code>paramDecl</code> grammar extension.
                        </p>
                        <pre><code>&lt;paramDecl&gt;
  ::= 'var'? &lt;identifier&gt; ':' &lt;type&gt;
</code></pre>
                        <p>
                            Don't forget to store whether the parameter is
                            mutable or not in the AST similary to
                            <code>VarDecl</code>, as the semantic analyzer needs
                            this information to ensure that only the allowed
                            operations are performed on the value.
                        </p>
                    </li>
                    <li>
                        <p>
                            In the semantic analyzer ensure that the parameter
                            declaration is resolved properly and modifying an
                            immutable parameter still results in an error, but
                            changing a mutable parameters is allowed. The
                            parameter of built-in
                            <code>println</code> should remain immutable.
                        </p>
                        <pre><code>fn paramSema(x: number, var y: number): void {
  y = 0;
  x = 1;
    ^ error: 'x' cannot be mutated
}</code></pre>
                        <p>
                            The mutation of the value is checked in the one and
                            only dataflow analysis pass, which expects the LHS
                            of an assignment to be a
                            <code>ResolvedVarDecl</code>, but this is no longer
                            the case. To make modifying this pass and later the
                            code generation easier, lift the
                            <code>isMutable</code> field up from
                            <code>ResolvedVarDecl</code> to the
                            <code>ResolvedDecl</code> base class.
                        </p>
                        <pre><code>struct ResolvedDecl {
  ...
  bool isMutable;

  ...
};</code></pre>
                        <p>
                            This property should automatically be set to
                            <code>false</code> for every resolved declaration
                            except for variables and parameters, for which it
                            should be deduced from the AST.
                        </p>
                        <p>
                            Note that this change also forwards the mutability
                            of the parameter to <code>Codegen</code>, where it
                            can be used for more efficient LLVM IR generation.
                        </p>
                    </li>
                    <li>
                        <p>
                            During LLVM IR generation, in the function body a
                            local variable is introduced for every parameter,
                            and their values are copied into these variables.
                            When the value of the parameter is read, LLVM loads
                            the corresponding local variable and uses it's value
                            for further computation.
                        </p>
                        <pre><code>define void @varParam(double %n) {
entry:
  %n1 = alloca double, align 8
  store double %n, double* %n1, align 8
  %0 = load double, double* %n1, align 8
  call void @println(double %0)
  ret void
}</code></pre>
                        <p>
                            Notice how the function in the example is called
                            <code>varParam()</code>. This is not a coincidence,
                            because in truth, this local variable only needs to
                            be introduced if the parameter is mutable, as it's
                            only purpose is to make changes to the parameter
                            visible within the function body.
                        </p>
                        <!-- FIXME: add a design note on why this is not default in C++ because of the & operator -->
                        <p>
                            The language is designed such way that the semantic
                            analyzer can ensure that every code modifying an
                            immutable parameter is rejected before code
                            generation. This allows <code>Codegen</code> to take
                            advantage of this information and generate more
                            optimized LLVM IR by omitting the local variable
                            creation for immutable parameters.
                        </p>
                        <pre><code>define void @nonVarParam(double %n) {
entry:
  call void @println(double %n)
  ret void
}</code></pre>
                        <p>
                            Update <code>Codegen</code> so that a local variable
                            is no longer introduced for immutable parameters.
                            Also ensure that when a
                            <code>ResolvedDeclRefExpr</code> points to such a
                            parameter, it's value is no longer loaded. The
                            generated LLVM IR for mutable parameters should
                            remain unchanged.
                        </p>
                    </li>
                </ol>
                <h2>The Struct Syntax</h2>
                <p>
                    The first bigger step towards supporting structs in the
                    language is correctly recognizing their syntax, which means
                    teaching it to the parser. This section describes how the
                    syntax was designed and explains every step to take to end
                    up with the parser correctly recognizing this new sytax.
                </p>
                <ol>
                    <li>
                        <p>
                            Notice how the example in the
                            <code>Motivation</code> sections already spoiled all
                            the new tokens that the lexer must recognize. These
                            are the <code>struct</code> keyword and the
                            <code>.</code> when a field is accessed. Let's
                            update the lexer so that it produces
                            <code>TokenKind::KwStruct</code> and
                            <code>TokenKind::Dot</code>, when it sees them.
                        </p>
                    </li>
                    <li>
                        <p>
                            The introduction of structs changes the top level of
                            the source file from a list of function declarations
                            to a list of function and struct declarations.
                        </p>
                        <pre><code>&lt;sourceFile> 
  ::= (&lt;structDecl> | &lt;functionDecl>)* EOF</code></pre>
                        <p>
                            To be able to see the changes and visualize the AST
                            dump as soon as possible, make sure the parser
                            returns a list of <code>Decl</code> instead of the
                            current list of <code>FunctionDecl</code> as the
                            AST. This makes the <code>-ast-dump</code> flag work
                            and print out the full AST for a better debugging
                            experience.
                        </p>
                        <pre><code>std::pair&lt;std::vector&lt;std::unique_ptr&lt;Decl>>, bool> parseSourceFile();</code></pre>
                        <p>
                            The AST should preserve the declaration order in the
                            source code, so if a struct is declared before a
                            function in the source code, it should also preceed
                            it in the AST.
                        </p>
                        <p>
                            Note that after changing the type of the returned
                            AST in the parser, the driver will not compile
                            because the next step in the compilation pipeline
                            still expects a list of <code>FunctionDecl</code>.
                            To make the compiler still produce an executable
                            from every already supported source code, introduce
                            a temporary adapter in the driver that extracts the
                            function declarations from the AST and only passes
                            those furher down the pipeline. This adapter will be
                            removed at the beginning of the next section.
                        </p>
                    </li>
                    <li>
                        <p>
                            The first new element to recognize is the struct
                            declaration, which as mentioned appears on the top
                            level and only on the top level, so nested struct
                            declarations are not allowed. It starts with the
                            <code>struct</code> keyword followed by a
                            <code>{}</code> enclosed list of zero or many field
                            declaration.
                        </p>
                        <pre><code>struct S { ... }</code></pre>
                        <p>
                            A field declaration is a <code>:</code> separated
                            pair of an identifier and a type. In the body of a
                            struct these declarations are separated by commas
                            with an optional trailing comma at the end.
                        </p>
                        <pre><code>struct S {
  field: type,
  field: type,
  field: type,
}</code></pre>
                        <p>
                            By adding the trailing comma, the
                            <code>struct</code> can also be written on only a
                            single line conveniently.
                        </p>
                        <pre><code>struct S { field: type, field: type, field: type }</code></pre>
                        <p>
                            This syntax leads to the following extension of the
                            grammar.
                        </p>
                        <pre><code>&lt;structDecl>
  ::= 'struct' &lt;identifier> &lt;fieldList>

&lt;fieldList>
  ::= '{' (&lt;fieldDecl> (',' &lt;fieldDecl>)* ','?)? '}'

&lt;fieldDecl>
  ::= &lt;identifier> ':' &lt;type></code></pre>
                        <p>
                            Update the parser so that it recognizes this grammar
                            extension and produces the following AST nodes. Note
                            that the constructors have been omitted from the
                            example, but need to be present in source code.
                        </p>
                        <pre><code>struct FieldDecl : public Decl {
  Type type;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) << "FieldDecl: "
              << identifier << ':' << type.name
              << '\n';
  }
};

struct StructDecl : public Decl {
  std::vector&lt;std::unique_ptr&lt;FieldDecl>> fields;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) << "StructDecl: "
              << identifier << '\n';
  
    for (auto &&field : fields)
      field->dump(level + 1);
  }
};</code></pre>
                    </li>
                    <li>
                        <p>
                            The syntax of instantiating a struct is almost
                            identical to declaring it except for the missing
                            <code>struct</code> keyword in front of the
                            identifier and that in the <code>{}</code> enclosed
                            list of fields, the <code>:</code> is not followed
                            by a type, but an expression that sets the value of
                            that field.
                        </p>
                        <pre><code>S {
  field: expr, 
  field: expr, 
  field: expr,
}</code></pre>
                        <p>
                            The struct instantiation can also be written on a
                            single line conveniently because of the optional
                            trailing comma at the end of the field initializer
                            list.
                        </p>
                        <pre><code>S { field: expr, field: expr, field: expr }</code></pre>
                        <p>
                            Instantiating a struct is considered a primary
                            expression, so the extended grammar looks like this
                            below.
                        </p>
                        <pre><code>&lt;primaryExpression>
  ::= ...
  |   &lt;structInstantiation>
  |   &lt;declRefExpr>
  |   ...

&lt;structInstantiation>
  ::= &lt;identifier> &lt;fieldInitList>

&lt;fieldInitList>
  ::= '{' (&lt;fieldInit> (',' &lt;fieldInit>)* ','?)? '}'

&lt;fieldInit>
  ::= &lt;identifier> ':' &lt;expr></code></pre>
                        <p>
                            Notice how <code>structInstantiation</code> is
                            listed before <code>declRefExpr</code>. Each of
                            these expressions start with an
                            <code>identifier</code>, but a
                            <code>structInstantiation</code> has a priority over
                            a <code>declRefExpr</code>.
                        </p>
                        <p>
                            This ensures that if an expression can be parsed as
                            a struct instantiation, it is always parsed as one,
                            instead of parsing a
                            <code>declRefExpr</code> and erroring out on the
                            <code>{</code> token.
                        </p>
                        <pre><code>Error { ... };
      ^
error: expected ';' at the end of expression</code></pre>
                        <p>
                            Update the parser so that it correctly recognizes
                            the new primary expression and produces the
                            following AST nodes. The constructors are once again
                            omitted.
                        </p>
                    </li>
                    <pre><code>struct FieldInitStmt : public Stmt {
  std::string identifier;
  std::unique_ptr&lt;Expr> initializer;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) 
              << "FieldInitStmt: " << identifier
              << '\n';
    initializer->dump(level + 1);
  }
};

struct StructInstantiationExpr : public Expr {
  std::string identifier;
  std::vector&lt;std::unique_ptr&lt;FieldInitStmt>>
    fieldInitializers;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) 
              << "StructInstantiationExpr: "
              << identifier << '\n';
  
    for (auto &&field : fieldInitializers)
    field->dump(level + 1);
  }
};</code></pre>
                    <li>
                        <p>
                            Notice how this struct instantiation syntax
                            introduces an ambiguity in the condition of an
                            <code>if</code> or <code>while</code> statement.
                        </p>
                        <pre><code>if condition { ... }</code></pre>
                        <p>
                            Because of the grammar modification this would be
                            parsed as an <code>if</code> followed by a
                            <code>structInstantiation</code> with a missing
                            body.
                        </p>
                        <pre><code>  structInstantiation
   ┌───────┴───────┐                          
if condition { ... } ...
                     ^ error: expected 'if' body
</code></pre>
                        <p>
                            To resolve this ambiguity, a
                            <code>structInstantiation</code> is not allowed to
                            be placed inside a condition and the parser should
                            ensure that the above example is always parsed as a
                            <code>declRefExpr</code> followed by a block.
                        </p>
                        <pre><code>IfStmt
  DeclRefExpr: condition
  Block</code></pre>
                        <p>
                            If for any reason a struct needs to be instantiated
                            in a condition, it can be done by wrapping it in a
                            grouping expression, as it can disambiguate the
                            condition.
                        </p>
                        <pre><code>if (identifier {}) {}</code></pre>
                        <p>
                            Implement a logic similar to what can be found in
                            the Rust parser, that makes it possible to apply
                            certain restrictions when an AST node is parsed.
                        </p>
                        <p>
                            When an <code>if</code> or
                            <code>while</code> condition is parsed, apply a
                            restriction that tells the parser to ignore struct
                            instantiations. Upon entering a grouping expression,
                            every restriction that is currently applied, should
                            be cleared until the wrapped expression is consumed.
                        </p>
                        <pre><code>Statement: if (condition {}) {}

|  parseStmt()                  [NoRestrictions]
|    parseIfStmt()
|      parseExpr()              [StructNotAllowed]
|       ...
|         parseGroupingExpr()  
|           parseExpr()         [NoRestrictions]
|             ...
|           parseExpr()
|         parseGroupingExpr()   [StructNotAllowed]
|       ...
|      parseExpr()
|      parseBlock()             [NoRestrictions]
|       ...
</code></pre>
                    </li>
                    <li>
                        <p>
                            After declaring and instantiating structs, the final
                            syntactical extension makes it possible to access
                            their fields.
                        </p>
                        <p>
                            Since a struct can have fields that are also
                            structs, any arbitrarily deep field can be read or
                            written. A struct can also be returned from a
                            function and reading or assigning the fields of the
                            returned struct is also allowed, which means all the
                            following expressions should be accepted.
                        </p>
                        <pre><code>s.f1.f2.f3
foo().f1.f2</code></pre>
                        <p>
                            On the other hand a struct cannot have function
                            fields or methods, so calling an accessed field is
                            not possible.
                        </p>
                        <pre><code>not.possible()</code></pre>
                        <p>
                            The restriction that a call expression, if present,
                            must be the first expression in the chain can be
                            enforced in the parser by modifying
                            <code>postfixExpression</code> the following way.
                        </p>
                        <pre><code>&lt;postfixExpression>
  ::= &lt;primaryExpression> &lt;argumentList>? &lt;memberExpr>*

&lt;memberExpr>
  ::= '.' &lt;identifier></code></pre>
                        <p>
                            Update the parser so that it correctly consumes
                            member expressions and creates the following node
                            for them. Similarly to the previous examples, the
                            construcor has been omitted.
                        </p>
                        <pre><code>struct MemberExpr : public Expr {
  std::unique_ptr&lt;Expr> base;
  std::string member;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) << "MemberExpr: ."
              << member << '\n';
  
    base->dump(level + 1);
  }
};</code></pre>
                    </li>
                    <li>
                        <p>
                            The previous point mentioned that a
                            <code>MemberExpr</code> can also be used to assign a
                            value to a field, however and assignment expression
                            is still restricted so that it only accepts a
                            <code>DeclRefExpr</code> on it's left-hand side,
                            thus getting the following statement rejected.
                        </p>
                        <pre><code>s.f = 1;</code></pre>
                        <p>
                            To make a field assignable while still maintaining a
                            strict restriction on the LHS of the assignment the
                            grammar can be updated the way below.
                        </p>
                        <pre><code>&lt;assignment>
  ::= (&lt;declRefExpr> | &lt;memberExpr>) '=' &lt;expr> ';'</code></pre>
                        <p>
                            To model the grammar change in the AST, introduce an
                            <code>AssignableExpr</code> placeholder node and
                            make it the base class of
                            <code>DeclRefExpr</code> and
                            <code>MemberExpr</code>. The
                            <code>Assignment</code> node should also store this
                            node instead of a <code>DeclRefExpr</code>.
                        </p>
                        <pre><code>struct AssignableExpr : public Expr { ... };

struct DeclRefExpr : public AssignableExpr { ... };

struct MemberExpr : public AssignableExpr { ... };

struct Assignment : public Stmt {
  std::unique_ptr&lt;AssignableExpr> assignee;
  ...
};</code></pre>
                        <p>
                            Update the parser so that it also accepts a
                            <code>MemberExpr</code> on the LHS of an assignment.
                        </p>
                    </li>
                    <li>
                        <p>
                            Update the error recovery mechanism, so that
                            synchronization also happens on the
                            <code>struct</code> keyword. Also update
                            <code>synchronizeOn()</code> to accept a list of
                            tokens instead of a single token only, as on the top
                            level both <code>struct</code> and
                            <code>fn</code> is a synchronization point and
                            synchronization should happen on the keyword that is
                            encountered first.
                        </p>
                        <pre><code>fail struct ... fn ...
┌─────┐ ┌────────┐ ┌─────┐ ┌────┐ ┌─────┐
│ ... │ │ struct │ │ ... │ │ fn │ │ ... │
└─────┘ └────────┘ └─────┘ └────┘ └─────┘
 ^        ^                  ^
 |        └ synchronize here └ don't skip here
 └ fail here</code></pre>
                        <p>
                            If a failure happens inside a struct instantiation,
                            the parser should manually synchronize on the next
                            <code>}</code> token instead of waiting for an
                            automatic synchronization on the block level, as the
                            parser might think the <code>}</code> is the end of
                            the statement, however it is not always true.
                        </p>
                        <pre><code>S { f1: fail, f2: 0 }
┌─────┐ ┌───┐ ┌────┐ ┌───┐ ┌───┐ ┌───┐
│ ... │ │ , │ │ f2 │ │ : │ │ 0 │ │ } │
└─────┘ └───┘ └────┘ └───┘ └───┘ └───┘
 ^                                 ^
 └ fail here                       └ sync here</code></pre>
                    </li>
                </ol>
                <h2>Semantic of Structs</h2>
                <p>
                    Structs are declared on the top level, but they are not
                    location dependent, meaning a struct doesn't have to be
                    declared before it can be used.
                </p>
                <!-- FIXME: design note about forward declarations -->
                <p>
                    This leads to the need to resolve structs similarly to
                    functions, in multiple passes, except that struct
                    declarations also need to be resolved before function
                    declarations because a function can refer to a struct before
                    it is declared.
                </p>
                <pre><code>fn returnS(): S { ... }
              ^ 'S' must be found when resolving the
                function declaration

struct S { ... }</code></pre>
                <!-- FIXME: explain why storing structs be reference requires runtime support and talk about GC and ARC -->
                <p>
                    Structs are stored on the stack, passed to and returned from
                    functions by value. To allocate a struct on the stack, it's
                    size must be known at compile time. Because a struct is a
                    list of values grouped together, it's size is equivalent to
                    the sum of the size of it's members.
                </p>
                <pre><code>struct Color {      Stack:
  r: number,          r: size(number) ┐
  g: number,          g: size(number) ├ (+) size(Color)
  b: number,          b: size(number) ┘
}</code></pre>
                <p>
                    Because of how the size is computed, a struct cannot have a
                    member of itself as in that case to compute the size of the
                    struct, the compiler already has to know it, but to know it,
                    it has to compute it first.
                </p>
                <pre><code>struct S {
  self: S      size(S) = size(self) = size(S) = ...
}</code></pre>
                <p>
                    The semantic analyzer also has to catch the case, when the
                    struct contains itself through one or more nested structs.
                </p>
                <pre><code>struct S { x: S2 }
struct S2 { y: S }

size(S) = size(x) = size(S2) = size(y) = size(S) = ...</code></pre>
                <p>
                    A struct cannot have <code>void</code> fields, or multiple
                    fields with the same name.
                </p>
                <pre><code>struct VoidField {
  f: void,
  ^ error: field cannot be void
}

struct DuplicateField {
  f: number,
  f: number,
  ^ error: error: field 'f' is already declared
}</code></pre>
                <p>
                    Upon instantiating a struct, each field must be initialized
                    but only declared fields can be initialized. Also the same
                    field cannot be initialized more than once.
                </p>
                <pre><code>struct Color {
  r: number,
  g: number,
  b: number,
}

fn main(): void {
  Color {
  ^ error: member 'b' is not initialized
    r: 255,
    r: 255,
    ^ error: field 'r' is already initialized
    g: 255,
    a: 0,
    ^ error: 'Color' has no field named 'a'
  };
}</code></pre>
                <p>
                    A <code>MemberExpr</code> is only allowed to access the
                    existing fields of structs.
                </p>
                <pre><code>fn main(): void {
  let n = 0;
  n.x;
  ^ error: cannot access member of 'number'

  let c = Color { r: 1, g: 2, b: 3 };
  c.y;
   ^ error: 'Color' has no member called 'y'
}</code></pre>
                <p>Proceed with performing the following steps:</p>
                <ol>
                    <li>
                        <p>
                            Extend <code>Type</code> with an additional
                            <code>structType</code>. The <code>kind</code> field
                            should store a new <code>Struct</code> kind and the
                            name field should store the identifier of the
                            struct.
                        </p>
                        <pre><code>static Type structType(const std::string &id) { return {Kind::Struct, id}; }</code></pre>
                        <p>
                            Two struct types are considered equal if their
                            identifiers are equal.
                        </p>
                    </li>
                    <li>
                        <p>
                            Extend the resolved tree with a new node for every
                            new AST node.
                        </p>
                        <p>
                            The <code>ResolvedFieldDecl</code> node represents
                            the resolved version of a <code>FieldDecl</code>.
                            Besides storing the identifier and the type of the
                            field, it should also store it's index within the
                            struct to make code generation easier in the future.
                        </p>
                        <pre><code>ResolvedFieldDecl: @(decl.address) identifier</code></pre>
                        <p>
                            The <code>ResolvedStructDecl</code> is the resolved
                            version of a <code>StructDecl</code>, it stores the
                            resolved field declarations of the struct.
                        </p>
                        <pre><code>ResolvedStructDecl: @(decl.address) identifier:
  ResolvedFieldDecl: @(decl.address) identifier
  ResolvedFieldDecl: @(decl.address) identifier
  ResolvedFieldDecl: @(decl.address) identifier</code></pre>
                        <p>
                            The <code>ResolvedFieldInitStmt</code> should store
                            the initializer expression and a pointer to the
                            declaration of the member being initialized.
                        </p>
                        <pre><code>ResolvedFieldInitStmt: @(field.address) identifier
  &lt;ResolvedExpr></code></pre>
                        <p>
                            The members of the struct are initialized in the
                            order they are declared, so to make code generation
                            simpler, the
                            <code>ResolvedStructInstantiationExpr</code>
                            should store the field initialization statements in
                            the same order.
                        </p>
                        <pre><code>ResolvedStructInstantiationExpr: @(struct.addr)
  ResolvedFieldInitStmt: @(field.address) identifier
    &lt;ResolvedExpr>
  ResolvedFieldInitStmt: @(field.address) identifier
    &lt;ResolvedExpr>
  ResolvedFieldInitStmt: @(field.address) identifier
    &lt;ResolvedExpr></code></pre>
                        <p>
                            The <code>ResolvedMemberExpr</code> node stores a
                            pointer to the accessed member decl and the base
                            expression returning the struct.
                        </p>
                        <pre><code>ResolvedMemberExpr: @(field.address) r
  &lt;ResolvedExpr></code></pre>
                    </li>
                    <li>
                        <p>
                            Introduce a <code>ResolvedAssignableExpr</code> no
                            to represent the
                            <code>AssignableExpr</code> placeholder node and
                            make it the base class of
                            <code>ResolvedDeclRefExpr</code> and
                            <code>ResolvedMemberExpr</code>. The
                            <code>ResolvedAssignment</code> node should also
                            store an <code>ResolvedAssignableExpr</code> instead
                            of a <code>ResolvedDeclRefExpr</code>.
                        </p>
                        <p>
                            Update the semantic analyzer so that it can resolve
                            this new node properly.
                        </p>
                    </li>
                    <li>
                        <p>
                            Resolve every <code>StructDecl</code> before
                            processing the function declarations. A struct can
                            store other structs that are not resolved when seen,
                            because they are declared later in the source code.
                            To avoid errors, at this point only validate that
                            fields are not redeclared and are not of
                            <code>void</code> type.
                        </p>
                        <p>
                            Ensure that in the resolved tree every struct
                            declaration preceedes any function declaration, to
                            make code generation easier.
                        </p>
                    </li>
                    <li>
                        <p>
                            After function declarations are resolved, resolve
                            the body of the struct declarations, and check for
                            structs containing themselves.
                        </p>
                    </li>
                    <li>
                        <p>Resolve struct instantiation and member access.</p>
                    </li>
                    <li>
                        <p>
                            Add the new expressions to the CFG and update it, so
                            that is also stores the LHS of an assignment if it's
                            not a
                            <code>ResolvedDeclRefExpr</code>.
                        </p>
                    </li>
                </ol>
                <h2>Structs in LLVM</h2>
                <p>
                    At this point structs can be parsed and validated by the
                    semantic analyzer. This section introduces how to work with
                    structs in LLVM IR and see all the previous changes put into
                    a platform specific executable.
                </p>
                <ol>
                    <li>
                        <!-- FIXME: use the words 'literal' and 'identified' -->
                        <p>
                            The first step towards seeing the new syntactical
                            changes in action is to represent each resolved
                            struct as a struct type in LLVM IR.
                        </p>
                        <p>
                            LLVM supports two kinds of struct type, named and
                            unnamed. An unnamed struct comes in handy for
                            languages that have built-in support for working
                            with directly packed together values, also known as
                            tuple types, or when implementing optimizations, but
                            more on that later.
                        </p>
                        <pre><code>fn returnTuple(): (number, number) { ... }</code></pre>
                        <p>
                            The snippet above could be represented with the
                            following piece of LLVM IR, where
                            <code>{ double, double }</code> is an unnamed struct
                            of two double members.
                        </p>
                        <pre><code>define { double, double } @returnTuple() { ... }</code></pre>
                        <p>
                            Named structs on the other hand are useful to
                            represent a concrete pack of values, like structs or
                            classes in a language.
                        </p>
                        <pre><code>struct Color { r: number, g: number, b: number }</code></pre>
                        <p>
                            The <code>Color</code> struct in LLVM IR would be
                            written the way below.
                        </p>
                        <pre><code>%struct.Color = type { double, double, double }</code></pre>
                        <p>
                            It's important to note that while unnamed struct are
                            structurally uniqued, so every
                            <code>{ double, double }</code> in the IR refers to
                            the same type, named structs are always different,
                            so even if the IR contains
                            <code>%struct.a = type { double, double }</code> and
                            <code>%struct.b = type { double, double }</code>,
                            <code>%struct.a</code> is not the same type as
                            <code>%struct.b</code>.
                        </p>
                        <p>
                            A struct type can also be opaque, which tells LLVM
                            that this struct exists, but it doesn't describe
                            what members it has, similarly to a forward
                            declaration in C.
                        </p>
                        <p>
                            In this step every
                            <code>ResolvedStructDecl</code> should be
                            represented with an opaque identified
                            <code>llvm::StructType</code>. Every time a struct
                            type is referenced, it's generated type should be
                            used, don't generate a new
                            <code>llvm::StructType</code> multiple times for the
                            same struct.
                        </p>
                        <p>
                            For example, declaring a <code>Color</code> variable
                            would look like this.
                        </p>
                        <pre><code>%struct.Color = type { double, double, double }

define void @allocateColor() {
entry:
  %c = alloca %struct.Color, align 8
  ret void
}</code></pre>
                        <p>
                            Similarly to what happens in the semantic analyzer,
                            first a type for every struct declaration needs to
                            be generated, because they can be referenced by
                            other structs or function declarations. This should
                            be straightforward as the resolved tree is
                            guaranteed to list every
                            <code>ResolvedStructDecl</code> before any other
                            declaration.
                        </p>
                    </li>
                    <li>
                        <p>
                            After every struct declaration has been given it's
                            own type in the IR, connect the fields of the struct
                            to a valid type declaration.
                        </p>
                        <p>
                            This step should turn the currently opaque structs
                            into complete struct types with every field type
                            correctly specified.
                        </p>
                        <pre><code>%struct.S = type opaque
%struct.S2 = type opaque</code></pre>
                        <p>
                            The above structs will turn into ones similar to
                            these below.
                        </p>
                        <pre><code>%struct.S = type { %struct.S2 }
%struct.S2 = type { double, double }</code></pre>
                    </li>
                    <li>
                        <p>
                            With struct types being supported, it's possible to
                            generate code for struct instantiations. In LLVM
                            they way to instantiate structs is to allocate them
                            first and then initialize each member separately.
                        </p>
                        <pre><code>Color { r: 1, g: 2, b: 3 }</code></pre>
                        <p>
                            As it can be seen, a struct instantiation expression
                            doesn't allocate a struct automatically, so it has
                            to be done manually. Then the fields of this
                            manually allocated struct will be initialized to the
                            specified values.
                        </p>
                        <p>
                            The above expression in LLVM IR would result in the
                            following logic. Note that in source code the
                            following snippet is invalid, it is only for
                            illustration purposes.
                        </p>
                        <pre><code>let tmp: Color;
tmp.r = 1;
tmp.g = 2;
tmp.b = 3;</code></pre>
                        <p>
                            Allocating a new variable is straightforward, the
                            resultin IR will look like this.
                        </p>
                        <pre><code>%Color.tmp = alloca %struct.Color, align 8</code></pre>
                        <p>
                            Accessing a field of a variable however was not
                            necessary until now. In LLVM IR, the field of a
                            struct is accessed by it's index and not by it's
                            name. This is the reason for also storing the index
                            of the field in a <code>ResolvedMemberExpr</code>.
                        </p>
                        <!-- FIXME: link to the offcial guide that explains GEP -->
                        <p>
                            The field is accessed with the
                            <code>GetElementPointer</code> instruction. This
                            instruction can be confusing, so the recommended way
                            is to let the
                            <code>llvm::IRBuilder::CreateStructGEP()</code>
                            helper create it. This helper takes the type of the
                            struct, a pointer to the beginning of the struct and
                            the index of the element that needs to be accessed.
                        </p>
                        <p>
                            Initializing <code>tmp.r</code> means calculating
                            the pointer to the <code>r</code> field and
                            assigning the initial value to it.
                        </p>
                        <pre><code>%0 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 0
store double 1.000000e+00, double* %0, align 8</code></pre>
                        <p>
                            The full LLVM IR for instantiating the
                            <code>Color</code> struct at the beginning of this
                            point looks like this.
                        </p>
                        <pre><code>%Color.tmp = alloca %struct.Color, align 8
%0 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 0
store double 1.000000e+00, double* %0, align 8
%1 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 1
store double 2.000000e+00, double* %1, align 8
%2 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 2
store double 3.000000e+00, double* %2, align 8</code></pre>
                        <p>
                            Note that the example struct deliberately has only
                            <code>number</code> fields. Assigning values to
                            struct fields works differently and will be
                            discussed later.
                        </p>
                    </li>
                    <li>
                        <p>
                            In the previous points fields of structs have
                            already been accessed, so it's the perfect time to
                            implement code generation support for
                            <code>ResolvedMemberExpr</code>.
                        </p>
                        <p>
                            To read the field of a struct, at some point code
                            for a <code>ResolvedDeclRefExpr</code> that
                            references the struct needs to be generated. While
                            numbers are loaded into a register, when referenced,
                            struct behave like immutable function parameters and
                            they are never loaded into registers, so it must be
                            unsured that a
                            <code>ResolvedDeclRefExpr</code> referencing a
                            struct always results in a pointer to that struct
                            without being followed by a load instruction.
                        </p>
                        <p>
                            A member access results in a
                            <code>GetElementPointer</code> instruction on the
                            pointer returned from generating code for it's base
                            expression, however there is a difference in how
                            it's followed up depending on whether the field is
                            being written or read.
                        </p>
                        <p>
                            When the value of a numberic field is being read, it
                            has to be loaded from memory.
                        </p>
                        <pre><code>%3 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 0
%4 = load double, double* %3, align 8</code></pre>
                        <p>
                            On the other hand, if the field is being assigned
                            the <code>store</code> instruction expects a pointer
                            operand, so the field doesn't have to be loaded.
                        </p>
                        <pre><code>%3 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 0
store double 1.000000e+00, double* %3, align 8</code></pre>
                    </li>
                    <li>
                        <p>
                            At this point creating temporary structs and reading
                            their fields immediately should work correctly, but
                            it would be convenient to also be able to store the
                            structs in variables, initialize struct fields or
                            assign a struct variable a different value.
                        </p>
                        <p>
                            All of the above use cases are handled by the same
                            logic. The difference between structs and numbers is
                            that they are not loaded into registers, so the
                            <code>load</code> and
                            <code>store</code> instructions don't work for them.
                            Any time a struct is assigned, the value of each
                            field must be manually assigned to the same field of
                            the destination struct.
                        </p>
                        <pre><code>let s = Color { r: 1, g: 2, b: 3 };</code></pre>
                        <p>
                            Based on this logic and what's already implemented,
                            the above snippet is equivalent to the following
                            piece of code.
                        </p>
                        <!-- FIXME: talk about copy elision here and memcpy-ing constant structs -->
                        <pre><code>let tmp: Color;
tmp.r = 1;
tmp.g = 2;
tmp.b = 3;

let s: Color;
s.r = tmp.r;
s.g = tmp.g;
s.b = tmp.b;</code></pre>
                        <!-- FIXME: talk about what an intrinsic is -->
                        <p>
                            Manually assigning every field however would result
                            in duplicating the work and generating large LLVM IR
                            code. The goal is to make the content of the piece
                            of memory that houses <code>s</code> the same as the
                            content of the memory housing <code>tmp</code>. For
                            this use case, LLVM has a builtin
                            <code>memcpy</code> intrinsic, that copies a
                            specific amount of memory from one place to another.
                            With that an assignment between 2 struct variables
                            can be simplified to a few lines only.
                        </p>
                        <pre><code>%3 = bitcast %struct.Color* %s to i8*
%4 = bitcast %struct.Color* %Color.tmp to i8*
call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 %4, i64 24, i1 false)</code></pre>
                        <p>
                            This is the version of <code>memcpy</code> created
                            by the
                            <code>llvm::IRBuilder::CreateMemCpy()</code> helper.
                            To use this helper, the alignment and the size of
                            the struct must be calculted first, which can be
                            done easily with the help of the
                            <code>llvm::DataLayout</code> utility.
                        </p>
                    </li>
                    <!-- FIXME: explain why immutable parameters don't need to be copied, but why they are in C++ (constness can be cast away) -->
                    <li>
                        <p>
                            By this point structs should be fully functional
                            within the body of a function. The last thing to do
                            is to implement support for passing them to and
                            returning them from functions.
                        </p>
                        <p>
                            Structs are passed to functions by value, however as
                            mentioned previously in LLVM IR only the pointer to
                            the struct can be moved around. Passing by value
                            means that no modification to the parameter is
                            visible outside the function, and this can be
                            achived in LLVM IR.
                        </p>
                        <p>
                            For mutable parameters the trick is to create a copy
                            of the struct in the caller and pass a pointer to
                            that copy.
                        </p>
                        <pre><code>%c = alloca %struct.Color, align 8
%struct.arg.tmp = alloca %struct.Color, align 8
...
%5 = bitcast %struct.Color* %struct.arg.tmp to i8*
%6 = bitcast %struct.Color* %c to i8*
call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %6, i64 24, i1 false)
call void @mutableStructParam(%struct.Color* byval(%struct.Color) %struct.arg.tmp)</code></pre>
                        <p>
                            Notice how the <code>byval</code> attribute is added
                            to the function. It is a way to let LLVM know that
                            the particular parameter actually simulates a
                            pass-by-value semantic and when it does, this
                            attribute must be present at both the function
                            declaration and the callsite.
                        </p>
                        <pre><code>define void @mutableStructParam(%struct.Color* byval(%struct.Color) %c) {
  ...
}

call void @mutableStructParam(%struct.Color* byval(%struct.Color) %struct.arg.tmp)</code></pre>
                        <p>
                            When the parameter is immutable, there is no need to
                            copy the struct, as there are no modifications that
                            can visible in the caller. To indicate that the
                            struct will never be modified inside the function
                            through the pointer, the
                            <code>readonly</code> attribute can be used. This
                            attribute is not compulsory though and can be
                            omitted.
                        </p>
                        <pre><code>%c = alloca %struct.Color, align 8
...
call void @immutableStructParam(%struct.Color* readonly %c)</code></pre>
                        <p>
                            Returning the struct is also done through a
                            dedicated parameter. If the function returns a
                            struct by value, a temporary variable that stores
                            the return value is allocated in the caller and the
                            pointer to this value is passed as the first
                            parameter of the function marked by the
                            <code>sret</code> attribute. The function is
                            otherwise treated as if it was a void function.
                        </p>
                        <pre><code>define void @caller() {
entry:
  %struct.ret.tmp = alloca %struct.Color, align 8
  call void @returnStruct(%struct.Color* sret(%struct.Color) %struct.ret.tmp)
  ret void
}

define void @returnStruct(%struct.Color* sret(%struct.Color) %ret) {
entry:
  %Color.tmp = alloca %struct.Color, align 8
  ...
  %3 = bitcast %struct.Color* %ret to i8*
  %4 = bitcast %struct.Color* %Color.tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 %4, i64 24, i1 false)
  br label %return

return: 
  ret void
}</code></pre>
                    </li>
                </ol>
                <p>
                    Congratulations! If every step was implemented correctly,
                    any arbitrary source code that works with structs can be
                    compiled and run correctly.
                </p>
            </section>
            <footer>
                <p>
                    <small
                        >Hosted on GitHub Pages &mdash; Theme by
                        <a href="https://github.com/orderedlist" target="_blank"
                            >orderedlist</a
                        ></small
                    >
                </p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
        <script src="javascripts/toc.js"></script>
    </body>
</html>
