<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="chrome=1" />
        <title>How to Compile Your Language</title>
        <link rel="icon" href="./favicon.ico" />
        <link rel="stylesheet" href="stylesheets/styles.css" />
        <link rel="stylesheet" href="stylesheets/pygment_trac.css" />
        <meta name="viewport" content="width=device-width" />
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="wrapper">
            <header>
                <ul>
                    <li>
                        <a href="index.html">Prologue </a>
                    </li>
                    <li><a href="lexing.html">Lexing</a></li>
                    <li><a href="parsing.html">Parsing</a></li>
                    <li>
                        <a href="extending-the-parser.html"
                            >Extending the Language</a
                        >
                    </li>
                    <li><a href="sema.html">Semantic Analysis</a></li>
                    <li><a href="codegen.html">Generating LLVM IR</a></li>
                    <li><a href="driver.html">Driver</a></li>
                    <li>
                        <a href="operators.html">Operators</a>
                    </li>
                    <li>
                        <a href="constexpr.html">Constant Expressions</a>
                    </li>
                    <li>
                        <a href="control-flow.html">Control Flow</a>
                    </li>
                    <li>
                        <a href="variables.html">Variables</a>
                    </li>
                    <br />
                    <li>
                        <a href="structs.html">Exercise: Structs</a>
                        <div id="toc"></div>
                    </li>
                </ul>
            </header>
            <section>
                <h1>Extending the Language With Structs</h1>
                <p>
                    This section introduces a semi-guided excercise to extend
                    the language with structs. The subsections only describe the
                    requirements that need to be done, implementation details
                    are left to be figured out by the reader. Imagine that this
                    is a real world situation of working as a compiler engineer
                    and getting a task to extend the language based on certain
                    criteria.
                </p>
                <h2>Motivation</h2>
                <p>
                    The motivation behind structs is to pack values together, so
                    that multiple values can be passed around easily.
                </p>
                <pre><code>fn rgbToGray(r: number, g: number, b: number): number {
    return (r + g + b) / 3;
}</code></pre>
                <p>
                    Maintaining 3 different variables to store each individual
                    color value can become overwhelming quickly and also affects
                    readability and maintanability. With stucts the same
                    snippets looks more descriptive and maintainable.
                </p>
                <pre><code>struct RGBColor {
    r: number,
    g: number,
    b: number,
}

fn rgbToGray(c: RGBColor): number {
    return (c.r + c.g + c.b) / 3;
}</code></pre>
                <h2>Warm-up</h2>
                <p>
                    Whether modifying the compiler from the lexer to code
                    generation seems overwhelming at first, or it looks like a
                    walk in the park, getting familiar with working on the
                    codebase is never a bad idea.
                </p>
                <p>
                    Right now parameters are passed by value, can only be of
                    <code>number</code> type and are immutable. With
                    <code>struct</code> parameters however it might be desired
                    to change the value of only a single field of the parameter
                    before processing it. Due to the parameter being immutable,
                    currently this is only possible if the
                    <code>struct</code> is copied first.
                </p>
                <pre><code>fn removeGreenChannel(c: RGBColor): RGBColor {
    var greenRemoved = c;
    greenRemoved.g = 0;

    return greenRemoved;
}</code></pre>
                <p>
                    In this case there is no reason to copy the
                    <code>struct</code> as it is passed by value, so no
                    modification to it is visible in the caller. To address
                    this, the parameter needs to be made mutable, which will be
                    indicated by the <code>var</code> keyword in front of it,
                    similarly to how it used to be in Swift. Just as
                    <code>var</code> before a local variable means the variable
                    is mutable, before a parameter it means the parameter is
                    also mutable.
                </p>
                <!-- FIXME: add a design note on why Swift removed var parameters and why it is not an issue in this language -->
                <pre><code>fn removeGreenChannel(var c: RGBColor): RGBColor {
    c.g = 0;
    return c;
}</code></pre>
                <p>
                    To implement this simple change, proceed with these few
                    steps:
                </p>
                <ol>
                    <li>
                        <p>
                            Update the parser so that it accepts the following
                            new grammar of <code>paramDecl</code>.
                        </p>
                        <pre><code>&lt;paramDecl&gt;
    ::= 'var'? &lt;identifier&gt; ':' &lt;type&gt;
</code></pre>
                        <p>
                            Don't forget to store whether the parameter is
                            mutable or not in the AST, or the semantic analyzer
                            won't be able to reason about it.
                        </p>
                    </li>
                    <li>
                        <p>
                            Ensure that assigning to an immutable parameter
                            still results in an error in the semantic analyzer,
                            but assigning to mutable parameters is allowed. The
                            mutability of the parameter should also be passed to
                            the code generator through the
                            <code>ResolvedParamDecl</code> node.
                        </p>
                    </li>
                    <li>
                        <p>
                            Currently the code generator handles parameters by
                            first creating a local variable for each of them
                            inside the function body and copying their value
                            into this variable. When the value of the parameter
                            needs to be read, LLVM is instructed to load the
                            local variable and proceed with using the loaded
                            value.
                        </p>
                        <pre><code>define void @functionVarParam(double %n) {
entry:
  %n1 = alloca double, align 8
  store double %n, double* %n1, align 8
  %0 = load double, double* %n1, align 8
  call void @println(double %0)
  ret void
}</code></pre>
                        <!-- FIXME: add a design note on why this cannot be achieved in C++ with const params by casting away constness -->
                        <p>
                            The truth is that this local variable only needs to
                            be introduced if the parameter is mutable, as this
                            variable serves as the storage for the mutated
                            value. If the parameter cannot be mutated, it's
                            value can be read directly.
                        </p>
                        <pre><code>define void @functionNotVarParam(double %n) {
entry:
  call void @println(double %n)
  ret void
}</code></pre>
                        <p>
                            Update the <code>Codegen</code> class so that the
                            mutability of the parameter affects the generated
                            code and immutable parameters no longer have a local
                            variable introduced for them. The generated LLVM IR
                            for mutable parameters should remain unchanged.
                        </p>
                    </li>
                </ol>
                <p>
                    By properly implementing the few short changes described
                    above, both mutable and immutable function parameters are
                    supported in the language and any mutation to a function
                    parameter remains invisible to the caller of the function.
                </p>
                <h2>Accepting the New Syntax</h2>
                <p>
                    A struct declaration can only appear on the top level, so
                    nested struct declarations are not allowed. Each such
                    declaration constains a list of field declarations separated
                    by commas. A trailing comma is allowed at the end.
                </p>
                <p>
                    A field declaration is the name and the type of the field
                    separated by a <code>:</code>.
                </p>
                <pre><code>struct S {
    field: type,
    field: type,
    field: type,
}</code></pre>
                <p>
                    By making the comma at the end optional, the
                    <code>struct</code> can also be written on only a single
                    line conveniently.
                </p>
                <pre><code>struct S { field: type, field: type, field: type }</code></pre>
                <p>
                    This syntax would require the parser to recognize the
                    grammar below.
                </p>
                <pre><code>&lt;sourceFile> 
    ::= (&lt;structDecl> | &lt;functionDecl>)* EOF

&lt;structDecl>
    ::= 'struct' &lt;identifier> &lt;fieldList>

&lt;fieldList>
    ::= '{' (&lt;fieldDecl> (',' &lt;fieldDecl>)* ','?)? '}'</code></pre>
                <p>
                    Instantiating the structs happends using the same syntax,
                    except for dropping the <code>struct</code> keyword from the
                    beginning and by pairing the fields with expressions that
                    give values to them.
                </p>
                <pre><code>S {
  field: expr, 
  field: expr, 
  field: expr,
};</code></pre>
                <p>
                    A struct instantiation expression is added to the language
                    as a primary expression, so the resulting grammar is the
                    following.
                </p>
                <pre><code>&lt;primaryExpr>
    ::= ...
    |   &lt;structInstantiation>
    |   &lt;declRefExpr>

&lt;structInstantiation>
    ::= &lt;identifier> &lt;fieldInitList>

&lt;fieldInitList>
    ::= '{' (&lt;fieldInit> (',' &lt;fieldInit>)* ','?)? '}'

&lt;memberInit>
    ::= &lt;identifier> ':' &lt;expr></code></pre>
                <p>
                    Notice how <code>structInstantiation</code> is listed before
                    <code>declRefExpr</code>. Each of these expressions start
                    with an <code>identifier</code>, but a
                    <code>structInstantiation</code> has a priority over a
                    <code>declRefExpr</code>. This ensures that if an expression
                    can be parsed as a struct instantiation, it is parsed that
                    way instead of just parsing the name of the struct as a
                    reference declaration and erroring out on the
                    <code>{</code> token.
                </p>
                <pre><code>Error { ... };
      ^
error: expected ';' at the end of expression</code></pre>
                <p>
                    Also notice how this struct instantiation syntax introduces
                    an ambiguity when placed in the condition of an
                    <code>if</code> or <code>while</code> statement.
                </p>
                <pre><code>if Ambiguous {} {}</code></pre>
                <p>
                    This can either be parsed as the condition is a reference to
                    a variable called <code>Ambiguous</code> followed by an
                    emtpy block, or as the condition is an instantiated struct
                    followed by an empty block.
                </p>
                <pre><code>IfStmt
  DeclRefExpr: Ambiguous
  Block
error: expected expression

IfStmt
  StructInstantiationExpr: Ambiguous
    ...
  Block
</code></pre>
                <p>
                    To resolve this ambiguity a
                    <code>structInstantiation</code> is not allowed inside a
                    condition and the parser should ensure that the statement is
                    always parsed the first way, that results in an error.
                </p>
                <p>
                    After declaring and instantiating structs, there must be a
                    way to read their members, that gives the last syntactical
                    extension of the language.
                </p>
                <p>
                    Since a struct can have fields that are also structs, any
                    arbitrarily deep members can be accessed, or assigned. A
                    struct can also be returned from a function and accessing or
                    assigning the members of the returned struct is also
                    allowed, which means all of the expressions below are valid.
                </p>
                <pre><code>s.f1.f2.f3 = v
foo().f1.f2 = v</code></pre>
                <p>
                    On the other hand a struct can't have methods, so calling an
                    accessed field is not allowed.
                </p>
                <pre><code>not.allowed()</code></pre>
                <p>
                    This limitation can be handled in the parser by modifying
                    <code>postfixExpression</code> the following way.
                </p>
                <pre><code>&lt;postfixExpression>
    ::= &lt;primaryExpression> &lt;argumentList>? ('.' &lt;identifier>)*</code></pre>
            </section>
            <footer>
                <p>
                    <small
                        >Hosted on GitHub Pages &mdash; Theme by
                        <a href="https://github.com/orderedlist" target="_blank"
                            >orderedlist</a
                        ></small
                    >
                </p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
        <script src="javascripts/toc.js"></script>
    </body>
</html>
