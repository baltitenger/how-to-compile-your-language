<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="chrome=1" />
        <title>How to Compile Your Language</title>
        <link rel="icon" href="./favicon.ico" />
        <link rel="stylesheet" href="stylesheets/styles.css" />
        <link rel="stylesheet" href="stylesheets/pygment_trac.css" />
        <meta name="viewport" content="width=device-width" />
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="wrapper">
            <header>
                <ul>
                    <li>
                        <a href="index.html">Prologue </a>
                    </li>
                    <li><a href="lexing.html">Lexing</a></li>
                    <li><a href="parsing.html">Parsing</a></li>
                    <li>
                        <a href="extending-the-parser.html"
                            >Extending the Language</a
                        >
                    </li>
                    <li><a href="sema.html">Semantic Analysis</a></li>
                    <li><a href="codegen.html">Generating LLVM IR</a></li>
                    <li><a href="driver.html">Driver</a></li>
                    <li>
                        <a href="operators.html">Operators</a>
                    </li>
                    <li>
                        <a href="constexpr.html">Constant Expressions</a>
                    </li>
                    <li>
                        <a href="control-flow.html">Control Flow</a>
                    </li>
                    <li>
                        <a href="variables.html">Variables</a>
                    </li>
                    <br />
                    <li>
                        <a href="structs.html">Exercise: Structs</a>
                        <div id="toc"></div>
                    </li>
                </ul>
            </header>
            <section>
                <h1>Extending the Language With Structs</h1>
                <p>
                    This section introduces a self-paced excercise to extend the
                    language with structs. The subsections only describe the
                    requirements and the theoretical background of every step.
                    Figuring out the implementation details of the new features
                    is part of the exercise. Imagine that this is a real world
                    situation of working as a compiler engineer and getting a
                    task to extend the language based on certain criteria.
                </p>
                <!-- FIXME add the link to the GH repo here -->
                <h2>Motivation</h2>
                <p>
                    The motivation behind structs is to pack values together and
                    make it more convenient to simultaneously pass them around,
                    as well as to make the source code more expressive.
                </p>
                <pre><code>fn rgbToGray(r: number, g: number, b: number): number {
  return (r + g + b) / 3;
}</code></pre>
                <p>
                    Maintaining 3 different variables to store each individual
                    color channel value can become overwhelming quickly and also
                    affects readability and maintanability. Expressing the same
                    logic with structs makes it more readable and maintainable.
                </p>
                <pre><code>struct RGBColor {
  r: number,
  g: number,
  b: number,
}

fn rgbToGray(c: RGBColor): number {
  return (c.r + c.g + c.b) / 3;
}</code></pre>
                <h2>Warm-up</h2>
                <p>
                    Whether extending the compiler from the lexer to code
                    generation seems overwhelming at first, or it looks like a
                    walk in the park, doing some small task to get used to
                    working on a codebase is always a good idea.
                </p>
                <p>
                    In the current version of the language parameters are passed
                    by value, can only be of
                    <code>number</code> type and are always immutable. With
                    <code>struct</code> parameters however, there can be use
                    cases when only one or two fields of the struct needs to be
                    changed within the function body. With immutable parameters,
                    the only way to achieve this is to duplicate the
                    <code>struct</code> into a local variable and then change
                    the field value of this variable.
                </p>
                <pre><code>fn removeGreenChannel(c: RGBColor): RGBColor {
  var greenRemoved = c;
  greenRemoved.g = 0;

  return greenRemoved;
}</code></pre>
                <!-- FIXME design note about why the struct is passeb by value -->
                <p>
                    Because the <code>struct</code> is passed by value, no
                    modification to it would be visible in the caller anyway, so
                    creating a copy of it doesn't make sense. To resolve this
                    inconvenience, it's time to introduce support for mutable
                    parameters, which are marked with the
                    <code>var</code> keyword, similarly to how it used to be in
                    Swift. Declaring a parameter with the
                    <code>var</code> keyword keeps the language consistent with
                    local variable declarations where <code>var</code> also
                    expresses that mutations to the value are intended.
                </p>
                <!-- FIXME: add a design note on why Swift removed var parameters and why it is not an issue in this language -->
                <pre><code>fn removeGreenChannel(var c: RGBColor): RGBColor {
  c.g = 0;
  return c;
}</code></pre>
                <p>
                    To implement this simple, but useful change proceed with the
                    following few steps.
                </p>
                <ol>
                    <li>
                        <p>
                            Update the parser so that it accepts this
                            <code>paramDecl</code> grammar extension.
                        </p>
                        <pre><code>&lt;paramDecl&gt;
  ::= 'var'? &lt;identifier&gt; ':' &lt;type&gt;
</code></pre>
                        <p>
                            Don't forget to store whether the parameter is
                            mutable or not in the AST similarly to
                            <code>VarDecl</code>, as the semantic analyzer needs
                            this information to ensure that only the allowed
                            operations are performed on the value.
                        </p>
                    </li>
                    <li>
                        <p>
                            In the semantic analyzer ensure that the parameter
                            declaration is resolved properly and modifying an
                            immutable parameter still results in an error, but
                            changing a mutable parameters is allowed. The
                            parameter of built-in
                            <code>println</code> should remain immutable.
                        </p>
                        <pre><code>fn paramSema(x: number, var y: number): void {
  y = 0;
  x = 1;
    ^ error: 'x' cannot be mutated
}</code></pre>
                        <p>
                            The mutation of the value is checked in the one and
                            only dataflow analysis pass, which expects the LHS
                            of an assignment to be a
                            <code>ResolvedVarDecl</code>, but this is no longer
                            the case. To make modifying this pass and later make
                            the code generation easier, lift the
                            <code>isMutable</code> field up from
                            <code>ResolvedVarDecl</code> to the
                            <code>ResolvedDecl</code> base class.
                        </p>
                        <pre><code>struct ResolvedDecl {
  ...
  bool isMutable;

  ...
};</code></pre>
                        <p>
                            This property should automatically be set to
                            <code>false</code> for every resolved declaration
                            except for variables and parameters, for which it
                            should be deduced from the AST. Note that this
                            change also forwards the mutability of the parameter
                            to <code>Codegen</code>, where it can be used for
                            more efficient LLVM IR generation.
                        </p>
                        <p>
                            Also don't forget to update the dataflow analysis
                            pass, so that lattices also store
                            <code>ResolvedDecl</code> instead of
                            <code>ResolvedVarDecl</code>.
                        </p>
                        <pre><code>using Lattice = std::map&lt;const ResolvedDecl *, State>;</code></pre>
                    </li>
                    <li>
                        <p>
                            During LLVM IR generation, in the function body a
                            local variable is introduced for every parameter,
                            and their values are copied into these variables.
                            When the value of the parameter is read, LLVM loads
                            the corresponding local variable and uses its value
                            for further computation.
                        </p>
                        <pre><code>define void @varParam(double %n) {
entry:
  %n1 = alloca double, align 8
  store double %n, double* %n1, align 8
  %0 = load double, double* %n1, align 8
  call void @println(double %0)
  ret void
}</code></pre>
                        <p>
                            Notice how the function in the example is called
                            <code>varParam()</code>. This is not a coincidence,
                            because in truth, this local variable only needs to
                            be introduced if the parameter is mutable, as its
                            only purpose is to make changes to the parameter
                            visible within the function body.
                        </p>
                        <!-- FIXME: add a design note on why this is not default in C++ because of the & operator -->
                        <p>
                            The language is designed such way that the semantic
                            analyzer can ensure that every code modifying an
                            immutable parameter is rejected before code
                            generation. This allows <code>Codegen</code> to take
                            advantage of this information and generate more
                            optimized LLVM IR by omitting the local variable
                            creation for immutable parameters.
                        </p>
                        <pre><code>define void @nonVarParam(double %n) {
entry:
  call void @println(double %n)
  ret void
}</code></pre>
                        <p>
                            Update <code>Codegen</code> so that a local variable
                            is no longer introduced for immutable parameters.
                            Also ensure that when a
                            <code>ResolvedDeclRefExpr</code> points to such a
                            parameter, its value is no longer loaded. The
                            generated LLVM IR for mutable parameters should
                            remain unchanged.
                        </p>
                    </li>
                </ol>
                <h2>The Struct Syntax</h2>
                <p>
                    The first bigger step towards supporting structs in the
                    language is correctly recognizing their syntax, which means
                    teaching it to the parser. This section describes how the
                    syntax was designed and explains every step to take to end
                    up with the parser correctly recognizing this new sytax.
                </p>
                <ol>
                    <li>
                        <p>
                            Notice how the example in the
                            <code>Motivation</code> sections already spoiled all
                            the new tokens that the lexer must recognize. These
                            are the <code>struct</code> keyword and the
                            <code>.</code> when a field is accessed. Let's
                            update the lexer so that it produces
                            <code>TokenKind::KwStruct</code> and
                            <code>TokenKind::Dot</code>, when it sees them.
                        </p>
                    </li>
                    <li>
                        <p>
                            The introduction of structs changes the top level of
                            the source file from a list of function declarations
                            to a list of function and struct declarations.
                        </p>
                        <pre><code>&lt;sourceFile> 
  ::= (&lt;structDecl> | &lt;functionDecl>)* EOF</code></pre>
                        <p>
                            To be able to see the changes and visualize the AST
                            dump as soon as possible, make sure the parser
                            returns a list of <code>Decl</code> instead of the
                            current list of <code>FunctionDecl</code> as the
                            AST. This makes the <code>-ast-dump</code> flag work
                            and print out the full AST for a better debugging
                            experience.
                        </p>
                        <pre><code>std::pair&lt;std::vector&lt;std::unique_ptr&lt;Decl>>, bool> parseSourceFile();</code></pre>
                        <p>
                            The AST should preserve the declaration order in the
                            source code, so if a struct is declared before a
                            function in the source code, it should also preceed
                            it in the AST.
                        </p>
                        <p>
                            Note that after changing the type of the returned
                            AST in the parser, the driver will not compile
                            because the next step in the compilation pipeline
                            still expects a list of <code>FunctionDecl</code>.
                            To make the compiler still produce an executable
                            from every already supported source code, introduce
                            a temporary adapter in the driver that extracts the
                            function declarations from the AST and only passes
                            those furher down the pipeline. This adapter will be
                            removed at the beginning of the next section.
                        </p>
                    </li>
                    <li>
                        <p>
                            The first new element to recognize is the struct
                            declaration, which as mentioned appears on the top
                            level and only on the top level, so nested struct
                            declarations are not allowed. It starts with the
                            <code>struct</code> keyword followed by a
                            <code>{}</code> enclosed list of zero or many field
                            declaration.
                        </p>
                        <pre><code>struct S { ... }</code></pre>
                        <p>
                            A field declaration is a <code>:</code> separated
                            pair of an identifier and a type. In the body of a
                            struct these declarations are separated by commas
                            with an optional trailing comma at the end.
                        </p>
                        <pre><code>struct S {
  field: type,
  field: type,
  field: type,
}</code></pre>
                        <p>
                            By adding the trailing comma, the
                            <code>struct</code> can also be written on only a
                            single line conveniently.
                        </p>
                        <pre><code>struct S { field: type, field: type, field: type }</code></pre>
                        <p>
                            This syntax leads to the following extension of the
                            grammar.
                        </p>
                        <pre><code>&lt;structDecl>
  ::= 'struct' &lt;identifier> &lt;fieldList>

&lt;fieldList>
  ::= '{' (&lt;fieldDecl> (',' &lt;fieldDecl>)* ','?)? '}'

&lt;fieldDecl>
  ::= &lt;identifier> ':' &lt;type></code></pre>
                        <p>
                            Update the parser so that it recognizes this grammar
                            extension and produces the following AST nodes. Note
                            that the constructors have been omitted from the
                            example, but need to be present in source code.
                        </p>
                        <pre><code>struct FieldDecl : public Decl {
  Type type;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) << "FieldDecl: "
              << identifier << ':' << type.name
              << '\n';
  }
};

struct StructDecl : public Decl {
  std::vector&lt;std::unique_ptr&lt;FieldDecl>> fields;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) << "StructDecl: "
              << identifier << '\n';
  
    for (auto &&field : fields)
      field->dump(level + 1);
  }
};</code></pre>
                    </li>
                    <li>
                        <p>
                            The syntax of instantiating a struct is almost
                            identical to declaring it except for the missing
                            <code>struct</code> keyword in front of the
                            identifier and that in the <code>{}</code> enclosed
                            list of fields, the <code>:</code> is not followed
                            by a type, but an expression that sets the value of
                            that field.
                        </p>
                        <pre><code>S {
  field: expr, 
  field: expr, 
  field: expr,
}</code></pre>
                        <p>
                            The struct instantiation can also be written on a
                            single line conveniently because of the optional
                            trailing comma at the end of the field initializer
                            list.
                        </p>
                        <pre><code>S { field: expr, field: expr, field: expr }</code></pre>
                        <p>
                            Instantiating a struct is considered a primary
                            expression, so the extended grammar looks like this
                            below.
                        </p>
                        <pre><code>&lt;primaryExpression>
  ::= ...
  |   &lt;structInstantiation>
  |   &lt;declRefExpr>
  |   ...

&lt;structInstantiation>
  ::= &lt;identifier> &lt;fieldInitList>

&lt;fieldInitList>
  ::= '{' (&lt;fieldInit> (',' &lt;fieldInit>)* ','?)? '}'

&lt;fieldInit>
  ::= &lt;identifier> ':' &lt;expr></code></pre>
                        <p>
                            Notice how <code>structInstantiation</code> is
                            listed before <code>declRefExpr</code>. Each of
                            these expressions start with an
                            <code>identifier</code>, but a
                            <code>structInstantiation</code> has a priority over
                            a <code>declRefExpr</code>.
                        </p>
                        <p>
                            This ensures that if an expression can be parsed as
                            a struct instantiation, it is always parsed as one,
                            instead of parsing a
                            <code>declRefExpr</code> and erroring out on the
                            <code>{</code> token.
                        </p>
                        <pre><code>Error { ... };
      ^
error: expected ';' at the end of expression</code></pre>
                        <p>
                            Update the parser so that it correctly recognizes
                            the new primary expression and produces the
                            following AST nodes. The constructors are once again
                            omitted.
                        </p>
                    </li>
                    <pre><code>struct FieldInitStmt : public Stmt {
  std::string identifier;
  std::unique_ptr&lt;Expr> initializer;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) 
              << "FieldInitStmt: " << identifier
              << '\n';
    initializer->dump(level + 1);
  }
};

struct StructInstantiationExpr : public Expr {
  std::string identifier;
  std::vector&lt;std::unique_ptr&lt;FieldInitStmt>>
    fieldInitializers;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) 
              << "StructInstantiationExpr: "
              << identifier << '\n';
  
    for (auto &&field : fieldInitializers)
    field->dump(level + 1);
  }
};</code></pre>
                    <li>
                        <p>
                            Notice how this struct instantiation syntax
                            introduces an ambiguity in the condition of an
                            <code>if</code> or <code>while</code> statement.
                        </p>
                        <pre><code>if condition { ... }</code></pre>
                        <p>
                            Because of the grammar modification this would be
                            parsed as an <code>if</code> followed by a
                            <code>structInstantiation</code> with a missing
                            body.
                        </p>
                        <pre><code>  structInstantiation
   ┌───────┴───────┐                          
if condition { ... } ...
                     ^ error: expected 'if' body
</code></pre>
                        <p>
                            To resolve this ambiguity, a
                            <code>structInstantiation</code> is not allowed to
                            be placed inside a condition and the parser should
                            ensure that the above example is always parsed as a
                            <code>declRefExpr</code> followed by a block.
                        </p>
                        <pre><code>IfStmt
  DeclRefExpr: condition
  Block</code></pre>
                        <p>
                            If for any reason a struct needs to be instantiated
                            in a condition, it can be done by wrapping it in a
                            grouping expression, as it can disambiguate the
                            condition.
                        </p>
                        <pre><code>if (identifier {}) {}</code></pre>
                        <p>
                            Implement a logic similar to what can be found in
                            the Rust parser, that makes it possible to apply
                            certain restrictions when an AST node is parsed.
                        </p>
                        <p>
                            When an <code>if</code> or
                            <code>while</code> condition is parsed, apply a
                            restriction that tells the parser to ignore struct
                            instantiations. Upon entering a grouping expression,
                            every restriction that is currently applied, should
                            be cleared until the wrapped expression is consumed.
                        </p>
                        <pre><code>Statement: if (condition {}) {}

|  parseStmt()                  [NoRestrictions]
|    parseIfStmt()
|      parseExpr()              [StructNotAllowed]
|       ...
|         parseGroupingExpr()  
|           parseExpr()         [NoRestrictions]
|             ...
|           parseExpr()
|         parseGroupingExpr()   [StructNotAllowed]
|       ...
|      parseExpr()
|      parseBlock()             [NoRestrictions]
|       ...
</code></pre>
                    </li>
                    <li>
                        <p>
                            After declaring and instantiating structs, the final
                            syntactical extension makes it possible to access
                            their fields.
                        </p>
                        <p>
                            Since a struct can have fields that are also
                            structs, any arbitrarily deep field can be read or
                            written. A struct can also be returned from a
                            function and reading or assigning the fields of the
                            returned struct is also allowed, which means all the
                            following expressions should be accepted.
                        </p>
                        <pre><code>s.f1.f2.f3
foo().f1.f2</code></pre>
                        <p>
                            On the other hand a struct cannot have function
                            fields or methods, so calling an accessed field is
                            not possible.
                        </p>
                        <pre><code>not.possible()</code></pre>
                        <p>
                            The restriction that a call expression, if present,
                            must be the first expression in the chain can be
                            enforced in the parser by modifying
                            <code>postfixExpression</code> the following way.
                        </p>
                        <pre><code>&lt;postfixExpression>
  ::= &lt;primaryExpression> &lt;argumentList>? &lt;memberExpr>*

&lt;memberExpr>
  ::= '.' &lt;identifier></code></pre>
                        <p>
                            Update the parser so that it correctly consumes
                            member expressions and creates the following node
                            for them. Similarly to the previous examples, the
                            construcor has been omitted.
                        </p>
                        <pre><code>struct MemberExpr : public Expr {
  std::unique_ptr&lt;Expr> base;
  std::string member;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) << "MemberExpr: ."
              << member << '\n';
  
    base->dump(level + 1);
  }
};</code></pre>
                    </li>
                    <li>
                        <p>
                            The previous point mentioned that a
                            <code>MemberExpr</code> can also be used to assign a
                            value to a field, however and assignment expression
                            is still restricted so that it only accepts a
                            <code>DeclRefExpr</code> on its left-hand side, thus
                            getting the following statement rejected.
                        </p>
                        <pre><code>s.f = 1;</code></pre>
                        <p>
                            To make a field assignable while still maintaining a
                            strict restriction on the LHS of the assignment the
                            grammar can be updated the way below.
                        </p>
                        <pre><code>&lt;assignment>
  ::= (&lt;declRefExpr> | &lt;memberExpr>) '=' &lt;expr> ';'</code></pre>
                        <p>
                            To model the grammar change in the AST, introduce an
                            <code>AssignableExpr</code> placeholder node and
                            make it the base class of
                            <code>DeclRefExpr</code> and
                            <code>MemberExpr</code>. The
                            <code>Assignment</code> node should also store this
                            node instead of a <code>DeclRefExpr</code>.
                        </p>
                        <pre><code>struct AssignableExpr : public Expr { ... };

struct DeclRefExpr : public AssignableExpr { ... };

struct MemberExpr : public AssignableExpr { ... };

struct Assignment : public Stmt {
  std::unique_ptr&lt;AssignableExpr> assignee;
  ...
};</code></pre>
                        <p>
                            Update the parser so that it also accepts a
                            <code>MemberExpr</code> on the LHS of an assignment.
                        </p>
                    </li>
                    <li>
                        <p>
                            Update the error recovery mechanism, so that
                            synchronization also happens on the
                            <code>struct</code> keyword. Also update
                            <code>synchronizeOn()</code> to accept a list of
                            tokens instead of a single token only, as on the top
                            level both <code>struct</code> and
                            <code>fn</code> is a synchronization point and
                            synchronization should happen on the keyword that is
                            encountered first.
                        </p>
                        <pre><code>fail struct ... fn ...
┌─────┐ ┌────────┐ ┌─────┐ ┌────┐ ┌─────┐
│ ... │ │ struct │ │ ... │ │ fn │ │ ... │
└─────┘ └────────┘ └─────┘ └────┘ └─────┘
 ^        ^                  ^
 |        └ synchronize here └ don't skip here
 └ fail here</code></pre>
                        <p>
                            If a failure happens inside a struct instantiation,
                            the parser should manually synchronize on the next
                            <code>}</code> token instead of waiting for an
                            automatic synchronization on the block level, as the
                            parser might think the <code>}</code> is the end of
                            the statement, however it is not always true.
                        </p>
                        <pre><code>S { f1: fail, f2: 0 }
┌─────┐ ┌───┐ ┌────┐ ┌───┐ ┌───┐ ┌───┐
│ ... │ │ , │ │ f2 │ │ : │ │ 0 │ │ } │
└─────┘ └───┘ └────┘ └───┘ └───┘ └───┘
 ^                                 ^
 └ fail here                       └ sync here</code></pre>
                    </li>
                </ol>
                <h2>Semantic of Structs</h2>
                <p>
                    After structs are recognized by the compiler, the next step
                    is to ensure that they are used correctly. This section
                    explains how to extend the semantic analyzer, to detect the
                    invalid use of structs and ensure there are no issues in the
                    user code.
                </p>
                <ol>
                    <li>
                        <p>
                            The parser now returns a list of
                            <code>Decl</code> as the AST, which is passed to the
                            semantic analyzer through an adapter in the driver.
                        </p>
                        <p>
                            Remove this adapter from the driver and update
                            <code>Sema</code> so that it takes a list of
                            <code>Decl</code> and returns a list of
                            <code>ResolvedDecl</code> as the new resolved tree.
                        </p>
                        <pre><code>class Sema {
  ...

public:
  explicit Sema(std::vector&lt;std::unique_ptr&lt;Decl>> ast)
      : ast(std::move(ast)) {}

  std::vector&lt;std::unique_ptr&lt;ResolvedDecl>> resolveAST();
};</code></pre>
                        <p>
                            Ensure that the <code>-cfg-dump</code> flag still
                            works as expected. Only functions can have a control
                            flow graph, so the driver should only run
                            <code>CFGBuilder</code> on a
                            <code>ResolvedFunctionDecl</code>.
                        </p>
                        <p>
                            Also <code>Codegen</code> still expects a list of
                            <code>ResolvedFunctionDecl</code> as the resolved
                            tree. To keep it working, introduce another
                            temporary adapter similar to the just removed one
                            between <code>Sema</code> and <code>Codegen</code>.
                        </p>
                    </li>
                    <li>
                        <p>
                            Extend <code>Type</code> with an additional
                            <code>structType</code>. The <code>kind</code> field
                            should store a new <code>Struct</code> kind and the
                            <code>name</code> field should store the identifier
                            of the struct.
                        </p>
                        <pre><code>static Type structType(const std::string &id) { return {Kind::Struct, id}; }</code></pre>
                        <p>
                            Two struct types are considered equal if their
                            identifiers are equal. Ensure in the semantic
                            analyzer that types are compared by their
                            <code>name</code> field instead of their
                            <code>kind</code> field.
                        </p>
                    </li>
                    <li>
                        <p>
                            Structs are declared on the top level and are
                            location independent, which means that a struct
                            doesn't have to be declared before it can be used.
                            Due to this property, struct are also resolved in
                            multiple passes just like functions.
                        </p>
                        <!-- FIXME: design note about forward declarations -->
                        <p>
                            They also need to be resolved before function
                            declarations because a function can have a struct
                            parameter, or it can return a struct and in these
                            cases the compiler needs to make sure that the
                            struct is declared in the source code.
                        </p>
                        <pre><code>fn returnS(): S { ... }
              ^ 'S' must be found when resolving 
                the function declaration

struct S { ... }</code></pre>
                        <p>
                            Implement the first pass of struct resolution in the
                            semantic analyzer that results in the following
                            resolved nodes.
                        </p>
                        <pre><code>struct ResolvedFieldDecl : public ResolvedDecl {
  unsigned index;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) 
              << "ResolvedFieldDecl: @(" 
              << this << ") " << identifier 
              << '\n';
  }
};

struct ResolvedStructDecl : public ResolvedDecl {
  std::vector&lt;std::unique_ptr&lt;ResolvedFieldDecl>> 
    fields;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) 
              << "ResolvedStructDecl: @(" 
              << this << ") " << identifier 
              << ':' << '\n';
  
    for (auto &&field : fields)
      field->dump(level + 1);
  }
};</code></pre>
                        <p>
                            This pass should only check if each field
                            declaration is unique and insert the structs to the
                            symbol table. Don't resolve the type of the field
                            declarations yet.
                        </p>
                        <pre><code>struct S { 
    f: number,
    f: number,
    ^ error: field 'f' is already declared
}</code></pre>
                        <p>
                            To make code generation easier ensure that in the
                            resolved tree every
                            <code>ResolvedStructDecl</code> preceeds any
                            <code>ResolvedFunctionDecl</code>. In other words,
                            the resolved tree should have the following
                            structure.
                        </p>
                        <pre><code>ResolvedStructDecl
       ...
ResolvedStructDecl
ResolvedFunctionDecl
       ...
ResolvedFunctionDecl</code></pre>
                    </li>
                    <li>
                        <p>
                            To resolve a <code>Type::Kind::Custom</code> type to
                            a <code>Type::Kind::Struct</code> type, the semantic
                            analyzer needs to check whether the identifier of
                            the custom type references a known
                            <code>ResolvedStructDecl</code>.
                        </p>
                        <p>
                            The current lookup logic only supports lookup based
                            on the identifier of the <code>ResolvedDecl</code>,
                            which can result in the wrong declaration being
                            looked up.
                        </p>
                        <pre><code>let S = 1;
let x: S;
       ^ here it needs to checked if this is an
         existing struct, but looking up the decl
         returns the variable above </code></pre>
                        <p>
                            Update the symbol lookup logic, so that type of the
                            searched declaration can also be specified and
                            instead of returning the first declaration with the
                            same name, it returns the first declaration with the
                            same name and the same type.
                        </p>
                        <pre><code>template &lt;typename T>
std::pair&lt;T *, int> Sema::lookupDecl(const std::string id) { ... }</code></pre>
                        <p>
                            Use the updated lookup logic to resolve a
                            <code>Type::Kind::Custom</code>. This change should
                            ensure that the following snippet is compiled
                            properly.
                        </p>
                        <pre><code>struct S {}

fn main(): void {
    let S = 1;
    let x: S;
           ^ struct

    println(S);
            ^ local variable
}</code></pre>
                    </li>
                    <li>
                        <p>
                            With the modified declaration lookup logic, the
                            bodies of the struct declarations can also be
                            resolved. The second pass of
                            <code>StructDecl</code> resolution should happen
                            after the first pass of function resolution.
                        </p>
                        <!-- FIXME: explain why storing structs by reference requires runtime support and talk about GC and ARC -->
                        <p>
                            Structs are stored on the stack, passed to and
                            returned from functions by value. To allocate a
                            struct, its size must be known at compile time.
                            Because a struct is a list of values grouped
                            together, its size is equivalent to the sum of the
                            sizes of its fields.
                        </p>
                        <pre><code>struct Color {      Stack:
  r: number,          r: size(number) ┐
  g: number,          g: size(number) ├ (+) size(Color)
  b: number,          b: size(number) ┘
}</code></pre>
                        <p>
                            A struct cannot have a field of itself as in that
                            case to compute the size of the struct, the compiler
                            has to know it already, but to know it, it has to
                            compute it first.
                        </p>
                        <pre><code>struct S {
  self: S      size(S) = size(self) = size(S) = ...
}</code></pre>
                        <p>
                            The semantic analyzer also has to catch the case,
                            when the struct contains itself through one or more
                            nested structs.
                        </p>
                        <pre><code>struct S { x: S2 }
struct S2 { y: S }

size(S) = size(x) = size(S2) = size(y) = size(S) = ...</code></pre>
                        <p>
                            A struct cannot have <code>void</code> fields
                            either, as there is no way to create a value of
                            <code>void</code> type.
                        </p>
                        <pre><code>struct VoidField {
  f: void,
  ^ error: field cannot be void
}</code></pre>
                        <p>
                            Implement a logic that resolves the fields of the
                            structs, detects <code>void</code> fields and self
                            containing structs.
                        </p>
                        <pre><code>struct S { s2: S2 }
^ error: struct 'S' contains itself

struct S2 { s3: S3 }
^ error: struct 'S2' contains itself

struct S3 { s: S }
^ error: struct 'S3' contains itself</code></pre>
                        <p>
                            If a field type cannot be resolved, it should raise
                            an error.
                        </p>
                        <pre><code>struct S { 
  e: Error
  ^ error: unable to resolve 'Error' type of field
}</code></pre>
                    </li>
                    <li>
                        <p>
                            A <code>StructInstantiationExpr</code> as its name
                            suggests, is only allowed to instantiate a
                            <code>struct</code>. Instantiating anything else
                            should result in an error.
                        </p>
                        <pre><code>let S = 1;
S { ... };
^ error: 'S' is not a struct type

Undefined { ... };
^ error: 'Undefined' is not a struct type</code></pre>
                        <p>
                            Upon instantiating a struct, every field must be
                            initialized and only declared fields can be
                            initialized. Also the same field cannot be
                            initialized more than once.
                        </p>
                        <pre><code>struct Color {
  r: number,
  g: number,
  b: number,
}

fn main(): void {
  Color {
  ^ error: member 'b' is not initialized
    r: 255,
    r: 255,
    ^ error: field 'r' is already initialized
    g: 255,
    a: 0,
    ^ error: 'Color' has no field named 'a'
  };
}</code></pre>
                        <p>
                            The type of the initializer must match the type of
                            the field.
                        </p>
                        <pre><code>struct Wrapper { c: Color }

fn main(): void {
  Wrapper {
  ^ error: member 'c' is not initialized
    c: 0
       ^ error: 'number' cannot be used to 
         initialize a field of type 'Color'
  };
}</code></pre>
                        <p>
                            Last but not least, a
                            <code>ResolvedStructDecl</code> cannot be referenced
                            on its own. In such cases it's safe to assume, the
                            developer forgot to instantiate it.
                        </p>
                        <pre><code>let s = Color;
        ^ error: expected an instance of 'Color'</code></pre>
                        <p>
                            Update the semantic analyzer so that all of the
                            mentioned use cases are recognized and their
                            correctness is checked. The resolved nodes to
                            produce with their constructors omitted can be found
                            below.
                        </p>
                        <pre><code>struct ResolvedFieldInitStmt : public ResolvedStmt {
  const ResolvedFieldDecl *field;
  std::unique_ptr&lt;ResolvedExpr> initializer;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) 
              << "ResolvedFieldInitStmt: @(" 
              << field << ") " << field->identifier
              << '\n';
  
    initializer->dump(level + 1);
  }
};

struct ResolvedStructInstantiationExpr : public ResolvedExpr {
  const ResolvedStructDecl *structDecl;
  std::vector&lt;std::unique_ptr&lt;ResolvedFieldInitStmt>> 
    fieldInitializers;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) 
              << "ResolvedStructInstantiationExpr: @("
              << structDecl << ')' << '\n';
  
    for (auto &&fieldInit : fieldInitializers)
      fieldInit->dump(level + 1);
  }
};</code></pre>
                        <p>
                            The order of the field initializers should be the
                            same as they are written in the source code. Also
                            don't forget to run the constant expression
                            evaluator on the initializer expression.
                        </p>
                    </li>
                    <li>
                        <p>
                            The semantic of a <code>MemberExpr</code> is
                            straightforward. It is only allowed to access the
                            existing fields of a struct.
                        </p>
                        <pre><code>fn main(): void {
  let n = 0;
  n.x;
  ^ error: cannot access field of 'number'

  let c = Color { r: 1, g: 2, b: 3 };
  c.y;
   ^ error: 'Color' has no field called 'y'
}</code></pre>
                        <p>
                            To make the semantic analyzer fully support the new
                            AST nodes, make sure this expression is also
                            resolved to the node below.
                        </p>
                        <pre><code>struct ResolvedMemberExpr : public ResolvedAssignableExpr {
  std::unique_ptr&lt;ResolvedExpr> base;
  const ResolvedMemberDecl *member;

  ...

  void dump(size_t level = 0) const override {
    std::cerr << indent(level) 
              << "ResolvedMemberExpr: @(" 
              << member << ") " 
              << member->identifier << '\n';
  
    base->dump(level + 1);
  }
};</code></pre>
                    </li>
                    <li>
                        <p>
                            In the AST there is a restriction on the kind of
                            expressions that can be found on the LHS of an
                            assignment. Propagate this same restriction to the
                            resolved tree by using the corresponding resolved
                            tree nodes and updating <code>Sema</code>, so that
                            these nodes are produced correctly.
                        </p>
                        <pre><code>struct ResolvedAssignableExpr : public ResolvedExpr { ... };

struct ResolvedDeclRefExpr : public ResolvedAssignableExpr { ... };

struct ResolvedMemberExpr : public ResolvedAssignableExpr { ... };

struct ResolvedAssignment : public ResolvedStmt {
  std::unique_ptr&lt;ResolvedAssignableExpr> assignee;
  ...
};</code></pre>
                        <p>
                            Because <code>ResolvedMemberExpr</code> can appear
                            on the LHS of an assignment, the statement can now
                            have side-effects on both sides. To set an order of
                            evaluation, the RHS of the assignment is calculated
                            before the LHS. Make sure this is also reflected in
                            the resolution process. Resolve the RHS before the
                            LHS.
                        </p>
                        <p>
                            The <code>ResolvedMemberExpr</code> on the LHS
                            should also be part of the CFG, but only this node,
                            the <code>ResolvedDeclRefExpr</code> still shouldn't
                            be added. The member expression can be applied to
                            any primary expression, so make sure to add the
                            <code>ResolvedStructInstantiationExpr</code> to the
                            CFG too.
                        </p>
                        <pre><code>fn foo(): void {
  S{ x: 2 }.x = 1;
  
  let n: number;
  n = 3;
}

foo:
[2 (entry)]
  preds: 
  succs: 1 

[1]
  preds: 2 
  succs: 0 
  ResolvedNumberLiteral: 1
  ResolvedNumberLiteral: 2
  ResolvedStructInstantiationExpr: S{ x: 2 }
  ResolvedMemberExpr: S{ x: 2 }.x
  ResolvedAssignment: S{ x: 2 }.x = 1
  ResolvedDeclStmt: n
  ResolvedNumberLiteral: 3
  ResolvedAssignment: n = 3

[0 (exit)]
  preds: 1 
  succs:</code></pre>
                        <p>
                            During variable initialization analysis, a struct is
                            only considered initialized, if all of its members
                            have been initialized in the same statement.
                            Memberwise initialization is not supported.
                        </p>
                        <pre><code>fn structInitAnalysis(): void {
  let initialized = S { x: 1 };
  initialized.x;

  let lateInit: S;
  lateInit = S { x: 1 };
  lateInit.x;

  let uninit: S;
  uninit.x = 1;
  ^ error: 'uninit' is not initialized
}</code></pre>
                        <p>
                            The mutability of a field is defined by the
                            mutability of the base declaration. Temporary
                            structs are always mutable.
                        </p>
                        <pre><code>fn structMutability(): void {
  S { x: 1 }.x = 1;

  var mutable = S { x: 1 };
  mutable.x = 2;

  let immutable = S { x: 1 };
  immutable.x = 1;
              ^ error: 'immutable' cannot be mutated
}</code></pre>
                    </li>
                </ol>
                <h2>Structs in LLVM</h2>
                <p>
                    At this point structs can be parsed and validated by the
                    semantic analyzer. This section introduces how to work with
                    structs in LLVM IR and see all the previous changes put into
                    a platform specific executable.
                </p>
                <ol>
                    <li>
                        <p>
                            Before getting started with code generation make
                            sure to update <code>Codegen</code> to accept a list
                            of <code>ResolvedDecl</code> as the resolved tree
                            instead of the current list of
                            <code>ResolvedFunctionDecl</code> and remove the
                            temporary adapter from the driver that was
                            introduced in the previous section.
                        </p>
                    </li>
                    <li>
                        <!-- FIXME: use the words 'literal' and 'identified' -->
                        <p>
                            The first step towards seeing the new syntactical
                            changes in action is to represent each resolved
                            struct as a struct type in LLVM IR.
                        </p>
                        <p>
                            LLVM supports two kinds of structs, named and
                            unnamed ones. An unnamed struct comes in handy for
                            languages that have built-in support for working
                            with tuple types, or when implementing
                            optimizations, but more on that later.
                        </p>
                        <pre><code>fn returnTuple(): (number, number) { ... }</code></pre>
                        <p>
                            The snippet above could be represented with the
                            following piece of LLVM IR, where
                            <code>{ double, double }</code> is an unnamed struct
                            of two <code>double</code> members.
                        </p>
                        <pre><code>define { double, double } @returnTuple() { ... }</code></pre>
                        <p>
                            Named structs on the other hand are useful to
                            represent a concrete pack of values, like user
                            defined structs or classes in a language.
                        </p>
                        <pre><code>struct Color { r: number, g: number, b: number }</code></pre>
                        <p>
                            The <code>Color</code> struct in LLVM IR would be
                            written like the one below.
                        </p>
                        <pre><code>%struct.Color = type { double, double, double }</code></pre>
                        <p>
                            It's important to note that while unnamed structs
                            are structurally uniqued, meaning that every
                            <code>{ double, double }</code> in the IR refers to
                            the same type, named structs are always different,
                            so even if the IR contains
                            <code>%struct.a = type { double, double }</code> and
                            <code>%struct.b = type { double, double }</code>,
                            <code>%struct.a</code> is not the same type as
                            <code>%struct.b</code>.
                        </p>
                        <p>
                            A struct type can also be opaque, which tells LLVM
                            that the struct exists, but it is not known what
                            fields it has, like a forward declaration in C or
                            C++.
                        </p>
                        <p>
                            In this step every
                            <code>ResolvedStructDecl</code> should be
                            represented with an opaque identified
                            <code>llvm::StructType</code>. Every time a struct
                            type is referenced, it's this struct type that
                            should be returned, don't generate a new
                            <code>llvm::StructType</code> multiple times for the
                            same struct.
                        </p>
                        <pre><code>%struct.Color = type { double, double, double }

define void @allocateColor() {
entry:
  %c = alloca %struct.Color, align 8
  ret void
}</code></pre>
                        <p>
                            Similarly to what happens in the semantic analyzer,
                            first a type for every struct declaration needs to
                            be generated, because they can be referenced by
                            other struct or function declarations. This is
                            automatically ensured as the resolved tree is
                            guaranteed to list every
                            <code>ResolvedStructDecl</code> before any other
                            declaration, so there is no need to implement any
                            complex logic in this step.
                        </p>
                    </li>
                    <li>
                        <p>
                            After every struct declaration has been given its
                            own type in the IR, connect the fields of the
                            structs to a valid type declaration.
                        </p>
                        <p>
                            This step should turn the currently opaque structs
                            into complete struct types with every field type
                            correctly specified by creating and setting their
                            bodies.
                        </p>
                        <pre><code>%struct.S = type opaque
%struct.S2 = type opaque</code></pre>
                        <p>
                            The above structs will turn into ones similar to
                            these below.
                        </p>
                        <pre><code>%struct.S = type { %struct.S2 }
%struct.S2 = type { double, double }</code></pre>
                    </li>
                    <li>
                        <p>
                            With struct types being supported, it's possible to
                            generate code for struct instantiations. In LLVM the
                            way to instantiate structs is to allocate space for
                            them first and then initialize each member
                            separately.
                        </p>
                        <pre><code>Color { r: initR(), g: initG(), b: initB() }</code></pre>
                        <p>
                            A struct instantiation expression doesn't allocate a
                            struct automatically, so it has to be done manually.
                            Then the fields of this manually allocated struct
                            are initialized to the specified values. Field
                            initialization happens in declaration order, but the
                            side-effects must be visible in instantiation order.
                        </p>
                        <p>
                            To make the previous logic easier to understand,
                            take a look at this example that shows how a struct
                            instantiation would be generated in LLVM IR.
                        </p>
                        <pre><code>struct Color { r: number, g: number, b: number }

fn instantiateColor(): void {
  Color { g: initG(), r: initR(), b: initB() }
}

let tmp: Color;

let gInit = initG();
let rInit = initR();
let bInit = initB();

tmp.r = rInit;
tmp.g = gInit;
tmp.b = bInit;</code></pre>
                        <p>
                            Allocating a new variable is straightforward, the
                            resulting IR will look like this.
                        </p>
                        <pre><code>%Color.tmp = alloca %struct.Color, align 8</code></pre>
                        <p>
                            Accessing a field of a variable however was not
                            necessary until now. In LLVM IR, the field of a
                            struct is accessed by its index and not by its name.
                            This is the reason for also storing the index of the
                            field in a <code>ResolvedMemberDecl</code>.
                        </p>
                        <!-- FIXME: link to the offcial guide that explains GEP -->
                        <p>
                            The field is accessed with the
                            <code>GetElementPointer</code> instruction. This
                            instruction can be confusing, so it's recommended to
                            let the
                            <code>llvm::IRBuilder::CreateStructGEP()</code>
                            helper create it. This helper takes the type of the
                            struct, a pointer to the beginning of the struct and
                            the index of the element that needs to be accessed.
                        </p>
                        <p>
                            Initializing <code>tmp.r</code> means getting the
                            pointer to the <code>r</code> field and assigning
                            the initial value to it.
                        </p>
                        <pre><code>%0 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 0
store double 1.000000e+00, double* %0, align 8</code></pre>
                        <p>
                            The full LLVM IR for instantiating the
                            <code>Color</code> struct at the beginning of this
                            point looks like this.
                        </p>
                        <pre><code>%Color.tmp = alloca %struct.Color, align 8
%0 = call double @initR()
%1 = call double @initG()
%2 = call double @initB()
%3 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 0
store double %0, double* %3, align 8
%4 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 1
store double %1, double* %4, align 8
%5 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 2
store double %2, double* %5, align 8</code></pre>
                        <p>
                            Note that the example struct deliberately has only
                            <code>number</code> fields. Assigning values to
                            struct fields works differently and will be
                            discussed later.
                        </p>
                    </li>
                    <li>
                        <p>
                            In the previous point, the fields of a struct have
                            already been accessed, so it's the perfect time to
                            implement code generation support for
                            <code>ResolvedMemberExpr</code>.
                        </p>
                        <p>
                            To read the field of a struct, a
                            <code>ResolvedDeclRefExpr</code> that references the
                            struct needs to be evaluated at some point. While
                            numbers are loaded into a register when referenced,
                            structs are not loaded into registers, as they might
                            not fit, so it must be ensured that a
                            <code>ResolvedDeclRefExpr</code> referencing a
                            struct always results in a pointer to that struct
                            without being followed by a load instruction.
                        </p>
                        <pre><code>%Color.tmp = alloca %struct.Color, align 8
...
%3 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 0</code></pre>
                        <p>
                            A member access results in a
                            <code>GetElementPointer</code> instruction on the
                            result of the base expression, however there is a
                            difference in how it is followed up depending on
                            whether the field is being written or read.
                        </p>
                        <p>
                            When the value of a numeric field is being read, it
                            has to be loaded from memory.
                        </p>
                        <pre><code>%3 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 0
%4 = load double, double* %3, align 8</code></pre>
                        <p>
                            On the other hand, if the field is being assigned
                            the <code>store</code> instruction expects a pointer
                            operand, so the field doesn't have to be loaded.
                        </p>
                        <pre><code>%3 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 0
store double 1.000000e+00, double* %3, align 8</code></pre>
                    </li>
                    <li>
                        <p>
                            At this point creating temporary structs and reading
                            their fields immediately should work correctly, but
                            it would be convenient to also be able to store the
                            structs in variables, initialize struct type fields
                            or assign a struct variable a different value.
                        </p>
                        <p>
                            All of the above use cases are handled by the same
                            logic. The difference between structs and numbers is
                            that structs are not loaded into registers, so the
                            <code>store</code> instruction cannot be used to
                            mutate their values. Any time a struct is assigned,
                            the value of each field must be manually assigned to
                            the same field of the destination struct.
                        </p>
                        <!-- FIXME: talk about copy elision here and memcpy-ing constant structs -->
                        <pre><code>let s = Color { r: 1, g: 2, b: 3 };

let tmp: Color;
tmp.r = 1;
tmp.g = 2;
tmp.b = 3;

let s: Color;
s.r = tmp.r;
s.g = tmp.g;
s.b = tmp.b;</code></pre>
                        <!-- FIXME: talk about what an intrinsic is -->
                        <p>
                            Manually assigning every field however would result
                            in duplicating the work and generating large LLVM IR
                            fragments. The goal is to make the content of the
                            piece of memory that stores the struct on the LHS
                            the same as the content of the memory storing the
                            one on the RHS. To achieve this easily, LLVM has a
                            builtin
                            <code>memcpy</code> intrinsic, that copies a
                            specific amount of memory from one place to another.
                            With that an assignment between 2 struct variables
                            can be simplified to a few lines only.
                        </p>
                        <pre><code>%3 = bitcast %struct.Color* %s to i8*
%4 = bitcast %struct.Color* %Color.tmp to i8*
call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 %4, i64 24, i1 false)</code></pre>
                        <p>
                            This is the version of <code>memcpy</code> created
                            by the
                            <code>llvm::IRBuilder::CreateMemCpy()</code> helper.
                            To use this helper, the alignment and the size of
                            the struct must be calculated first, which can be
                            done easily with the help of the
                            <code>llvm::DataLayout</code> utility.
                        </p>
                    </li>
                    <!-- FIXME: explain why immutable parameters don't need to be copied, but why they are in C++ (constness can be cast away) -->
                    <li>
                        <p>
                            By this point structs should be fully functional
                            within the body of a function. The last thing to do
                            is implementing support for passing them to and
                            returning them from functions.
                        </p>
                        <p>
                            Structs are passed to functions by value, however as
                            mentioned previously in LLVM IR only the pointer to
                            the struct can be moved around, it's not possible to
                            load them and pass the loaded value. Passing by
                            value however only means that no modification to the
                            parameter is visible outside the function, and this
                            can be achieved in LLVM IR.
                        </p>
                        <p>
                            For mutable parameters the trick is to create a copy
                            of the struct in the caller and pass a pointer to
                            that copy.
                        </p>
                        <pre><code>%c = alloca %struct.Color, align 8
%struct.arg.tmp = alloca %struct.Color, align 8
...
%5 = bitcast %struct.Color* %struct.arg.tmp to i8*
%6 = bitcast %struct.Color* %c to i8*
call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %6, i64 24, i1 false)
call void @mutableStructParam(%struct.Color* byval(%struct.Color) %struct.arg.tmp)</code></pre>
                        <p>
                            Notice how the <code>byval</code> attribute is added
                            to the function. It is a way to let LLVM know that
                            the particular parameter actually simulates a
                            pass-by-value semantic and when it does, this
                            attribute must be present at both the function
                            declaration and the callsite.
                        </p>
                        <pre><code>define void @mutableStructParam(%struct.Color* byval(%struct.Color) %c) {
  ...
}

call void @mutableStructParam(%struct.Color* byval(%struct.Color) %struct.arg.tmp)</code></pre>
                        <p>
                            When the parameter is immutable, there is no need to
                            copy the struct, as there are no modifications that
                            can be visible in the caller. To indicate that the
                            struct will never be modified inside the function
                            through the pointer, the
                            <code>readonly</code> attribute can be used. This
                            attribute is not compulsory though and can be
                            omitted.
                        </p>
                        <pre><code>%c = alloca %struct.Color, align 8
...
call void @immutableStructParam(%struct.Color* readonly %c)</code></pre>
                        <p>
                            Returning the struct is also done through a
                            dedicated parameter. If the function returns a
                            struct by value, a temporary variable that stores
                            the return value is allocated in the caller and the
                            pointer to this value is passed as the first
                            parameter of the function marked by the compulsory
                            <code>sret</code> attribute. The return statement
                            copies the returned value into the parameter marked
                            by <code>sret</code>, and the function is treated as
                            if it was a void function.
                        </p>
                        <pre><code>define void @caller() {
entry:
  %struct.ret.tmp = alloca %struct.Color, align 8
  call void @returnStruct(%struct.Color* sret(%struct.Color) %struct.ret.tmp)
  ret void
}

define void @returnStruct(%struct.Color* sret(%struct.Color) %ret) {
entry:
  %Color.tmp = alloca %struct.Color, align 8
  ...
  %3 = bitcast %struct.Color* %ret to i8*
  %4 = bitcast %struct.Color* %Color.tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 %4, i64 24, i1 false)
  br label %return

return: 
  ret void
}</code></pre>
                    </li>
                </ol>
                <h2>The End</h2>
                <p>
                    Congratulations for reaching the end of this exercise, the
                    compiler now fully supports struct in the language!
                </p>
                <p>
                    Hopefully it was time well spent and an interesting
                    experience to explore the different fields of language
                    design, static code analysis and code generation throughout
                    the previous few sections.
                </p>
            </section>
            <footer>
                <p>
                    <small
                        >Hosted on GitHub Pages &mdash; Theme by
                        <a href="https://github.com/orderedlist" target="_blank"
                            >orderedlist</a
                        ></small
                    >
                </p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
        <script src="javascripts/toc.js"></script>
    </body>
</html>
