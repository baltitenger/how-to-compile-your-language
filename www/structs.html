<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="chrome=1" />
        <title>How to Compile Your Language</title>
        <link rel="icon" href="./favicon.ico" />
        <link rel="stylesheet" href="stylesheets/styles.css" />
        <link rel="stylesheet" href="stylesheets/pygment_trac.css" />
        <meta name="viewport" content="width=device-width" />
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="wrapper">
            <header>
                <ul>
                    <li>
                        <a href="index.html">Prologue </a>
                    </li>
                    <li><a href="lexing.html">Lexing</a></li>
                    <li><a href="parsing.html">Parsing</a></li>
                    <li>
                        <a href="extending-the-parser.html"
                            >Extending the Language</a
                        >
                    </li>
                    <li><a href="sema.html">Semantic Analysis</a></li>
                    <li><a href="codegen.html">Generating LLVM IR</a></li>
                    <li><a href="driver.html">Driver</a></li>
                    <li>
                        <a href="operators.html">Operators</a>
                    </li>
                    <li>
                        <a href="constexpr.html">Constant Expressions</a>
                    </li>
                    <li>
                        <a href="control-flow.html">Control Flow</a>
                    </li>
                    <li>
                        <a href="variables.html">Variables</a>
                    </li>
                    <br />
                    <li>
                        <a href="structs.html">Exercise: Structs</a>
                        <div id="toc"></div>
                    </li>
                </ul>
            </header>
            <section>
                <h1>Extending the Language With Structs</h1>
                <p>
                    This section introduces a self-paced excercise to extend the
                    language with structs. The subsections only describe the
                    requirements and the theoretical background of every step.
                    Figuring out the implementation details of the new features
                    is part of the exercise. Imagine that this is a real world
                    situation of working as a compiler engineer and getting a
                    task to extend the language based on certain criteria.
                </p>
                <!-- FIXME add the link to the GH repo here -->
                <h2>Motivation</h2>
                <p>
                    The motivation behind structs is to pack values together and
                    make it more convenient to simultaneously pass them around,
                    as well as to make the source code more expressive.
                </p>
                <pre><code>fn rgbToGray(r: number, g: number, b: number): number {
  return (r + g + b) / 3;
}</code></pre>
                <p>
                    Maintaining 3 different variables to store each individual
                    color channel value can become overwhelming quickly and also
                    affects readability and maintanability. Expressing the same
                    logic with structs makes it more readable and maintainable.
                </p>
                <pre><code>struct RGBColor {
  r: number,
  g: number,
  b: number,
}

fn rgbToGray(c: RGBColor): number {
  return (c.r + c.g + c.b) / 3;
}</code></pre>
                <h2>Warm-up</h2>
                <p>
                    Whether extending the compiler from the lexer to code
                    generation seems overwhelming at first, or it looks like a
                    walk in the park, doing some small task to get used to
                    working on a codebase is always a good idea.
                </p>
                <p>
                    In the current version the language parameters are passed by
                    value, can only be of
                    <code>number</code> type and are always immutable. With
                    <code>struct</code> parameters however, there can be use
                    cases when only one or two fields of the struct needs to be
                    changed within the function body. With immutable parameters,
                    the only way to achieve this is to duplicate the
                    <code>struct</code> into a local variable and then change
                    the field value of this variable.
                </p>
                <pre><code>fn removeGreenChannel(c: RGBColor): RGBColor {
  var greenRemoved = c;
  greenRemoved.g = 0;

  return greenRemoved;
}</code></pre>
                <!-- FIXME design note about why the struct is passeb by value -->
                <p>
                    Because the <code>struct</code> is passed by value, no
                    modification to it would be visible in the caller anyway, so
                    creating a copy of it doesn't make sense. To resolve this
                    inconvenience, it's time to introduce support for mutable
                    parameters, which are marked with the
                    <code>var</code> keyword, similarly to how it used to be in
                    Swift. Declaring a parameter with the
                    <code>var</code> keyword keeps the language consistent with
                    local variable declarations where <code>var</code> also
                    expresses that mutations to the value are intended.
                </p>
                <!-- FIXME: add a design note on why Swift removed var parameters and why it is not an issue in this language -->
                <pre><code>fn removeGreenChannel(var c: RGBColor): RGBColor {
  c.g = 0;
  return c;
}</code></pre>
                <p>
                    To implement this simple, but useful change proceed with the
                    following few steps.
                </p>
                <ol>
                    <li>
                        <p>
                            Update the parser so that it accepts this
                            <code>paramDecl</code> grammar extension.
                        </p>
                        <pre><code>&lt;paramDecl&gt;
  ::= 'var'? &lt;identifier&gt; ':' &lt;type&gt;
</code></pre>
                        <p>
                            Don't forget to store whether the parameter is
                            mutable or not in the AST similary to
                            <code>VarDecl</code>, as the semantic analyzer needs
                            this information to ensure that only the allowed
                            operations are performed on the value.
                        </p>
                    </li>
                    <li>
                        <p>
                            In the semantic analyzer ensure that the parameter
                            declaration is resolved properly and modifying an
                            immutable parameter still results in an error, but
                            changing a mutable parameters is allowed. The
                            parameter of built-in
                            <code>println</code> should remain immutable.
                        </p>
                        <pre><code>fn paramSema(x: number, var y: number): void {
  y = 0;
  x = 1;
    ^ error: 'x' cannot be mutated
}</code></pre>
                        <p>
                            The mutation of the value is checked in the one and
                            only dataflow analysis pass, which expects the LHS
                            of an assignment to be a
                            <code>ResolvedVarDecl</code>, but this is no longer
                            the case. To make modifying this pass and later the
                            code generation easier, lift the
                            <code>isMutable</code> field up from
                            <code>ResolvedVarDecl</code> to the
                            <code>ResolvedDecl</code> base class.
                        </p>
                        <pre><code>struct ResolvedDecl {
  ...
  bool isMutable;

  ...
};</code></pre>
                        <p>
                            This property should automatically be set to
                            <code>false</code> for every resolved declaration
                            except for variables and parameters, for which it
                            should be deduced from the AST.
                        </p>
                        <p>
                            Note that this change also forwards the mutability
                            of the parameter to <code>Codegen</code>, where it
                            can be used for more efficient LLVM IR generation.
                        </p>
                    </li>
                    <li>
                        <p>
                            During LLVM IR generation, in the function body a
                            local variable is introduced for every parameter,
                            and their values are copied into these variables.
                            When the value of the parameter is read, LLVM loads
                            the corresponding local variable and uses it's value
                            for further computation.
                        </p>
                        <pre><code>define void @varParam(double %n) {
entry:
  %n1 = alloca double, align 8
  store double %n, double* %n1, align 8
  %0 = load double, double* %n1, align 8
  call void @println(double %0)
  ret void
}</code></pre>
                        <p>
                            Notice how the function in the example is called
                            <code>varParam()</code>. This is not a coincidence,
                            because in truth, this local variable only needs to
                            be introduced if the parameter is mutable, as it's
                            only purpose is to make changes to the parameter
                            visible within the function body.
                        </p>
                        <!-- FIXME: add a design note on why this is not default in C++ because of the & operator -->
                        <p>
                            The language is designed such way that the semantic
                            analyzer can ensure that every code modifying an
                            immutable parameter is rejected before code
                            generation. This allows <code>Codegen</code> to take
                            advantage of this information and generate more
                            optimized LLVM IR by omitting the local variable
                            creation for immutable parameters.
                        </p>
                        <pre><code>define void @nonVarParam(double %n) {
entry:
  call void @println(double %n)
  ret void
}</code></pre>
                        <p>
                            Update <code>Codegen</code> so that a local variable
                            is no longer introduced for immutable parameters.
                            Also ensure that when a
                            <code>ResolvedDeclRefExpr</code> points to such a
                            parameter, it's value is no longer loaded. The
                            generated LLVM IR for mutable parameters should
                            remain unchanged.
                        </p>
                    </li>
                </ol>
                <h2>Accepting the New Syntax</h2>
                <p>
                    A struct declaration can only appear on the top level, so
                    nested struct declarations are not allowed. Each such
                    declaration constains a list of field declarations separated
                    by commas. A trailing comma is allowed at the end.
                </p>
                <p>
                    A field declaration is the name and the type of the field
                    separated by a <code>:</code>.
                </p>
                <pre><code>struct S {
    field: type,
    field: type,
    field: type,
}</code></pre>
                <p>
                    By making the comma at the end optional, the
                    <code>struct</code> can also be written on only a single
                    line conveniently.
                </p>
                <pre><code>struct S { field: type, field: type, field: type }</code></pre>
                <p>
                    This syntax would require the parser to recognize the
                    grammar below.
                </p>
                <pre><code>&lt;sourceFile> 
    ::= (&lt;structDecl> | &lt;functionDecl>)* EOF

&lt;structDecl>
    ::= 'struct' &lt;identifier> &lt;fieldList>

&lt;fieldList>
    ::= '{' (&lt;fieldDecl> (',' &lt;fieldDecl>)* ','?)? '}'</code></pre>
                <p>
                    Instantiating the structs happends using the same syntax,
                    except for dropping the <code>struct</code> keyword from the
                    beginning and by pairing the fields with expressions that
                    give values to them.
                </p>
                <pre><code>S {
  field: expr, 
  field: expr, 
  field: expr,
};</code></pre>
                <p>
                    A struct instantiation expression is added to the language
                    as a primary expression, so the resulting grammar is the
                    following.
                </p>
                <pre><code>&lt;primaryExpr>
    ::= ...
    |   &lt;structInstantiation>
    |   &lt;declRefExpr>

&lt;structInstantiation>
    ::= &lt;identifier> &lt;fieldInitList>

&lt;fieldInitList>
    ::= '{' (&lt;fieldInit> (',' &lt;fieldInit>)* ','?)? '}'

&lt;memberInit>
    ::= &lt;identifier> ':' &lt;expr></code></pre>
                <p>
                    Notice how <code>structInstantiation</code> is listed before
                    <code>declRefExpr</code>. Each of these expressions start
                    with an <code>identifier</code>, but a
                    <code>structInstantiation</code> has a priority over a
                    <code>declRefExpr</code>. This ensures that if an expression
                    can be parsed as a struct instantiation, it is parsed that
                    way instead of just parsing the name of the struct as a
                    reference declaration and erroring out on the
                    <code>{</code> token.
                </p>
                <pre><code>Error { ... };
      ^
error: expected ';' at the end of expression</code></pre>
                <p>
                    Also notice how this struct instantiation syntax introduces
                    an ambiguity when placed in the condition of an
                    <code>if</code> or <code>while</code> statement.
                </p>
                <pre><code>if Ambiguous {} {}</code></pre>
                <p>
                    This can either be parsed as the condition is a reference to
                    a variable called <code>Ambiguous</code> followed by an
                    emtpy block, or as the condition is an instantiated struct
                    followed by an empty block.
                </p>
                <pre><code>IfStmt
  DeclRefExpr: Ambiguous
  Block
error: expected expression

IfStmt
  StructInstantiationExpr: Ambiguous
    ...
  Block
</code></pre>
                <p>
                    To resolve this ambiguity a
                    <code>structInstantiation</code> is not allowed inside a
                    condition and the parser should ensure that the statement is
                    always parsed the first way, that results in an error.
                </p>
                <p>
                    If for any reason a struct needs to be instantiated in a
                    condition, it should be wrapped in a grouping expression as
                    it can disambiguate the condition.
                </p>
                <pre><code>if (NoLongerAmbiguous {}) {}</code></pre>

                <p>
                    After declaring and instantiating structs, there must be a
                    way to read their members, that gives the last syntactical
                    extension of the language.
                </p>
                <p>
                    Since a struct can have fields that are also structs, any
                    arbitrarily deep members can be accessed, or assigned. A
                    struct can also be returned from a function and accessing or
                    assigning the members of the returned struct is also
                    allowed, which means all of the expressions below are valid.
                </p>
                <pre><code>s.f1.f2.f3 = v
foo().f1.f2 = v</code></pre>
                <p>
                    On the other hand a struct can't have methods, so calling an
                    accessed field is not allowed.
                </p>
                <pre><code>not.allowed()</code></pre>
                <p>
                    This limitation can be handled in the parser by modifying
                    <code>postfixExpression</code> the following way.
                </p>
                <pre><code>&lt;postfixExpression>
    ::= &lt;primaryExpression> &lt;argumentList>? ('.' &lt;identifier>)*</code></pre>
                <p>
                    To make the parser support the syntactical modifications
                    take the following steps:
                </p>
                <ol>
                    <li>
                        <p>
                            Update the lexer so that it recognizes every new
                            token and keyword.
                        </p>
                    </li>
                    <li>
                        <p>
                            Extend the AST with new nodes that represent the
                            elements of the new syntax. To make this point
                            easier below can be seen a short description and the
                            AST dump of every node that needs to be added.
                        </p>
                        <p>
                            The <code>FieldDecl</code> node represents a field
                            declaration by storing the identifier and the type
                            of the field.
                        </p>
                        <pre><code>FieldDecl: identifier:type</code></pre>
                        <p>
                            The <code>StructDecl</code> node represents the
                            struct declaration. It also houses every
                            <code>FieldDecl</code> inside the struct.
                        </p>
                        <pre><code>StructDecl: identifier
  FieldDecl: identifier:type
  FieldDecl: identifier:type
  FieldDecl: identifier:type</code></pre>
                        <p>
                            The <code>FieldInitStmt</code> node represents a
                            field initialization inside a struct instantiation.
                            It stores the identifier of the field that's being
                            initialized as well as the expression the result of
                            which is used to initialize the field.
                        </p>
                        <pre><code>FieldInitStmt: identifier
  &lt;Expr></code></pre>
                        <p>
                            The
                            <code>StructInstantiationExpr</code>
                            represents a struct instantiation by storing the
                            identifier of the struct and the list of member
                            initialization statements.
                        </p>
                        <pre><code>StructInstantiationExpr: identifier
  FieldInitStmt: identifier
    &lt;Expr>
  FieldInitStmt: identifier
    &lt;Expr>
  FieldInitStmt: identifier
    &lt;Expr></code></pre>
                        <p>
                            The <code>MemberExpr</code> node represents an
                            access to a field of a struct. It stores the base
                            expression that is used to refer to the struct and
                            the identifier of the field being accessed.
                        </p>
                        <pre><code>MemberExpr: .identifier
  &lt;Expr></code></pre>
                    </li>
                    <li>
                        <p>
                            To enforce the restrictions on the LHS of an
                            assigment in the parser, introduce an
                            <code>AssignableExpr</code> placeholder node and
                            make it the base class of
                            <code>DeclRefExpr</code> and
                            <code>MemberExpr</code>. The
                            <code>Assignment</code> node should also store an
                            <code>AssignableExpr</code> instead of a
                            <code>DeclRefExpr</code>.
                        </p>
                        <p>
                            Update the parser so that it also uses this new node
                            while parsing an assignment.
                        </p>
                    </li>
                    <li>
                        <!-- FIXME: explain why the declaration order is preserved in the ast -->
                        <p>
                            Extend the parser so that it can parse the grammar
                            extensions according to their specification
                            described at the top of this section. Because the
                            top level of the source file is no longer a list of
                            functions but a list of functions and structs, the
                            parser should now return a list of declarations.
                        </p>
                        <!-- FIXME: point the reader to the rust parser as a source of help -->
                        <p>
                            To resolve the ambiguity of structs inside
                            conditions find a way to support restrictions on
                            parsing a specific element.
                        </p>
                        <p>
                            When the condition is parsed, a restriction that
                            disallows parsing struct instantiation should be
                            applied to that expression. A grouping expression on
                            the other hand should disable every restriction that
                            is currently applied, as it creates a new context
                            for the expression it wraps.
                        </p>
                    </li>
                    <li>
                        <p>
                            Extend the parser error recovery, so that
                            synchronization also happens on the
                            <code>struct</code> keyword. For update
                            <code>synchronizeOn()</code> to accept a list of
                            tokens instead of a single token only, as on the top
                            level both <code>struct</code> and
                            <code>fn</code> is a synchronization point.
                        </p>
                        <pre><code>fail struct {} fn ...
┌─────┐ ┌────────┐ ┌───┐ ┌───┐ ┌────┐ ┌─────┐
│ ... │ │ struct │ │ { │ │ } │ │ fn │ │ ... │
└─────┘ └────────┘ └───┘ └───┘ └────┘ └─────┘
   ^        ^                    ^
   |        └ synchronize here   └ don't skip here
   └ fail here</code></pre>
                        <p>
                            If a failure happens inside a struct instantiation,
                            the parser should explicitly synchronize on the next
                            <code>}</code> token instead of waiting for an
                            automatic synchronization on the top level.
                        </p>
                        <pre><code>S { f1: fail, f2: 0 }
┌─────┐ ┌───┐ ┌─────┐ ┌───┐
│ ... │ │ , │ │ ... │ │ } │
└─────┘ └───┘ └─────┘ └───┘
   ^                    ^                 
   └ fail here          └ synchronize here</code></pre>
                    </li>
                    <li>
                        <p>
                            At this point the driver is broken as it still
                            expects a list of function declarations that it
                            either dumps or passes to the semantic analyzer. Fix
                            the errors in the driver and make sure that every
                            code that compiled before the parser extension still
                            compiles.
                        </p>
                    </li>
                </ol>
                <h2>Semantic of Structs</h2>
                <p>
                    Structs are declared on the top level, but they are not
                    location dependent, meaning a struct doesn't have to be
                    declared before it can be used.
                </p>
                <!-- FIXME: design note about forward declarations -->
                <p>
                    This leads to the need to resolve structs similarly to
                    functions, in multiple passes, except that struct
                    declarations also need to be resolved before function
                    declarations because a function can refer to a struct before
                    it is declared.
                </p>
                <pre><code>fn returnS(): S { ... }
              ^ 'S' must be found when resolving the
                function declaration

struct S { ... }</code></pre>
                <!-- FIXME: explain why storing structs be reference requires runtime support and talk about GC and ARC -->
                <p>
                    Structs are stored on the stack, passed to and returned from
                    functions by value. To allocate a struct on the stack, it's
                    size must be known at compile time. Because a struct is a
                    list of values grouped together, it's size is equivalent to
                    the sum of the size of it's members.
                </p>
                <pre><code>struct Color {      Stack:
  r: number,          r: size(number) ┐
  g: number,          g: size(number) ├ (+) size(Color)
  b: number,          b: size(number) ┘
}</code></pre>
                <p>
                    Because of how the size is computed, a struct cannot have a
                    member of itself as in that case to compute the size of the
                    struct, the compiler already has to know it, but to know it,
                    it has to compute it first.
                </p>
                <pre><code>struct S {
  self: S      size(S) = size(self) = size(S) = ...
}</code></pre>
                <p>
                    The semantic analyzer also has to catch the case, when the
                    struct contains itself through one or more nested structs.
                </p>
                <pre><code>struct S { x: S2 }
struct S2 { y: S }

size(S) = size(x) = size(S2) = size(y) = size(S) = ...</code></pre>
                <p>
                    A struct cannot have <code>void</code> fields, or multiple
                    fields with the same name.
                </p>
                <pre><code>struct VoidField {
  f: void,
  ^ error: field cannot be void
}

struct DuplicateField {
  f: number,
  f: number,
  ^ error: error: field 'f' is already declared
}</code></pre>
                <p>
                    Upon instantiating a struct, each field must be initialized
                    but only declared fields can be initialized. Also the same
                    field cannot be initialized more than once.
                </p>
                <pre><code>struct Color {
  r: number,
  g: number,
  b: number,
}

fn main(): void {
  Color {
  ^ error: member 'b' is not initialized
    r: 255,
    r: 255,
    ^ error: field 'r' is already initialized
    g: 255,
    a: 0,
    ^ error: 'Color' has no field named 'a'
  };
}</code></pre>
                <p>
                    A <code>MemberExpr</code> is only allowed to access the
                    existing fields of structs.
                </p>
                <pre><code>fn main(): void {
  let n = 0;
  n.x;
  ^ error: cannot access member of 'number'

  let c = Color { r: 1, g: 2, b: 3 };
  c.y;
   ^ error: 'Color' has no member called 'y'
}</code></pre>
                <p>Proceed with performing the following steps:</p>
                <ol>
                    <li>
                        <p>
                            Extend <code>Type</code> with an additional
                            <code>structType</code>. The <code>kind</code> field
                            should store a new <code>Struct</code> kind and the
                            name field should store the identifier of the
                            struct.
                        </p>
                        <pre><code>static Type structType(const std::string &id) { return {Kind::Struct, id}; }</code></pre>
                        <p>
                            Two struct types are considered equal if their
                            identifiers are equal.
                        </p>
                    </li>
                    <li>
                        <p>
                            Extend the resolved tree with a new node for every
                            new AST node.
                        </p>
                        <p>
                            The <code>ResolvedFieldDecl</code> node represents
                            the resolved version of a <code>FieldDecl</code>.
                            Besides storing the identifier and the type of the
                            field, it should also store it's index within the
                            struct to make code generation easier in the future.
                        </p>
                        <pre><code>ResolvedFieldDecl: @(decl.address) identifier</code></pre>
                        <p>
                            The <code>ResolvedStructDecl</code> is the resolved
                            version of a <code>StructDecl</code>, it stores the
                            resolved field declarations of the struct.
                        </p>
                        <pre><code>ResolvedStructDecl: @(decl.address) identifier:
  ResolvedFieldDecl: @(decl.address) identifier
  ResolvedFieldDecl: @(decl.address) identifier
  ResolvedFieldDecl: @(decl.address) identifier</code></pre>
                        <p>
                            The <code>ResolvedFieldInitStmt</code> should store
                            the initializer expression and a pointer to the
                            declaration of the member being initialized.
                        </p>
                        <pre><code>ResolvedFieldInitStmt: @(field.address) identifier
  &lt;ResolvedExpr></code></pre>
                        <p>
                            The members of the struct are initialized in the
                            order they are declared, so to make code generation
                            simpler, the
                            <code>ResolvedStructInstantiationExpr</code>
                            should store the field initialization statements in
                            the same order.
                        </p>
                        <pre><code>ResolvedStructInstantiationExpr: @(struct.addr)
  ResolvedFieldInitStmt: @(field.address) identifier
    &lt;ResolvedExpr>
  ResolvedFieldInitStmt: @(field.address) identifier
    &lt;ResolvedExpr>
  ResolvedFieldInitStmt: @(field.address) identifier
    &lt;ResolvedExpr></code></pre>
                        <p>
                            The <code>ResolvedMemberExpr</code> node stores a
                            pointer to the accessed member decl and the base
                            expression returning the struct.
                        </p>
                        <pre><code>ResolvedMemberExpr: @(field.address) r
  &lt;ResolvedExpr></code></pre>
                    </li>
                    <li>
                        <p>
                            Introduce a <code>ResolvedAssignableExpr</code> no
                            to represent the
                            <code>AssignableExpr</code> placeholder node and
                            make it the base class of
                            <code>ResolvedDeclRefExpr</code> and
                            <code>ResolvedMemberExpr</code>. The
                            <code>ResolvedAssignment</code> node should also
                            store an <code>ResolvedAssignableExpr</code> instead
                            of a <code>ResolvedDeclRefExpr</code>.
                        </p>
                        <p>
                            Update the semantic analyzer so that it can resolve
                            this new node properly.
                        </p>
                    </li>
                    <li>
                        <p>
                            Resolve every <code>StructDecl</code> before
                            processing the function declarations. A struct can
                            store other structs that are not resolved when seen,
                            because they are declared later in the source code.
                            To avoid errors, at this point only validate that
                            fields are not redeclared and are not of
                            <code>void</code> type.
                        </p>
                        <p>
                            Ensure that in the resolved tree every struct
                            declaration preceedes any function declaration, to
                            make code generation easier.
                        </p>
                    </li>
                    <li>
                        <p>
                            After function declarations are resolved, resolve
                            the body of the struct declarations, and check for
                            structs containing themselves.
                        </p>
                    </li>
                    <li>
                        <p>Resolve struct instantiation and member access.</p>
                    </li>
                    <li>
                        <p>
                            Add the new expressions to the CFG and update it, so
                            that is also stores the LHS of an assignment if it's
                            not a
                            <code>ResolvedDeclRefExpr</code>.
                        </p>
                    </li>
                </ol>
                <h2>Structs in LLVM</h2>
                <p>
                    At this point structs can be parsed and validated by the
                    semantic analyzer. This section introduces how to work with
                    structs in LLVM IR and see all the previous changes put into
                    a platform specific executable.
                </p>
                <ol>
                    <li>
                        <!-- FIXME: use the words 'literal' and 'identified' -->
                        <p>
                            The first step towards seeing the new syntactical
                            changes in action is to represent each resolved
                            struct as a struct type in LLVM IR.
                        </p>
                        <p>
                            LLVM supports two kinds of struct type, named and
                            unnamed. An unnamed struct comes in handy for
                            languages that have built-in support for working
                            with directly packed together values, also known as
                            tuple types, or when implementing optimizations, but
                            more on that later.
                        </p>
                        <pre><code>fn returnTuple(): (number, number) { ... }</code></pre>
                        <p>
                            The snippet above could be represented with the
                            following piece of LLVM IR, where
                            <code>{ double, double }</code> is an unnamed struct
                            of two double members.
                        </p>
                        <pre><code>define { double, double } @returnTuple() { ... }</code></pre>
                        <p>
                            Named structs on the other hand are useful to
                            represent a concrete pack of values, like structs or
                            classes in a language.
                        </p>
                        <pre><code>struct Color { r: number, g: number, b: number }</code></pre>
                        <p>
                            The <code>Color</code> struct in LLVM IR would be
                            written the way below.
                        </p>
                        <pre><code>%struct.Color = type { double, double, double }</code></pre>
                        <p>
                            It's important to note that while unnamed struct are
                            structurally uniqued, so every
                            <code>{ double, double }</code> in the IR refers to
                            the same type, named structs are always different,
                            so even if the IR contains
                            <code>%struct.a = type { double, double }</code> and
                            <code>%struct.b = type { double, double }</code>,
                            <code>%struct.a</code> is not the same type as
                            <code>%struct.b</code>.
                        </p>
                        <p>
                            A struct type can also be opaque, which tells LLVM
                            that this struct exists, but it doesn't describe
                            what members it has, similarly to a forward
                            declaration in C.
                        </p>
                        <p>
                            In this step every
                            <code>ResolvedStructDecl</code> should be
                            represented with an opaque identified
                            <code>llvm::StructType</code>. Every time a struct
                            type is referenced, it's generated type should be
                            used, don't generate a new
                            <code>llvm::StructType</code> multiple times for the
                            same struct.
                        </p>
                        <p>
                            For example, declaring a <code>Color</code> variable
                            would look like this.
                        </p>
                        <pre><code>%struct.Color = type { double, double, double }

define void @allocateColor() {
entry:
  %c = alloca %struct.Color, align 8
  ret void
}</code></pre>
                        <p>
                            Similarly to what happens in the semantic analyzer,
                            first a type for every struct declaration needs to
                            be generated, because they can be referenced by
                            other structs or function declarations. This should
                            be straightforward as the resolved tree is
                            guaranteed to list every
                            <code>ResolvedStructDecl</code> before any other
                            declaration.
                        </p>
                    </li>
                    <li>
                        <p>
                            After every struct declaration has been given it's
                            own type in the IR, connect the fields of the struct
                            to a valid type declaration.
                        </p>
                        <p>
                            This step should turn the currently opaque structs
                            into complete struct types with every field type
                            correctly specified.
                        </p>
                        <pre><code>%struct.S = type opaque
%struct.S2 = type opaque</code></pre>
                        <p>
                            The above structs will turn into ones similar to
                            these below.
                        </p>
                        <pre><code>%struct.S = type { %struct.S2 }
%struct.S2 = type { double, double }</code></pre>
                    </li>
                    <li>
                        <p>
                            With struct types being supported, it's possible to
                            generate code for struct instantiations. In LLVM
                            they way to instantiate structs is to allocate them
                            first and then initialize each member separately.
                        </p>
                        <pre><code>Color { r: 1, g: 2, b: 3 }</code></pre>
                        <p>
                            As it can be seen, a struct instantiation expression
                            doesn't allocate a struct automatically, so it has
                            to be done manually. Then the fields of this
                            manually allocated struct will be initialized to the
                            specified values.
                        </p>
                        <p>
                            The above expression in LLVM IR would result in the
                            following logic. Note that in source code the
                            following snippet is invalid, it is only for
                            illustration purposes.
                        </p>
                        <pre><code>let tmp: Color;
tmp.r = 1;
tmp.g = 2;
tmp.b = 3;</code></pre>
                        <p>
                            Allocating a new variable is straightforward, the
                            resultin IR will look like this.
                        </p>
                        <pre><code>%Color.tmp = alloca %struct.Color, align 8</code></pre>
                        <p>
                            Accessing a field of a variable however was not
                            necessary until now. In LLVM IR, the field of a
                            struct is accessed by it's index and not by it's
                            name. This is the reason for also storing the index
                            of the field in a <code>ResolvedMemberExpr</code>.
                        </p>
                        <!-- FIXME: link to the offcial guide that explains GEP -->
                        <p>
                            The field is accessed with the
                            <code>GetElementPointer</code> instruction. This
                            instruction can be confusing, so the recommended way
                            is to let the
                            <code>llvm::IRBuilder::CreateStructGEP()</code>
                            helper create it. This helper takes the type of the
                            struct, a pointer to the beginning of the struct and
                            the index of the element that needs to be accessed.
                        </p>
                        <p>
                            Initializing <code>tmp.r</code> means calculating
                            the pointer to the <code>r</code> field and
                            assigning the initial value to it.
                        </p>
                        <pre><code>%0 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 0
store double 1.000000e+00, double* %0, align 8</code></pre>
                        <p>
                            The full LLVM IR for instantiating the
                            <code>Color</code> struct at the beginning of this
                            point looks like this.
                        </p>
                        <pre><code>%Color.tmp = alloca %struct.Color, align 8
%0 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 0
store double 1.000000e+00, double* %0, align 8
%1 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 1
store double 2.000000e+00, double* %1, align 8
%2 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 2
store double 3.000000e+00, double* %2, align 8</code></pre>
                        <p>
                            Note that the example struct deliberately has only
                            <code>number</code> fields. Assigning values to
                            struct fields works differently and will be
                            discussed later.
                        </p>
                    </li>
                    <li>
                        <p>
                            In the previous points fields of structs have
                            already been accessed, so it's the perfect time to
                            implement code generation support for
                            <code>ResolvedMemberExpr</code>.
                        </p>
                        <p>
                            To read the field of a struct, at some point code
                            for a <code>ResolvedDeclRefExpr</code> that
                            references the struct needs to be generated. While
                            numbers are loaded into a register, when referenced,
                            struct behave like immutable function parameters and
                            they are never loaded into registers, so it must be
                            unsured that a
                            <code>ResolvedDeclRefExpr</code> referencing a
                            struct always results in a pointer to that struct
                            without being followed by a load instruction.
                        </p>
                        <p>
                            A member access results in a
                            <code>GetElementPointer</code> instruction on the
                            pointer returned from generating code for it's base
                            expression, however there is a difference in how
                            it's followed up depending on whether the field is
                            being written or read.
                        </p>
                        <p>
                            When the value of a numberic field is being read, it
                            has to be loaded from memory.
                        </p>
                        <pre><code>%3 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 0
%4 = load double, double* %3, align 8</code></pre>
                        <p>
                            On the other hand, if the field is being assigned
                            the <code>store</code> instruction expects a pointer
                            operand, so the field doesn't have to be loaded.
                        </p>
                        <pre><code>%3 = getelementptr inbounds %struct.Color, %struct.Color* %Color.tmp, i32 0, i32 0
store double 1.000000e+00, double* %3, align 8</code></pre>
                    </li>
                    <li>
                        <p>
                            At this point creating temporary structs and reading
                            their fields immediately should work correctly, but
                            it would be convenient to also be able to store the
                            structs in variables, initialize struct fields or
                            assign a struct variable a different value.
                        </p>
                        <p>
                            All of the above use cases are handled by the same
                            logic. The difference between structs and numbers is
                            that they are not loaded into registers, so the
                            <code>load</code> and
                            <code>store</code> instructions don't work for them.
                            Any time a struct is assigned, the value of each
                            field must be manually assigned to the same field of
                            the destination struct.
                        </p>
                        <pre><code>let s = Color { r: 1, g: 2, b: 3 };</code></pre>
                        <p>
                            Based on this logic and what's already implemented,
                            the above snippet is equivalent to the following
                            piece of code.
                        </p>
                        <!-- FIXME: talk about copy elision here and memcpy-ing constant structs -->
                        <pre><code>let tmp: Color;
tmp.r = 1;
tmp.g = 2;
tmp.b = 3;

let s: Color;
s.r = tmp.r;
s.g = tmp.g;
s.b = tmp.b;</code></pre>
                        <!-- FIXME: talk about what an intrinsic is -->
                        <p>
                            Manually assigning every field however would result
                            in duplicating the work and generating large LLVM IR
                            code. The goal is to make the content of the piece
                            of memory that houses <code>s</code> the same as the
                            content of the memory housing <code>tmp</code>. For
                            this use case, LLVM has a builtin
                            <code>memcpy</code> intrinsic, that copies a
                            specific amount of memory from one place to another.
                            With that an assignment between 2 struct variables
                            can be simplified to a few lines only.
                        </p>
                        <pre><code>%3 = bitcast %struct.Color* %s to i8*
%4 = bitcast %struct.Color* %Color.tmp to i8*
call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 %4, i64 24, i1 false)</code></pre>
                        <p>
                            This is the version of <code>memcpy</code> created
                            by the
                            <code>llvm::IRBuilder::CreateMemCpy()</code> helper.
                            To use this helper, the alignment and the size of
                            the struct must be calculted first, which can be
                            done easily with the help of the
                            <code>llvm::DataLayout</code> utility.
                        </p>
                    </li>
                    <!-- FIXME: explain why immutable parameters don't need to be copied, but why they are in C++ (constness can be cast away) -->
                    <li>
                        <p>
                            By this point structs should be fully functional
                            within the body of a function. The last thing to do
                            is to implement support for passing them to and
                            returning them from functions.
                        </p>
                        <p>
                            Structs are passed to functions by value, however as
                            mentioned previously in LLVM IR only the pointer to
                            the struct can be moved around. Passing by value
                            means that no modification to the parameter is
                            visible outside the function, and this can be
                            achived in LLVM IR.
                        </p>
                        <p>
                            For mutable parameters the trick is to create a copy
                            of the struct in the caller and pass a pointer to
                            that copy.
                        </p>
                        <pre><code>%c = alloca %struct.Color, align 8
%struct.arg.tmp = alloca %struct.Color, align 8
...
%5 = bitcast %struct.Color* %struct.arg.tmp to i8*
%6 = bitcast %struct.Color* %c to i8*
call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %6, i64 24, i1 false)
call void @mutableStructParam(%struct.Color* byval(%struct.Color) %struct.arg.tmp)</code></pre>
                        <p>
                            Notice how the <code>byval</code> attribute is added
                            to the function. It is a way to let LLVM know that
                            the particular parameter actually simulates a
                            pass-by-value semantic and when it does, this
                            attribute must be present at both the function
                            declaration and the callsite.
                        </p>
                        <pre><code>define void @mutableStructParam(%struct.Color* byval(%struct.Color) %c) {
  ...
}

call void @mutableStructParam(%struct.Color* byval(%struct.Color) %struct.arg.tmp)</code></pre>
                        <p>
                            When the parameter is immutable, there is no need to
                            copy the struct, as there are no modifications that
                            can visible in the caller. To indicate that the
                            struct will never be modified inside the function
                            through the pointer, the
                            <code>readonly</code> attribute can be used. This
                            attribute is not compulsory though and can be
                            omitted.
                        </p>
                        <pre><code>%c = alloca %struct.Color, align 8
...
call void @immutableStructParam(%struct.Color* readonly %c)</code></pre>
                        <p>
                            Returning the struct is also done through a
                            dedicated parameter. If the function returns a
                            struct by value, a temporary variable that stores
                            the return value is allocated in the caller and the
                            pointer to this value is passed as the first
                            parameter of the function marked by the
                            <code>sret</code> attribute. The function is
                            otherwise treated as if it was a void function.
                        </p>
                        <pre><code>define void @caller() {
entry:
  %struct.ret.tmp = alloca %struct.Color, align 8
  call void @returnStruct(%struct.Color* sret(%struct.Color) %struct.ret.tmp)
  ret void
}

define void @returnStruct(%struct.Color* sret(%struct.Color) %ret) {
entry:
  %Color.tmp = alloca %struct.Color, align 8
  ...
  %3 = bitcast %struct.Color* %ret to i8*
  %4 = bitcast %struct.Color* %Color.tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 %4, i64 24, i1 false)
  br label %return

return: 
  ret void
}</code></pre>
                    </li>
                </ol>
                <p>
                    Congratulations! If every step was implemented correctly,
                    any arbitrary source code that works with structs can be
                    compiled and run correctly.
                </p>
            </section>
            <footer>
                <p>
                    <small
                        >Hosted on GitHub Pages &mdash; Theme by
                        <a href="https://github.com/orderedlist" target="_blank"
                            >orderedlist</a
                        ></small
                    >
                </p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
        <script src="javascripts/toc.js"></script>
    </body>
</html>
