<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="chrome=1" />
        <title>How to Compile Your Language</title>
        <link rel="icon" href="./favicon.ico" />
        <link rel="stylesheet" href="stylesheets/styles.css" />
        <link rel="stylesheet" href="stylesheets/pygment_trac.css" />
        <meta name="viewport" content="width=device-width" />
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="wrapper">
            <header>
                <ul>
                    <li>
                        <a href="index.html">Intro </a>
                    </li>
                    <li><a href="lexing.html">Lexing</a></li>
                    <li><a href="parsing.html">Parsing</a></li>
                    <li>
                        <a href="extending-the-parser.html"
                            >Extending the Language</a
                        >
                    </li>
                    <li><a href="sema.html">Semantic Analysis</a></li>
                    <li><a href="codegen.html">Generating LLVM IR</a></li>
                    <li><a href="driver.html">Driver</a></li>
                    <li>
                        <a href="operators.html">Operators</a>
                    </li>
                    <li>
                        <a href="constexpr.html">Constant Expressions</a>
                    </li>
                    <li>
                        <a href="control-flow.html">Control Flow</a>
                        <div id="toc"></div>
                    </li>
                    <li>
                        <a href="variables.html">Variables</a>
                    </li>
                </ul>
            </header>
            <section>
                <h1>Control Flow</h1>
                <p>
                    A programming language is not really a language without
                    statements that have an effect on the control flow. Arguably
                    there is already a <code>return</code> statement, which can
                    immediately transfer the control back to the caller, but the
                    language still misses conditions and loops.
                </p>
                <h2>Conditions</h2>
                <p>
                    Conditions are implemented in the form of
                    <code>if</code> statements. This statement starts with the
                    <code>if</code> keyword, which is followed by an expression
                    and a block. This series of tokens can optionally be
                    followed by an <code>else</code> keyword and another
                    <code>if</code> statement, or a block.
                </p>
                <pre><code>&lt;ifStatement>
  ::= 'if' &lt;expr> &lt;block> ('else' (&lt;ifStatement> | &lt;block>))?</code></pre>
                <p>
                    This allows the programmers to create different branches in
                    their code.
                </p>
                <pre><code>fn condition(x: number) {
    if x == 2 {
        ...
    } else if x == 3 {
        ...
    } else {
        ...
    }
}</code></pre>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        A common problem with conditions is the dangling else.
                        It can happen if the block is not mandatory after the
                        condition.
                    </p>
                    <pre><code>if (1)
    if (2)
      return 0;
    else
      return 1;</code></pre>
                    <p>
                        It raises the question which <code>if</code> the
                        <code>else</code> branch belongs to. By making the block
                        mandatory, this question becomes simple to answer.
                    </p>
                    <pre><code>  if (1) {
    if (2) { ... }
  } else {
    return 1;
  }</code></pre>
                    <p>
                        Also notice that the <code>( ... )</code> around the
                        condition was necessary for the parser to know where the
                        condition ends if it's not followed by a block. With
                        making the block mandatory these symbols are no longer
                        needed.
                    </p>
                </blockquote>
                <p>
                    To start extending the language with conditions, first the
                    <code>if</code> and <code>else</code> keywords need to be
                    introduced to the lexer.
                </p>
                <pre><code>enum class TokenKind : char {
  ...
  KwIf,
  KwElse,
  ...
};

const std::unordered_map&lt;std::string_view, TokenKind> keywords = {
    ..., 
    {"if", TokenKind::KwIf}, {"else", TokenKind::KwElse}};
</code></pre>
                <p>
                    In the AST the <code>if</code> statement has a condition and
                    a block for it's true and it's false branch respectively. It
                    can be observed that in the <code>else if</code> case, the
                    else branch is not a block, but a statement.
                </p>
                <p>
                    The <code>else if</code> case is actually a syntactic sugar
                    for <code>else { if ... }</code> and is parsed such way only
                    to keep the AST simple.
                </p>
                <pre><code>struct IfStmt : public Stmt {
  std::unique_ptr&lt;Expr> condition;
  std::unique_ptr&lt;Block> trueBlock;
  std::unique_ptr&lt;Block> falseBlock;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>
                    In the parser the condition has it's own parser method,
                    which is called from <code>parseStmt()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;Stmt> Parser::parseStmt() {
  if (nextToken.kind == TokenKind::KwIf)
    return parseIfStmt();

  ...
}</code></pre>
                <p>
                    The method expects the first token to be the
                    <code>KwIf</code>, which it eats and then proceeds with
                    parsing the condition the condition.
                </p>
                <pre><code>// &lt;ifStatement>
//  ::= 'if' &lt;expr> &lt;block> ('else' (&lt;ifStatement> | &lt;block>))?
std::unique_ptr&lt;IfStmt> Parser::parseIfStmt() {
  SourceLocation location = nextToken.location;
  eatNextToken(); // eat 'if'

  varOrReturn(condition, parseExpr());

  ...
}</code></pre>
                <p>
                    If the next token is not the beginning of a block, an error
                    is reported otherwise the true branch is parsed. If the
                    block is not followed by an <code>else</code>, the statement
                    only has a true branch and an AST node can be returned.
                </p>
                <pre><code>std::unique_ptr&lt;IfStmt> Parser::parseIfStmt() {
  ...

  if (nextToken.kind != TokenKind::Lbrace)
    return report(nextToken.location, "expected 'if' body");

  varOrReturn(trueBranch, parseBlock());

  if (nextToken.kind != TokenKind::KwElse)
    return std::make_unique&lt;IfStmt>(location, std::move(condition),
                                    std::move(trueBranch));
  ...
}</code></pre>
                <p>
                    If there is an <code>else</code> branch, the
                    <code>KwElse</code> token is eaten. If the else branch is a
                    regular else branch and not an <code>else if</code>, the
                    block is parsed and the AST node is returned.
                </p>
                <pre><code>std::unique_ptr&lt;IfStmt> Parser::parseIfStmt() {
  ...
  eatNextToken(); // eat 'else'

  std::unique_ptr&lt;Block> falseBlock;
  if (nextToken.kind == TokenKind::KwIf) {
    ...
  } else {
    if (nextToken.kind != TokenKind::Lbrace)
      return report(nextToken.location, "expected 'else' body");

    falseBlock = parseBlock();
  }

  if (!falseBlock)
    return nullptr;

  return std::make_unique&lt;IfStmt>(location, std::move(condition),
                                  std::move(trueBranch), std::move(falseBlock));
}</code></pre>
                <p>
                    If the branch is an <code>else if</code>, the other if
                    statement is parsed and put into a manually created false
                    block.
                </p>
                <pre><code>std::unique_ptr&lt;IfStmt> Parser::parseIfStmt() {
  ...
  if (nextToken.kind == TokenKind::KwIf) {
    varOrReturn(elseIf, parseIfStmt());

    SourceLocation loc = elseIf->location;
    std::vector&lt;std::unique_ptr&lt;Stmt>> stmts;
    stmts.emplace_back(std::move(elseIf));

    falseBlock = std::make_unique&lt;Block>(loc, std::move(stmts));
  } 
  ...
}</code></pre>
                <p>
                    The resolved node of the <code>if</code> statement is
                    identical to it's non-resolved counterpart.
                </p>
                <pre><code>struct ResolvedIfStmt : public ResolvedStmt {
  std::unique_ptr&lt;ResolvedExpr> condition;
  std::unique_ptr&lt;ResolvedBlock> trueBlock;
  std::unique_ptr&lt;ResolvedBlock> falseBlock;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>
                    The resolution the the statement is driven by
                    <code>resolveStmt()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedStmt> Sema::resolveStmt(const Stmt &stmt) {
  ...

  if (auto *ifStmt = dynamic_cast&lt;const IfStmt *>(&stmt))
    return resolveIfStmt(*ifStmt);

  ...
}</code></pre>
                <p>
                    First the condition is resolved followed by the resolution
                    of the true block. The condition must be a number.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedIfStmt> Sema::resolveIfStmt(const IfStmt &ifStmt) {
  varOrReturn(condition, resolveExpr(*ifStmt.condition));

  if (condition->type.kind != Type::Kind::Number)
    return report(condition->location, "expected number in condition");

  varOrReturn(trueBlock, resolveBlock(*ifStmt.trueBlock));

  ...
}</code></pre>
                <p>
                    If there is a false block, it is resolved too. Once
                    everything is resolved, it's checked if the value of the
                    condition is a compiler time constant and the value is set
                    accordingly.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedIfStmt> Sema::resolveIfStmt(const IfStmt &ifStmt) {
  ...

  std::unique_ptr&lt;ResolvedBlock> resolvedFalseBlock;
  if (ifStmt.falseBlock) {
    resolvedFalseBlock = resolveBlock(*ifStmt.falseBlock);
    if (!resolvedFalseBlock)
      return nullptr;
  }

  condition->setConstantValue(cee.evaluate(*condition, false));

  return std::make_unique&lt;ResolvedIfStmt>(ifStmt.location, std::move(condition),
                                          std::move(trueBlock),
                                          std::move(resolvedFalseBlock));
}</code></pre>
                <p>
                    The code generation is driven by
                    <code>generateStmt()</code>.
                </p>
                <pre><code>llvm::Value *Codegen::generateStmt(const ResolvedStmt &stmt) {
  ...

  if (auto *ifStmt = dynamic_cast&lt;const ResolvedIfStmt *>(&stmt))
    return generateIfStmt(*ifStmt);

  ...
}</code></pre>
                <p>
                    The idea for representing <code>if</code> in LLVM IR is to
                    create a new basic block for all of it's branches, and
                    another one for the rest of the code after the statement.
                </p>
                <pre><code>
    ┌─────────────────────────────────────────────┐
    │ br i1 %con, label %if.true, label %if.false │
    └─────────────────────────────────────────────┘
               ┌───────────┴───────────┐
               V                       V
    ┌─────────────────────┐ ┌─────────────────────┐
    │ if.true:            │ │ if.false:           │
    │   br label %if.exit │ │   br label %if.exit │
    └─────────────────────┘ └─────────────────────┘
               └───────────┬───────────┘
                           V            
                ┌─────────────────────┐
                │ if.exit:            │
                │   ...               │
                └─────────────────────┘
  </code></pre>
                <p>
                    When there is no <code>else</code> block in the source code,
                    the exit block is treated as the else block.
                </p>
                <pre><code>
    ┌─────────────────────────────────────────────┐
    │ br i1 %cond, label %if.true, label %if.exit │
    └─────────────────────────────────────────────┘
               ┌───────────┴───────────┐
               V                       │
    ┌─────────────────────┐            │
    │ if.true:            │            │
    │   br label %if.exit │            │
    └─────────────────────┘            │
               ├───────────────────────┘
               V                       
    ┌─────────────────────┐
    │ if.exit:            │
    │   ...               │
    └─────────────────────┘
  </code></pre>
                <p>
                    First a new basic block is created for the true, false and
                    exit blocks. Unless there is an explicit false block, the
                    false block is set to the exit block as mentioned.
                </p>
                <pre><code>llvm::Value *Codegen::generateIfStmt(const ResolvedIfStmt &stmt) {
  llvm::Function *function = getCurrentFunction();
  auto *trueBB = llvm::BasicBlock::Create(context, "if.true");
  auto *exitBB = llvm::BasicBlock::Create(context, "if.exit");

  llvm::BasicBlock *elseBB = exitBB;
  if (stmt.falseBlock)
    elseBB = llvm::BasicBlock::Create(context, "if.false");

  ...
}</code></pre>
                <p>
                    Then the condition is generated followed by the two blocks.
                    Finally the blocks are inserted into the function and the
                    insertion point is set to the exit block.
                </p>
                <pre><code>llvm::Value *Codegen::generateIfStmt(const ResolvedIfStmt &stmt) {
  ...

  llvm::Value *cond = generateExpr(*stmt.condition);
  builder.CreateCondBr(doubleToBool(cond), trueBB, elseBB);

  trueBB->insertInto(function);
  builder.SetInsertPoint(trueBB);
  generateBlock(*stmt.trueBlock);
  builder.CreateBr(exitBB);

  if (stmt.falseBlock) {
    elseBB->insertInto(function);
    builder.SetInsertPoint(elseBB);
    generateBlock(*stmt.falseBlock);
    builder.CreateBr(exitBB);
  }

  exitBB->insertInto(function);
  builder.SetInsertPoint(exitBB);
  return nullptr;
}</code></pre>
                <h2>Loops</h2>
                <p>
                    Loops come in handy if the same statement has to be repeated
                    multiple times. Without them the developer would be required
                    to write the same statement on multiple lines after each
                    other, unless the number of times the statement needs to be
                    run is unknown. In that case the problem becomes difficult
                    to solve without a dedicated element in the language. In
                    <i>your language</i> this dedicated element is the
                    <code>while</code> loop.
                </p>
                <pre><code>&lt;whileStatement>
  ::= 'while' &lt;expr> &lt;block></code></pre>
                <p>
                    The grammar rule introduces a new keyword,
                    <code>while</code>.
                </p>
                <pre><code>enum class TokenKind : char {
  ...
  KwWhile,
  ...
};

const std::unordered_map&lt;std::string_view, TokenKind> keywords = {
    ..., {"while", TokenKind::KwWhile}};</code></pre>
                <p>
                    The AST node of <code>while</code> stores the condition and
                    a block.
                </p>
                <pre><code>struct WhileStmt : public Stmt {
  std::unique_ptr&lt;Expr> condition;
  std::unique_ptr&lt;Block> body;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>
                    As in case of every other statement, the parsing is driven
                    by <code>parseStmt()</code>.
                </p>
                <pre><code>std::unique_ptr&lt;Stmt> Parser::parseStmt() {
  ...

  if (nextToken.kind == TokenKind::KwWhile)
    return parseWhileStmt();

  ...
}</code></pre>
                <p>
                    The <code>parseWhileStmt()</code> method is small and
                    simple. It parses the condition and the body if exists. If
                    everything is successful, the AST node is returned.
                </p>
                <pre><code>std::unique_ptr&lt;WhileStmt> Parser::parseWhileStmt() {
  SourceLocation location = nextToken.location;
  eatNextToken(); // eat 'while'

  varOrReturn(cond, parseExpr());

  if (nextToken.kind != TokenKind::Lbrace)
    return report(nextToken.location, "expected 'while' body");

  varOrReturn(body, parseBlock());

  return std::make_unique&lt;WhileStmt>(location, std::move(cond),
                                     std::move(body));
}</code></pre>
                <p>
                    Similar to the <code>if</code> statement, the resolved node
                    of <code>while</code> is identical to it's non-resolved
                    counterpart.
                </p>
                <pre><code>struct ResolvedWhileStmt : public ResolvedStmt {
  std::unique_ptr&lt;ResolvedExpr> condition;
  std::unique_ptr&lt;ResolvedBlock> body;

  // the constructor and dump() are omitted
  ...
};</code></pre>
                <p>The resolution is driven by <code>resolveStmt()</code>.</p>
                <pre><code>std::unique_ptr&lt;ResolvedStmt> Sema::resolveStmt(const Stmt &stmt) {
  ...

  if (auto *whileStmt = dynamic_cast&lt;const WhileStmt *>(&stmt))
    return resolveWhileStmt(*whileStmt);

  ...
}</code></pre>
                <p>
                    First the condition is resolved, then the body. The
                    condition must be a number, which is also evaluated as a
                    compile time expression. If everything is successful, the
                    corresponding resolved node is returned.
                </p>
                <pre><code>std::unique_ptr&lt;ResolvedWhileStmt>
Sema::resolveWhileStmt(const WhileStmt &whileStmt) {
  varOrReturn(condition, resolveExpr(*whileStmt.condition));

  if (condition->type.kind != Type::Kind::Number)
    return report(condition->location, "expected number in condition");

  varOrReturn(body, resolveBlock(*whileStmt.body));

  condition->setConstantValue(cee.evaluate(*condition, false));

  return std::make_unique&lt;ResolvedWhileStmt>(
      whileStmt.location, std::move(condition), std::move(body));
}</code></pre>
                <p>Code generation is driven by <code>generateStmt()</code>.</p>
                <pre><code>llvm::Value *Codegen::generateStmt(const ResolvedStmt &stmt) {
  ...

  if (auto *whileStmt = dynamic_cast&lt;const ResolvedWhileStmt *>(&stmt))
    return generateWhileStmt(*whileStmt);

  ...
}</code></pre>
                <p>
                    A <code>while</code> loop in LLVM IR is similar to a
                    condition. The condition is placed into a separate basic
                    block, as it has to be evaluated after every iteration. One
                    more block is created for the body of the loop, which always
                    jumps back to the condition and one block is created for the
                    rest of the code that runs after the loop.
                </p>
                <pre><code>               ┌───────────────────────┐
               │ ...                   │
               │ br label %while.cond  │
               └───────────────────────┘
                           |
                           V
┌─────────────────────────────────────────────────────┐
│ while.cond:                                         │
│   ...                                               │
│   br i1 %cond, label %while.body, label %while.exit │
└─────────────────────────────────────────────────────┘
    |                ^                   |             
    V                |                   V              
┌────────────────────────┐   ┌────────────────────────┐
│ while.body:            │   │ while.exit:            │
│   br label %while.cond │   │   ...                  │
└────────────────────────┘   └────────────────────────┘</code></pre>
                <p>
                    First the blocks for the condition, cody and the rest of the
                    code are created. By convention the block with the condition
                    is called the header of the loop. A jump to the header is
                    also inserted into the current block.
                </p>
                <pre><code>llvm::Value *Codegen::generateWhileStmt(const ResolvedWhileStmt &stmt) {
  llvm::Function *function = getCurrentFunction();
  auto *header = llvm::BasicBlock::Create(context, "while.cond", function);
  auto *body = llvm::BasicBlock::Create(context, "while.body", function);
  auto *exit = llvm::BasicBlock::Create(context, "while.exit", function);

  builder.CreateBr(header);

  ...
}</code></pre>
                <p>
                    Next the condition is generated into the header and the jump
                    instruction to either the body or the exit is inserted.
                </p>
                <pre><code>llvm::Value *Codegen::generateWhileStmt(const ResolvedWhileStmt &stmt) {
  ...

  builder.SetInsertPoint(header);
  llvm::Value *cond = generateExpr(*stmt.condition);
  builder.CreateCondBr(doubleToBool(cond), body, exit);

  ...
}</code></pre>
                <p>
                    Finally, the body of the loop is generated into the
                    corresponding block followed by the insertion a jump back to
                    header. Upon finishing the generation of the body, the
                    insert point is set to the exit block.
                </p>
                <pre><code>llvm::Value *Codegen::generateWhileStmt(const ResolvedWhileStmt &stmt) {
  ...

  builder.SetInsertPoint(body);
  generateBlock(*stmt.body);
  builder.CreateBr(header);

  builder.SetInsertPoint(exit);
  return nullptr;
}</code></pre>
                <h2>The Control Flow Graph</h2>
                <p>
                    The control flow graph is a graph representation of all
                    paths the program might traverse during it's execution. It
                    is a required data structure for many optimization and
                    analysis techniques. It is also essential for any kind of
                    flow sensitive reasoning about the program. It can be used
                    to make code generation easier, or to perform the symbolic
                    execution on the program.
                </p>
                <p>
                    How the CFG is constructed varies on what it is going to be
                    used for. This compiler uses it for performing a simple flow
                    sensitive analysis and data-flow analysis later, so the
                    minimalistic CFG is constructed with these goals in mind.
                </p>
                <blockquote>
                    <h3>Design Note</h3>
                    <p>
                        Different production ready compilers construct different
                        control flow graphs and use them for different purposes.
                    </p>
                    <p>
                        In Clang the CFG was created for the Clang Static
                        Analyzer to be able to perform symbolic execution. As a
                        result the Clang CFG is the list of the statements in
                        the program in the order they are executed. This way the
                        Clang Static Analyzer can traverse statements from top
                        to bottom and simulate executing them.
                    </p>
                    <pre><code>                 [B1]
                    1: 0
                    2: int x = 0;
                    3: x
int x = 0;          4: [B1.3] (ImplicitCastExpr, ...)
int y = x;          5: int y = x;                    
x = 1;              6: 1                             
                    7: x
                    8: [B1.7] = [B1.6]
                    Preds (1): B2
                    Succs (1): B0</code></pre>
                    <p>
                        Notice that <code>[B1.3]</code> and
                        <code>[B1.7]</code> are the same statements. The former
                        is reading the value of <code>x</code> and at the latter
                        <code>x</code> is about to be assigned a value, but this
                        information is not known while traversing the CFG and it
                        can be an issue if the CFG is used for data flow
                        analysis or code generation. During code generation
                        <code>[B1.3]</code> needs to be a load instruction,
                        while <code>[B1.7]</code> needs to be a store.
                    </p>
                    <p>
                        The Kotlin CFG on the other hand was designed for data
                        flow analysis, so it is an SSA form.
                    </p>
                    <pre><code>                 $1 = 0
                 x = $1
var x = 0        
val y = x        $2 = x
x = 1            y = $2
        
                 $3 = 1
                 x = $3</code></pre>
                    <p>
                        Here it can be clearly seen that when <code>x</code> is
                        on the LHS, it's an assignment and when it's on the RHS,
                        it's reading it's value.
                    </p>
                </blockquote>
                <p>
                    The CFG consists of basic blocks. Each basic block consists
                    of a set of statements that execute together as well as a
                    list of predecessors from which the program can enter this
                    block and a set of successors to which the program can
                    continue from it.
                </p>
                <pre><code>struct BasicBlock {
  std::set&lt;std::pair&lt;int, bool>> predecessors;
  std::set&lt;std::pair&lt;int, bool>> successors;
  std::vector&lt;const ResolvedStmt *> statements;
};</code></pre>
                <p>
                    In the <code>predecessors</code> and
                    <code>successors</code> sets, the <code>int</code> refers to
                    the index of the block, while the
                    <code>bool</code> indicates whether that block is reachable
                    or not.
                </p>
                <p>
                    The CFG is modelled as a list of basic blocks. It also knows
                    which block is the entry of the function and which is the
                    exit.
                </p>
                <pre><code>struct CFG : public Dumpable {
  std::vector&lt;BasicBlock> basicBlocks;
  int entry = -1;
  int exit = -1;

  ...
};</code></pre>
                <p>Three operations are supported on the CFG</p>
                <ol>
                    <li>Inserting a new block.</li>
                    <li>Inserting a statement into a block.</li>
                    <li>Inserting an edge between blocks.</li>
                </ol>
                <pre><code>struct CFG : public Dumpable {
  ...
  int insertNewBlock() {
    basicBlocks.emplace_back();
    return basicBlocks.size() - 1;
  };

  int insertNewBlockBefore(int before, bool reachable) {
    int b = insertNewBlock();
    insertEdge(b, before, reachable);
    return b;
  }

  void insertEdge(int from, int to, bool reachable) {
    basicBlocks[from].successors.emplace(std::make_pair(to, reachable));
    basicBlocks[to].predecessors.emplace(std::make_pair(from, reachable));
  }

  void insertStmt(const ResolvedStmt *stmt, int block) {
    basicBlocks[block].statements.emplace_back(stmt);
  }
  ...
};</code></pre>
                <p>
                    The logic for constructing a CFG is found in the
                    <code>CFGBuilder</code> class. It takes a function and
                    builds the CFG for that function.
                </p>
                <pre><code>class CFGBuilder {
  CFG cfg;

public:
  CFG build(const ResolvedFunctionDecl &fn);
};</code></pre>
                <p>
                    The construction of the CFG happens from the end of the
                    function to the beginning of the function. The
                    <code>build</code> method first creates the exit block, then
                    inserts the body of the function and finally inserts the
                    entry block.
                </p>
                <p>
                    Return statements automatically jump to the exit block, so
                    by inserting the exit block first, the edge between the
                    block ending with a return statement and the exit block can
                    immediately be inserted. From a top to bottom construction
                    these blocks would need to be collected first and the edges
                    can only be inserted once the builder finished processing
                    the function.
                </p>
                <pre><code>CFG CFGBuilder::build(const ResolvedFunctionDecl &fn) {
  cfg = {};
  cfg.exit = cfg.insertNewBlock();

  int body = insertBlock(*fn.body, cfg.exit);

  cfg.entry = cfg.insertNewBlockBefore(body, true);
  return cfg;
};</code></pre>
                <p>
                    The <code>insertBlock()</code> method first creates a new
                    CFG block for the given block if the block is not empty and
                    then it traverses the statements of that block in a reverse
                    order and inserts them into the current CFG block. To be
                    able to create the <code>BasicBlock</code>, it takes the
                    successor block as a parameter. The returned
                    <code>BasicBlock</code> is the current one at the start of
                    the block.
                </p>
                <pre><code>int CFGBuilder::insertBlock(const ResolvedBlock &block, int succ) {
  const auto &stmts = block.statements;

  bool insertNewBlock = true;
  for (auto it = stmts.rbegin(); it != stmts.rend(); ++it) {
    if (insertNewBlock)
      succ = cfg.insertNewBlockBefore(succ, true);

    insertNewBlock = false;
    succ = insertStmt(**it, succ);
  }

  return succ;
}</code></pre>
                <pre><code>fn cfgConstruction(): void {
    stmt1;
    stmt2;
    stmt3;
}

1.) create the exit block for the function
┌─────────┐
│ fn.exit │
└─────────┘      

2.) insertBlock(fn.body, fn.exit)
                     return this block -> ┌─────────┐
                            ┌─────────┐   │  stmt1; │
┌─────────┐   ┌─────────┐   │  stmt2; │   │  stmt2; │
│         │   │  stmt3; │   │  stmt3; │   │  stmt3; │
└─────────┘   └─────────┘   └─────────┘   └─────────┘
     │             │             │             │     
     V             V             V             V     
┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐
│ fn.exit │   │ fn.exit │   │ fn.exit │   │ fn.exit │
└─────────┘   └─────────┘   └─────────┘   └─────────┘

3.) create and insert the entry block
┌──────────┐
│ fn.entry │
└──────────┘
     │ 
     V 
┌─────────┐
│  stmt1; │
│  stmt2; │
│  stmt3; │
└─────────┘
     │     
     V     
┌─────────┐
│ fn.exit │
└─────────┘</code></pre>
                <p>
                    The <code>insertStmt()</code> method takes the statement and
                    the basic block to which the statement should be inserted
                    into as parameters. It then dispatches the correct insert
                    function for the given statement.
                </p>
                <pre><code>int CFGBuilder::insertStmt(const ResolvedStmt &stmt, int block) {
  if (auto *ifStmt = dynamic_cast&lt;const ResolvedIfStmt *>(&stmt))
    return insertIfStmt(*ifStmt, block);

  if (auto *whileStmt = dynamic_cast&lt;const ResolvedWhileStmt *>(&stmt))
    return insertWhileStmt(*whileStmt, block);

  if (auto *expr = dynamic_cast&lt;const ResolvedExpr *>(&stmt))
    return insertExpr(*expr, block);

  auto *returnStmt = dynamic_cast&lt;const ResolvedReturnStmt *>(&stmt);
  assert(returnStmt && "unexpected statement");

  return insertReturnStmt(*returnStmt, block);
}</code></pre>
                <p>
                    When a return statement is inserted, the builder stops
                    processing the current block and creates a new one right
                    before the exit block. Because the graph is constructed from
                    bottom to top, the <code>ReturnStmt</code> is inserted
                    first, then the expression whose result it returns.
                </p>
                <pre><code>int CFGBuilder::insertReturnStmt(const ResolvedReturnStmt &stmt, int block) {
  block = cfg.insertNewBlockBefore(cfg.exit, true);

  cfg.insertStmt(&stmt, block);
  if (stmt.expr)
    return insertExpr(*stmt.expr, block);

  return block;
}</code></pre>
                <pre><code>fn cfgConstruction(): number {
    stmt1;
    return 0;
    stmt2;
}
1.) insert stmt2
┌─────────┐
│  stmt2; │
└─────────┘
     │     
     V     
┌─────────┐
│ fn.exit │
└─────────┘

2.) insertReturnStmt()
                      return this block -> ┌─────────┐
  ┌─────────┐        ┌─────────┐           │      0; │
┌─│         │      ┌─│ return; │         ┌─│ return; │
│ └─────────┘      │ └─────────┘         │ └─────────┘
│ ┌─────────┐      │ ┌─────────┐         │ ┌─────────┐
│ │  stmt2; │─┐    │ │  stmt2; │─┐       │ │  stmt2; │─┐
│ └─────────┘ │    │ └─────────┘ │       │ └─────────┘ │
│ ┌─────────┐ │    │ ┌─────────┐ │       │ ┌─────────┐ │
└>│ fn.exit │&lt;┘    └>│ fn.exit │&lt;┘       └>│ fn.exit │&lt;┘
  └─────────┘        └─────────┘           └─────────┘

3.) insert stmt1
  ┌─────────┐
  │  stmt1; │
  │      0; │
┌─│ return; │
│ └─────────┘
│ ┌─────────┐
│ │  stmt2; │─┐
│ └─────────┘ │
│ ┌─────────┐ │
└>│ fn.exit │&lt;┘
  └─────────┘
</code></pre>
                <p>
                    In case of expressions, first the expression is inserted,
                    then it's child expressions in a reverse order of their
                    evaluation.
                </p>
                <pre><code>int CFGBuilder::insertExpr(const ResolvedExpr &expr, int block) {
  cfg.insertStmt(&expr, block);

  if (const auto *call = dynamic_cast&lt;const ResolvedCallExpr *>(&expr)) {
    for (auto it = call->arguments.rbegin(); it != call->arguments.rend(); ++it)
      insertExpr(**it, block);
    return block;
  }

  if (const auto *grouping = dynamic_cast&lt;const ResolvedGroupingExpr *>(&expr))
    return insertExpr(*grouping->expr, block);

  if (const auto *binop = dynamic_cast&lt;const ResolvedBinaryOperator *>(&expr))
    return insertExpr(*binop->rhs, block), insertExpr(*binop->lhs, block);

  if (const auto *unop = dynamic_cast&lt;const ResolvedUnaryOperator *>(&expr))
    return insertExpr(*unop->rhs, block);

  return block;
}
</code></pre>
                <p>
                    For conditional binary operators, this insertion tactics
                    leads to a not completely accurate CFG.
                </p>
                <pre><code>stmt1;
1 || 2;
stmt2;

┌─────────┐
│  stmt1; │
│      1; │
│      2; │
│     ||; │
│  stmt2; │
└─────────┘</code></pre>
                <p>
                    Because the <code>||</code> and <code>&&</code> operators
                    are lazily evaluated, if the LHS yields a result from which
                    the result of the whole operator can be determined, the RHS
                    is not evaluated. Depending on the goal of the CFG this
                    should also be modelled.
                </p>
                <pre><code>stmt1;
1 || 2;
stmt2;

┌─────────┐
│  stmt1; │
│      1; │─────┐
└─────────┘     V
     │     ┌─────────┐
     │     │      2; │
     V     └─────────┘
┌─────────┐     │
│     ||; │&lt;────┘
│  stmt2; │
└─────────┘</code></pre>
                <p>
                    Since this compiler wouldn't take advantage of such
                    accuracy, the CFG and it's construction is kept as simple as
                    possible.
                </p>
                <p>
                    In case of an <code>IfStmt</code> the inserter method takes
                    the successor block as parameter. If there is a false block,
                    it is inserted first, otherwise the exit block is considered
                    the false block.
                </p>
                <pre><code>int CFGBuilder::insertIfStmt(const ResolvedIfStmt &stmt, int exit) {
  int falseBlock = exit;
  if (stmt.falseBlock)
    falseBlock = insertBlock(*stmt.falseBlock, exit);

  ...
}</code></pre>
                <p>
                    This is followed by the insertion of the true block and the
                    creation of the entry block.
                </p>
                <pre><code>int CFGBuilder::insertIfStmt(const ResolvedIfStmt &stmt, int exit) {
  ...

  int trueBlock = insertBlock(*stmt.trueBlock, exit);
  int entry = cfg.insertNewBlock();

  ...
}</code></pre>
                <p>
                    The tree walk interpreter is invoked to determine if the
                    condition is always true or not. Since in this case even
                    statements like <code>sideEffects() || true</code> should be
                    returned as <code>true</code>, the interpreter is invoked
                    with the <code>allowSideEffects</code> option turned on.
                </p>
                <p>
                    The true block is reachable only if the condition is not
                    false, while the false block is reachable only if the
                    condition is not true.
                </p>
                <pre><code>int CFGBuilder::insertIfStmt(const ResolvedIfStmt &stmt, int exit) {
  ...

  std::optional&lt;double> val = cee.evaluate(*stmt.condition, true);
  cfg.insertEdge(entry, trueBlock, val != 0);
  cfg.insertEdge(entry, falseBlock, val.value_or(0) == 0);

  ...
}</code></pre>
                <p>
                    Finally the statement itself is inserted into the entry
                    block followed by the insertion of the condition.
                </p>
                <pre><code>int CFGBuilder::insertIfStmt(const ResolvedIfStmt &stmt, int exit) {
  ...

  cfg.insertStmt(&stmt, entry);
  return insertExpr(*stmt.condition, entry);
}</code></pre>
                <pre><code>fn cfgConstruction(): number {
    stmt1;

    if cond {
      stmt2;
    } else {
      stmt3;
    }

    stmt4;
}

1.) insert stmt4
┌─────────┐
│  stmt4; │
└─────────┘
     │     
     V     
┌─────────┐
│ fn.exit │
└─────────┘

2.) insertIfStmt()
                     return this block -> ┌─────────┐
                                          │   cond; │
                                          │     if; │─┐
                                          └─────────┘ │
                                               │      │
                                               V      │
                     ┌─────────┐          ┌─────────┐ │
                   ┌─│  stmt2; │        ┌─│  stmt2; │ │
                   │ └─────────┘        │ └─────────┘ │
┌─────────┐        │ ┌─────────┐        │ ┌─────────┐ │
│  stmt3; │        │ │  stmt3; │        │ │  stmt3; │&lt;┘
└─────────┘        │ └─────────┘        │ └─────────┘
     │             │      │             │      │     
     V             │      V             │      V     
┌─────────┐        │ ┌─────────┐        │ ┌─────────┐
│  stmt4; │        └>│  stmt4; │        └>│  stmt4; │
└─────────┘          └─────────┘          └─────────┘
     │                    │                    │     
     V                    V                    V     
┌─────────┐          ┌─────────┐          ┌─────────┐
│ fn.exit │          │ fn.exit │          │ fn.exit │
└─────────┘          └─────────┘          └─────────┘

3.) insert stmt1
  ┌─────────┐
  │  stmt1; │
  │   cond; │
  │     if; │─┐
  └─────────┘ │
       │      │
      ...</code></pre>
                <p>
                    The last statement to handle is the <code>WhileStmt</code>.
                    For the loop one additional helper node is inserted, by
                    terminology called the <code>latch</code>. This is the node
                    that loops back to the condition with only the body of the
                    loop as it's predecessor. Then the header is inserted along
                    with an edge between the latch and the header.
                </p>
                <pre><code>int CFGBuilder::insertWhileStmt(const ResolvedWhileStmt &stmt, int exit) {
  int latch = cfg.insertNewBlock();
  int body = insertBlock(*stmt.body, latch);

  int header = cfg.insertNewBlock();
  cfg.insertEdge(latch, header, true);

  ...
}</code></pre>
                <p>
                    For the condition it's checked if it's value is known in
                    compile time and the reachability of the edges are set
                    accordingly.
                </p>
                <pre><code>int CFGBuilder::insertWhileStmt(const ResolvedWhileStmt &stmt, int exit) {
  ...

  std::optional&lt;double> val = cee.evaluate(*stmt.condition, true);
  cfg.insertEdge(header, body, val != 0);
  cfg.insertEdge(header, exit, val.value_or(0) == 0);

  ...
}</code></pre>
                <p>
                    Finally the statement and the condition are inserted into
                    the header node and the header is returned.
                </p>
                <pre><code>int CFGBuilder::insertWhileStmt(const ResolvedWhileStmt &stmt, int exit) {
  ...

  cfg.insertStmt(&stmt, header);
  insertExpr(*stmt.condition, header);

  return header;
}</code></pre>
                <p>
                    Because the header houses the condition, if there is any
                    other statement before the header, a new block needs to be
                    created before the header that houses thT statement.
                </p>
                <pre><code>int CFGBuilder::insertBlock(const ResolvedBlock &block, int succ) {
  ...

  for (auto it = stmts.rbegin(); it != stmts.rend(); ++it) {
    ...
    insertNewBlock = dynamic_cast&lt;const ResolvedWhileStmt *>(it->get());
    ...
  }

  ...
}</code></pre>
                <pre><code>fn cfgConstruction(): number {
    stmt1;

    while cond {
      stmt2;
    }

    stmt3;
}

1.) insert stmt3
┌─────────┐
│  stmt3; │
└─────────┘
     │     
     V     
┌─────────┐
│ fn.exit │
└─────────┘

2.) insertWhileStmt()
                                          ┌─────────┐
                                          │   cond; │
                                        ┌─│  while; │&lt;┐
                                        │ └─────────┘ │
                                        │      │      │
                                        │      V      │
                            ┌─────────┐ │ ┌─────────┐ │
                            │  stmt2; │ │ │  stmt2; │ │
                            └─────────┘ │ └─────────┘ │
                                 │      │      │      │
                                 V      │      V      │
              ┌─────────┐   ┌─────────┐ │ ┌─────────┐ │
              │  latch  │   │  latch  │ │ │  latch  │─┘
              └─────────┘   └─────────┘ │ └─────────┘
┌─────────┐   ┌─────────┐   ┌─────────┐ │ ┌─────────┐
│  stmt3; │   │  stmt3; │   │  stmt3; │ └>│  stmt3; │
└─────────┘   └─────────┘   └─────────┘   └─────────┘
     │             │             │             │     
     V             V             V             V     
┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐
│ fn.exit │   │ fn.exit │   │ fn.exit │   │ fn.exit │
└─────────┘   └─────────┘   └─────────┘   └─────────┘

3.) insert stmt1
  ┌─────────┐
  │  stmt1; │
  └─────────┘
       │     
       V     
  ┌─────────┐
  │   cond; │
┌─│  while; │&lt;┐
│ └─────────┘ │
│      │      │
      ...</code></pre>
                <p>
                    One additional case to handle is that if a block is about to
                    be created but the current statement that is going to be
                    inserted into the new block is a statement that terminates a
                    block, like <code>ReturnStmt</code>,
                    <code>WhileStmt</code> and <code>IfStmt</code>, the block
                    shouldn't be created. A terminating statement creates a new
                    block on it's own and the created block would stay empty.
                </p>
                <pre><code>int CFGBuilder::insertBlock(const ResolvedBlock &block, int succ) {
  ...
    if (insertNewBlock && !isTerminator(**it))
      succ = cfg.insertNewBlockBefore(succ, true);
  ...
}</code></pre>

                <p>
                    The terminator statements are the ones already listed above.
                </p>
                <pre><code>bool isTerminator(const ResolvedStmt &stmt) {
  return dynamic_cast&lt;const ResolvedIfStmt *>(&stmt) ||
         dynamic_cast&lt;const ResolvedWhileStmt *>(&stmt) ||
         dynamic_cast&lt;const ResolvedReturnStmt *>(&stmt);
}</code></pre>
                <pre><code>incorrect graph:
                        ┌─────────┐
                        │ return; │
                        └─────────┘       
                             |
                             V
            ┌─────────┐ ┌─────────┐
            │         │ │         │
            └─────────┘ └─────────┘
                 |           |
                 V           V
┌─────────┐ ┌─────────┐ ┌─────────┐
│ return; │ │ return; │ │ return; │
└─────────┘ └─────────┘ └─────────┘

correct graph:
            ┌─────────┐
            │ return; │
            └─────────┘
                 |     
                 V     
┌─────────┐ ┌─────────┐
│ return; │ │ return; │
└─────────┘ └─────────┘</code></pre>
                <p>
                    The users of the compiler are provided with the option to
                    visualize the generated control flow graph, but first the
                    <code>dump()</code> method of the CFG needs to be defined.
                </p>
                <p>
                    Because the entry block is inserted last, the block are
                    printed in a reverse order, so that the CFG dump starts with
                    the entry block.
                </p>
                <pre><code>void CFG::dump(size_t) const {
  for (int i = basicBlocks.size() - 1; i >= 0; --i) {
    ...
  }
}</code></pre>
                <p>
                    First the identifier of the block is printed and whether
                    it's the entry or the exit block.
                </p>
                <pre><code>void CFG::dump(size_t) const {
  for (int i = basicBlocks.size() - 1; i >= 0; --i) {
    std::cerr << '[' << i;
    if (i == entry)
      std::cerr << " (entry)";
    else if (i == exit)
      std::cerr << " (exit)";
    std::cerr << ']' << '\n';

    ...
  }
}</code></pre>
                <p>
                    After the id of the block, the predecessors and successors
                    are printed.
                </p>
                <pre><code>void CFG::dump(size_t) const {
  for (int i = basicBlocks.size() - 1; i >= 0; --i) {
    ...

    std::cerr << "  preds: ";
    for (auto &&[id, reachable] : basicBlocks[i].predecessors)
      std::cerr << id << ((reachable) ? " " : "(U) ");
    std::cerr << '\n';

    std::cerr << "  succs: ";
    for (auto &&[id, reachable] : basicBlocks[i].successors)
      std::cerr << id << ((reachable) ? " " : "(U) ");
    std::cerr << '\n';

    ...
  }
}</code></pre>
                <p>
                    Finally, because the statements have also been inserted from
                    backward, they are also printed in a reverse order.
                </p>
                <pre><code>void CFG::dump(size_t) const {
  for (int i = basicBlocks.size() - 1; i >= 0; --i) {
    ...

    const auto &statements = basicBlocks[i].statements;
    for (auto it = statements.rbegin(); it != statements.rend(); ++it)
      (*it)->dump(1);
    std::cerr << '\n';
  }
}</code></pre>
                <p>
                    To let the users know that the CFG can be visualized, the
                    help message is extended with the
                    <code>-cfg-dump</code> flag.
                </p>
                <pre><code>void displayHelp() {
  ...
            << "  -cfg-dump    print the control flow graph\n";
}</code></pre>
                <p>
                    A corresponding option is added to the
                    <code>CompilerOptions</code> structure.
                </p>
                <pre><code>struct CompilerOptions {
  ...
  bool cfgDump = false;
};</code></pre>
                <p>
                    The argument parser is also extended to be able to handle
                    the newly introduced flag.
                </p>
                <pre><code>CompilerOptions parseArguments(int argc, const char **argv) {
  ...
  while (idx < argc) {
      ...
      else if (arg == "-cfg-dump")
        options.cfgDump = true;
      ...
  }

  ...
}</code></pre>
                <p>
                    The CFG can only be constructed for functions that have been
                    resolved successfully, so the printing of the CFG happens in
                    the driver after the semantic analyzer returns.
                </p>
                <pre><code>int main(int argc, const char **argv) {
  ...

  if (options.cfgDump) {
    for (auto &&fn : resolvedTree) {
      std::cerr << fn->identifier << ':' << '\n';
      CFGBuilder().build(*fn).dump();
    }
    return 0;
  }

  if (resolvedTree.empty())
  ...
}</code></pre>
                <h2>Flow-Sensitive Analysis</h2>
                <p>
                    The first flow sensitive analysis performed during semantic
                    analysis will be to ensure that a function returns a value
                    on every execution path.
                </p>
                <pre><code>std::vector&lt;std::unique_ptr&lt;ResolvedFunctionDecl>> Sema::resolveAST() {
  ...

  for (size_t i = 1; i < resolvedTree.size(); ++i) {
    ...

    currentFunction->body = std::move(resolvedBody);
    error |= runFlowSensitiveChecks(*currentFunction);
  }

  ...
}</code></pre>
                <p>
                    The <code>runFlowSensitiveChecks()</code> first builds the
                    CFG of the function and hands it over to the
                    <code>checkReturnOnAllPaths()</code>, which performs the
                    actual analysis.
                </p>
                <pre><code>bool Sema::runFlowSensitiveChecks(const ResolvedFunctionDecl &fn) {
  CFG cfg = CFGBuilder().build(fn);

  bool error = false;
  error |= checkReturnOnAllPaths(fn, cfg);

  return error;
};</code></pre>
                <p>
                    If the given function doesn't return a value, there is
                    nothing to check, so the function can return immediately.
                </p>
                <pre><code>bool Sema::checkReturnOnAllPaths(const ResolvedFunctionDecl &fn,
                                 const CFG &cfg) {
  if (fn.type.kind == Type::Kind::Void)
    return false;

  ...
}</code></pre>
                <p>
                    The core of the function is a DFS traversal of the reachable
                    CFG blocks.
                </p>
                <pre><code>bool Sema::checkReturnOnAllPaths(const ResolvedFunctionDecl &fn,
                                 const CFG &cfg) {
  ...

  std::set&lt;int> visited;
  std::vector&lt;int> worklist;
  worklist.emplace_back(cfg.entry);

  while (!worklist.empty()) {
    int bb = worklist.back();
    worklist.pop_back();

    if (!visited.emplace(bb).second)
      continue;
    
    ...

    const auto &[preds, succs, stmts] = cfg.basicBlocks[bb];

    for (auto &&[succ, reachable] : succs)
      if (reachable)
        worklist.emplace_back(succ);
  }

  ...
}</code></pre>
                <p>
                    To create more accurate error messages the number of seen
                    return statements is tracked. Because of the way the CFG was
                    constructed, if a block contains a return statement, it must
                    be the first one in the statement list of the block.
                </p>
                <pre><code>bool Sema::checkReturnOnAllPaths(const ResolvedFunctionDecl &fn,
                                 const CFG &cfg) {
  ...

  int returnCount = 0;

  while (!worklist.empty()) {
    ...

    if (!stmts.empty() && dynamic_cast&lt;const ResolvedReturnStmt *>(stmts[0])) {
      ++returnCount;
      continue;
    }

    ...
  }

  ...
}</code></pre>
                <p>
                    If the block ends with a return statement, the successors of
                    that block are not visited. As a result it's enough to keep
                    track of whether the exit block is reached during the
                    traversal. If any path to the exit block is not blocked by a
                    return statement, a value is not returned on that path.
                </p>
                <pre><code>bool Sema::checkReturnOnAllPaths(const ResolvedFunctionDecl &fn,
                                 const CFG &cfg) {
  ...

  bool exitReached = false;

  while (!worklist.empty()) {
    ...
    exitReached |= bb == cfg.exit;
    ...
  }

  ...
}</code></pre>
                <p>
                    After the traversal if the exit block is reached, or there
                    are no return statements an error is reported. If there is
                    no return statement, the function doesn't return a value at
                    all, if there is at least one return statement, the function
                    only returns on some branches. Wether an error is reported
                    is also returned to the caller.
                </p>
                <pre><code>bool Sema::checkReturnOnAllPaths(const ResolvedFunctionDecl &fn,
                                 const CFG &cfg) {
  ...

  if (exitReached || returnCount == 0) {
    report(fn.location,
           returnCount > 0
               ? "non-void function doesn't return a value on every path"
               : "non-void function doesn't return a value");
  }

  return exitReached || returnCount == 0;
}</code></pre>
            </section>
            <footer>
                <p>
                    <small
                        >Hosted on GitHub Pages &mdash; Theme by
                        <a href="https://github.com/orderedlist" target="_blank"
                            >orderedlist</a
                        ></small
                    >
                </p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
        <script src="javascripts/toc.js"></script>
    </body>
</html>
